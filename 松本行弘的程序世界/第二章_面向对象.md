# 第二章 面向对象

### 编程和面向对象的关系

#### 怎样写程序

* 编程风格
* 算法
* 数据结构
* 设计模式
* 开发方法

**编程风格**

编程的细节,比如变量名的选择方法,函数的写法等.

**算法**

==程序就是算法加数据结构==.

**设计模式**

设计软件时,根据以前的设计经验对设计方法进行分类.

**开发方法**

是指开发程序时的设计方法.

#### 多态性

多态就是可以把不同种类的东西当做相同的东西处理.

根据对象不同类型而进行适当地处理就是多态的基本内容.

根据数据类型来进行合适的处理(调用合适的方法),本来就应该是编程语言这种工具应该完成的事.只有实现了这一点,才能称为真正的多态.

**非多态**

		def box_open(box)
			if box_type(box) == "plain"
				puts("打开箱子")
			elsif box_type(box) == "lock"
				...
			end
		end
		
		不是多态,这里要人为的判断.
		
**多态**

		box1.open() 
		box2.open()
		box3.open()
		
		可以理解为给前面式子的值发送 open 消息. 也就是说,他会根据前面式子的值,调用合适的 open 方法.这就是利用了多态性的调用方法.
		

==多态性==可以让程序值关注要处理什么==(what)==,而不是怎么去处理==(how)==.

如果有新数据需要对应处理的话,通过简单的追加就可以实现了,而不需要改动以前的程序,这就是程序具备了扩展性.

### 数据抽象和继承

==多态性==,==数据抽象==和==继承==被称为面向对象编程的三原则.

* 多态性 = 动态绑定
* 数据抽象 = 信息隐藏或封装

#### 复杂性是面向对象的敌人

软件开发的最大敌人是复杂性. 人类的大脑无法做太复杂的处理,记忆力和理解力是有限的.

人类的理解力的局限性给软件生产力带来的限制则各大.人们为了找到迅速开发大规模复杂软件的方法,哪怕牺牲一些性能也在所不惜.

我个人理解是,面向对象有助于提升人们的理解力.所以牺牲一些性能也在所不惜.

#### 结构化编程

基本思想史有序地控制流程.

把程序的执行顺序限制为:

* 顺序
* 分支
* 循环

把共通的处理归结为例程.

结构化编程的==限制==和==抽象化==,是人类处理复杂软件的非常有效的方法.

**限制**

结构化编程的新顺序,分支和循环可以实现一切算法,虽然降低了程序的复杂性和灵活性,但是程序的实现能力并没有降低.
		
**抽象化**

抽象化的目的是我们只需要知道过程的名字,而并不需要知道过程的内部细节.
复杂的结构被黑盒子隐藏起来,这样我们就可以更容易,更好地理解系统的整体结构.

**结构化总结**

现在几乎所有的编程语言都支持结构化编程,结构化编程已经成为了编程的基本常识.

#### 数据抽象化

数据抽象是数据和处理方法的结合.数据和处理方法结合起来成为了黑盒子.

==利于变化==是抽象数据的巨大优点.

对于数据进行操作的一方,并不需要知道其中的处理细节,而只对=="要做什么"==感兴趣.所以隐藏了处理细节的程序会变得更加明确,实现目的也更清楚.

#### 雏形

程序的重复是一切问题的根源.

开发人员要阅读和理解大量的程序,所以程序的可读性直接关系到生产力.

为了避免对象重复,可以采用两种方法来管理对象,

* 原型.用原始对象的副本来作为新的相同的对象.`javascript`.
* 模板.`class`.同样类型的对象分贝属于同样的类.

#### 找出相似的部分来继承

### 多重继承的缺点

* 单一继承: 只能有一个父类的继承.
* 剁成继承: 有多个父类的继承称为多重继承.

#### 为什么需要多重继承

作者举例多重继承:

		秋刀鱼 金枪鱼 继承 鱼,海洋生物
		
		鲸 继承 海洋生物,哺乳类
		
#### 多重继承和单一继承不可分离

单一继承的特点: 继承关系单纯.

单一继承的继承关系是单纯的树结构.

**单一继承**

* 关系单纯就不会发生混乱,实现起来也比较简单.
* 不能通过继承关系来共享程序代码,导致了最后要复制程序.

**多重继承**

* 很自然地做到了单一继承的扩展.
* 可以继承多个类的功能.
* 类之间的关系会变得复杂.

#### goto语句和多重继承比较相似

上文说的结构化编程.分支和循环可以用`goto`语句来实现,单纯的分支和循环组合起来不能直接实现的控制也可以用`goto`语句来实现.`goto`语句具有更强的控制力.

`goto`语句的程序不是一目了然的,结构不容易理解.这样的流程复杂的程序被称为==意大利面条程序==.

多重继承也存在同样的问题.多重继承会导致下列3个问题.

**结构复杂化**

多重继承,一个类有多个父类,这些父类又有自己的父类,那么类之间的关系就很复杂了.

**优先顺序模糊**

继承父类==方法==的顺序不明确.

**功能冲突**

因为有多个父类,所以当不同父类中有相同的方法时会产生冲突.

		D 继承 B,C
		
		B 和 C 有相同的方法时, D继承的是哪个方法就不明确了.
		
#### 解决多重继承的问题

* `interface`: java
* `Mix-in`: Lisp, Ruby

#### 静态语言和动态语言的区别

动态语言: 宽松的编程机制称为==Duck Typing==(鸭子类型检测).

#### 继承的两种含义

* ==实现==的继承用 `extends` 来继承父类.
* ==规格==的继承用 `implements` 来指定接口.

#### 接口的缺点

用接口来解决多重继承问题.但是接口有不能共享实现的缺点.

`Java`推荐的解决共享实现问题的方案是,在单一继承的前提下,使用组合模式(`Composite`)来挑用别的类实现的共通功能.

#### 从剁成继承变形而来的 `Mix-in`

`Mix-in` 最初是在 `Lisp`中开始使用的.

`Mix-in` 技术按照以下规则来限制多重继承:

* 通常的继承用单一继承.
* 第二个以及连个以上的父类必须是 `Mix-in` 的抽象类

`Mix-in` 类是具有以下特征的抽象类:

* 不能单独生成实例
* 不能继承普通类

实现功能共享的方法是把共享的功能放在`Mix-in`类里面.

#### 积极支持`Mix-in`的`Ruby`

`Mix-in`的单位是模块(`module`).
		
		$ Stram 类, Object 的子类
		class stream < Object
			...
		end
		
		# 输入用 Mix-in
		module Readable
			
			# 定义输入用的方法
			def read
				...
			end
		
		end
		
		# 输出用 Mix-in
		module Writable
			
			# 定义输出用的方法
			def write(str)
				...
			end
			
		end
		
		# 输入用Stream, Stream 的子类
		class ReadStream < Stream
			
			# 继承输入用的Mix-in
			# Ruby 称为include
			include Readable
		
		end
		
		# 输出用Stream, Stream 的子类
		class WiteStream < Stream
		
			# 继承输出用Mix-in
			include Writable
			
		end
		
		# 输入输出用Stream, Stream 的子类
		class ReadWriteStream < Stream
			
			# 继承输入用Mix-in
			include Readable
			
			# 继承输出用Mix-in
			include Writable
			
		end
		
**我个人的理解站在php角度**

php 使用了 `trait` 和 `interface` 一起配合使用解决了多重继承. 我认为 `trait` 和 `Mix-in` 比较类似. 而且同样当 `trait` 的方法和类的方法冲突. 类的方法会被优先执行.

### 两个误解

**第一个误解**

对象是对现实世界中具体物理的反映,继承是对物体分类的反映.

**第二个误解**

多重继承是不好的.

正确的理解应该是, 多重继承如果用得不好就会出现问题. `Mix-in`只不过是实现多重继承的一个技巧而已.

#### 面向对象的编程

现在对面向对象最好理解是,面向对象编程是结构化编程的延伸.

* 顺序: 程序按照顺序执行.
* 循环: 一定的条件成立时程序反复执行.
* 分支: 条件满足时执行A处理,不满足时执行B处理.

结构化编程基本上实现了控制流程的结构化.但是程序流程虽然结构化了,要处理的数据确没有被结构化.面向对象的设计方法是在结构化编程对控制流程实现了结构化后,又加上了==对数据的结构化==.

面向对象编程语言都具有以下共通功能:

1. 不需要知道内部的详细处理就可以进行操作(封装,数据抽象)
2. 根据不同的数据类型自动选择适当的方法(多态性)

黑盒化是模块化的基本原则,面向对象编程语言将每一类数据都当做黑盒处理.

封装和多态是提高生产率的技术.

结构化编程通过整理数据流,提高了程序的生产效率和可维护性.同样,面向对象编程通过对数据结构的整理,提高了程序的生产率和可维护性.

**总结**

如果把面向对象编程看作是对结构化编程的扩展,那么对象是否是现实世界中具体物理的反映就不重要了.实际上,面向对象变成严重的对象,像字符串,数组和范围等,很多都没有现实实践中的具体物体与之对应.即使现实实践中有具体物体与之对应,对象也只是描述现实物理某一侧面的抽象概念而已.比如猫有颜色,血统等很多属性,而程序中的对象并不需要把这些属性都考虑进去.==程序只是处理抽象数据的.==

#### 对象的模板 = 类

类是对象的模板,相当于对象的雏形.

可以把面向对象编程语言的类看做是结构化编程语言的结构体或记录的扩展.==不同==的是,类里面不仅有被称为成员或字段的数据,而且还有对这些"数据块"进行操作的方法.

**类与结构体的不同**

* 结构体: 能做的只是取出或者更新成员变量的值.
* 类: 定义有成员函数,可以调用这些方法来处理类的对象.

**抽象化**

不用考虑内部处理的黑盒化也被称为抽象化,是降低程序复杂度的有效方法.

#### 利用模块的手段 = 继承

继承只不过是抽象的功能利用方法,所以不必把对继承的理解束缚在"继承是对现实失误的分类的反映".

#### 多重继承不好吗

* 单一继承的类之间的关系是很单纯的树结构
* 多重继承的类之间的关系确实复杂的网状结构

**多重继承名字重复解决方案**

* 给父类定义优先级,重复的时候使用优先级高的父类属性.`Common Lisp`
* 把重复的名字替换掉.`Eiffel`
* 指定使用类的名字.`C++`

### DuckTyping 诞生之前

**静态(static)**

静态是指程序执行之前,从代码中就可以知道一切.

**动态(dynamic)**

动态是指在程序之前有些地方是不知道的.

#### 为什么需要类型

编程语言中的类型指的是数据的种类.

#### 动态类型 静态类型

动态类型程序执行时要做类型检查.另外,静态类型的编程语言大都是通过编译把程序源代码转换成可以直接执行的形式,而动态类型的编程怨言大多是==边解释源代码边执行==,这种编译型处理和解释型处理的区别也是影响程序执行速度的原因之一.

运行速度慢这一点,随着计算机性能的提高已经不再重要,现在的程序开发中,程序的灵活性和生产力更为重要.

**动态优点**

编写程序的时候就不用考虑数据类型这些无关本质的部分,而是可以集中于程序处理的本质部分.

#### 只关心行为的Duck Typing

		走起路来像鸭子,叫起来也像鸭子,那么它就是鸭子.
		
如果行为像鸭子,那么不管它是什么,就把它看做鸭子.==根本不考虑一个对象属于什么类,只关心它有什么样的行为(它有哪些方法)==.

#### 动态编程语言

像以前那样,一开始把所有的情况都考虑到,在确定了需求之后再进行开发的方式已经越来越行不通了.尽快着手开发,快速应对需求变更的开发方式变得越来越重要.

### 元编程

"元" 有"超越"和"高阶"等意思.

元编程是对程序进行编程的意思.

#### 元编程

作者用 `attr_accessor` 举例,

		class Person
			attr_accessor :name, :age
		end
		
该方法可以自动为变量生成类似 `set`, `get` 的方法.

#### 反射 reflection

在编程语言中它是指在程序执行时取出程序的信息或者改变程序信息.

#### 元编程的例子

**特异方法**

是指类中没有定义而只存在于示例(对象)中的方法.


#### 后面这几章节关于`dsl`看的理解不够

