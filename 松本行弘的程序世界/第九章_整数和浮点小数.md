# 第九章 整数和浮点小数

### 深奥的整数世界

`Ruby`中,整数相除得到整数.这里和`php`不同.

`php`计算规则如下:

* 除法运算符总是返回浮点数.只有在下列情况例外:两个操作数都是整数(或字符串转换成的整数)并且正好能整除,这时它返回一个整数.

* 取模运算符的操作数在运算之前都会转换成整数(除去小数部分).

#### 整数是有范围的

`C` 语言中有多重表示整数的数据类型.每种数据类型能够表示的整数位数值一定的.位数是指二进制数据的位数.正如刚才所说的,二进制中的1位称作1比特,也可以说==每种数据类型占据的比特数是不一样的==.

`C`语言中如果运算结果超出了规定的位数,不会报错,溢出的位数仅仅被忽视了.

#### 尝试位运算

* `|` 按位或
* `&` 按位与
* `^` 按位异或
* `~` 按位取反
* `<<` 左移
* `>>` 右移

```php

205: 11001001
5: 	      101

201 | 5 = 205
201 $ 5 = 1
201 ^ 5 = 204
```

根据二进制性质:

* ==左移==一位相当于将数变成==2倍==.
* ==右移==一位相当于将数编程==一半==.

```php
php -r "echo 4>>1,PHP_EOL;"
2
```

#### 操作特定的位

计算机中处理各种数据都是以二进制的位来表示的.

* 文本是由字符所对应编码的数字串来组成,各数字串最后还是还原成二进制的比特.
* 图像数据是各个点的颜色按一定形式排列,最后也还是二进制的比特串.
* 程序本身就是二进制的比特穿.

==操作二进制位就等于操作计算机的数据==

**基本 位 处理**

* 取出特定位的状态
* 特定位置位(设为1)
* 特定位清零(设为0)
* 特定位反转

**使用场景**

要从一连串二进制位取出某一特定为`a`的状态.这个功能用按位`与(&)`来实现.准备一个数`B`,只需将想取出那一位置设为1,其余位置设为0,那么取`A`与`B`的按位与,就可以只取出`A`数中的`a`位的状态.

```php
	 ? ? ? ? a ? ? ?    比特串A
	 0 0 0 0 1 0 0 0	比特串B(掩码)
	 0 0 0 0 a 0 0 0 	计算机结果
```

仅生成某一特定位为1的数,可以用移位运算符.使用`1<<n`就可以得到近某一特定位为1的数.

`1<<n` 最低位为0,像左偏移`n`位相当于乘以`2*n`,可以得到最高位为`1`其余位为`0`.

```php
1<<3 = 8 = 1000
1<<2 = 4 = 0100
1<<1 = 2 = 0010
1<<0 = 1 = 0001
```

第`n`位是从最后一位开始数.最低位为0.

**取出整数A第3位的状态**

```php
A & (1<<3)

13: 1101
6:  0110
13 & 6 = 0100 = 4
php -r "echo 14 & 6;"
```

**将变量A的第3位设为1**

用按位或写成以下形式:

```php
A | (1<<3)

13 :    1101 
1<<1:   0010
echo 13 | (1<<1); => 15
```

按与位,可以不管原数内容,而将其某一位设为`1`.

**位清零**

将某一特定位设为0.

要将第2位清零:

```php

A & ~(1<<2)


1<<2 = 0100
~(1<<2) = 1011
A & 1011  = 第2位清零
```

**位反转**

`1`变`0`, `0`变`1`.

$a ^ $b 	`Xor`（按位异或） 	将把 $a 和 $b 中一个为 1 另一个为 0 的位设为 1。

```php
A ^ (1<<3)

A ^ 1000

第3位取反
```

**标志位操作**

用位操作,可以将多个标志位(指定 ON 或者 OFF 的选项)用一个参数来传递.

#### 表示负数的办法

表示负数的方法:

* 开头一位用作符号位
* 将整数的各位反转(1的补数)

```php
8位整数:

第一种方法: 10000001
第二种方法: 11111110
```

负数一般用2的补数来表示.2的补数是将正数的每一位反转,然后加1所得的数.

```php
-1的2的补数:

00000001 (数1)
11111110 (位反转)
11111111 (加1)
```

**2的补数表示负数的优点**

* 可以表示 256 个数. 采用符号位方式或1的补数方式, 0 和 -0 都存在,只能表示255个数.
* 可以直接运算. 2的补数的方式,不考虑符号,直接进行四则运算就可以得到正确结果.

#### Ruby的整数

#### 挑战公开密钥的方式

**最大公约数**

公约数与公倍数相反,就是既是A的约数同时也是B的约数的数,12和15的公约数有1,3,最大公约数就是3.

再举个例子,30和40,它们的公约数有1,2,5,10,最大公约数是10.

在老教材中,公约数就是公因数,一个数最大的约数是它本身,最小的公约数是1.

计算两个数的最大公约数的函数.

		def gcd(x,y)
			if y == 0
				return x
			else
				return gcd(y, x%y)
			end
		end
		
gcd(a,b)=gcd(b,a)

		gcd(40,30) => gcd (30, 40%30) => gcd (30, 10) => (10, 0) => 最大公约数 10
		
**公钥密码加密的原理**

* p 和 q 均为素数

		pq = p x q
		k  = n x (p-1) x (q-1)+1, n为任意正数
		e,d = 能使 e x d = k 的任意正数
		
比如 p=3, q=11, 则 (pq,e) 是公钥, (pq,d)是私钥.

		pq = 33
		k = 1 x (3-1) x (11-1) + 1 = 21
		e, d = 3, 7
		
当 p 与 q 是非常大的素数时,从积 pq 计算素数(素因数分解)并不简单.RSA 安好中一般使用的钥长(pq的位数)是 1024 位(二进制).

RSA 加密的强度)就归因于素因数分解的难度.

`mod`: a ≡ b(mod c) 意思是 a 和 b 除以 c 后余数相同.(同余)

`注意`这里我只是按照公式和自己的理解推导的,不是很确认.

`加密`:

		　加密数据^公钥 ≡ 加密后数据 (mod pq)
		　公钥是(33,3),m 是加密前数据假设是 4
		　
		　4^3(64) ≡ 31(mod 33)
		　
		　这个31我是按照 64 % 33 得到的.
		　
`解密`:

			加密后数据^私钥 = 加密数据 (mod pq)
			31^7(27512614111) = 加密数据 (mod pq)
			
			27512614111%33 = 4 加密前数据
		　
### 扑所迷离的浮点小数

#### 计算机对小数的处理

计算机中的小数被称为==浮点数==(floating point number).

#### 固定小数点数不易使用

==浮点数==: 是指小数点的位置可以移动.==它与计算机中数的表示方法有着密切的关系==.

计算机必须要用某种办法,将含有小数部分的数编程二进制的比特串(编码).

* 抬高小数进行整数化
* 使用科学计数法来表示

抬高小数是指将小数放大,比如说100倍,进行整数化.用于处理明确知道小数点后的有效位数.

缺点:浪费位数. 1 称为 1.00,小数点后的两位就浪费了.在位数一定的情况下,本来能够表示的数就,现在只能表示较小的数了(整数部分的浪费).

#### 科学计数法也有问题

科学计数法是指将有效数字和指数组合起来表示小数(实数).

		2.5 x 10^4 = 25000
		
以上是用十进制,必须变为二进制的比特串:

`IEEE754`:

* 单精度(float) 32位
* 双精度(double) 64位

#### 小数不能完全表示

限制:

* 计算机中数的表示有长度(位数)限制.
* 计算机中数的表示是二进制.

浮点数在计算机内部是以二进制表示的,能以十进制除得尽的数,在二进制也是除不尽的.

		小数 0.2 是 1 除以 5 所得到的结果.
		但是在二进制是循环小数 0,00011001100...
		
==浮点数其实是真是数的近似,所以产生了限制==

**浮点数是有限的**

数学上有的数是无限多位,浮点数只能拥有有限信息.

* 单精度的浮点数只有 32 位.
* 双精度的只有 64 位.

**浮点数有误差**

任意的实数,只要是用有效数字和指数的组合来近似表示的,有效数字的不足部分被简单地忽略.多次运算结果与理论值偏差很大.

**对于浮点数小数,结合法不成立**

==结合法== 是指 加法 和 乘法,不管计算顺序怎样,计算结果都相同的法则.

		(a + b) x c
		
		(a + B)产生的误差有被扩大的可能.
		
		(a x c) + (b x c) 误差会变小.
		
#### 又不能比较的时候

浮点数运算的例子, 0,1 相加 10 次不能变成 1.0

```php
我自己用php写的例子
<?php

$one = 1.0;
$sum = 0.0;

for ($i = 0; $i < 10; $i++)
{
    $sum += 0.1;
}

echo $sum,PHP_EOL;
echo $one,PHP_EOL;

var_dump($sum == $one);
echo $one - $sum,PHP_EOL;

输出:
1
1
bool(false)
1.1102230246252E-16
```

这与 0.1 是用二进制表示的循环小数有关.假设计算是以用二进制能除尽的 0.5 来加 10 次,就不会产生误差了.

对浮点数进行比较运算, 只有两个数在内部表示完全相同的情况下裁判定为相等.

#### 误差积累

```php
<?php

$one = 1.0;
$mul = 0.1 * 10;

echo $one,PHP_EOL;
echo $mul,PHP_EOL;

var_dump($one == $mul);

echo $one - $mul;

输出:
1
1
bool(true)
0
```

与加法的对比,

* 二进制不能除尽的数 0.1 相加的节骨哦也是除不尽的数,所以就在双精度的表示范围内进行舍入.
* 加法: 计算后舍入,重复10次,误差就积累起来了.
* 乘法: 运算只对结果舍入1次,与10次加法相比,误差要少得多.

#### 不是数的特别"数"

`IEEE754`,除了普通的数,还定义了几个特别的数,用于不同于不同数的目的.

**无限大**

为了==表示在浮点数范围内无法表示的大数==,提供了无限大(`Inf`)这个特别的数.

用于表示==溢出错误==.

`C`语言中,整数运算发生溢出后,运算结果会变成某一适当的值,而不产生错误.

`IEEE754`方式下,发生溢出时,不是将结果变成某一适当的值,而是使用无限大来表示溢出错误.

**零**

`IEEE754`中,零有符号,正零和负零要区别对待.

在除以零的时候,为了将结果区分为正无限大或是负无限大.

**NaN**

`NaN` 是 `Not a Number(非数)`.

`NaN`是为了表示未定义的结果错误.

`NaN`不是正常值,含`NaN`的运算结果依然是`NaN`. 包括`NaN`自身,`NaN`与任何数都不一致.

#### 计算误差有多种

**舍入误差**

循环小数及无理数等有限多小数位的数,用位数有限的浮点数比可能完全表示,必须从某一位舍去.

**最大值溢出与最小值溢出**

当运算结果超出了浮点数所能表示的数的范围时,就会发生:

* 最大值溢出(超出最大值)
* 最小值溢出(超出最小值)

**信息丢失**

双精度 数与数之间存在不能表示的数.特别是对于浮点数,数值越大,能够表示的"分解能"越低.

在 0 附近,数值可以表示的很细致,离 0 越远,所能表示的数的间隔越大.

```php
我自己写的 php 列子
<?php
$a = 10000001.0;
$b = 0.12345678;
$c = 0.11111111;
$d = -10000000.0;

$s = 0.0;
$s += $a;
$s += $b;
$s += $c;
$s += $d;

var_dump($s);

$s2 = 0.0;
$s2 += $a;
$s2 += $d;
$s2 += $b;
$s2 += $c;
var_dump($s2);
```

输出:
```php
float(1.2345678899437)
float(1.23456789)
```

因为第一次运算在计算时发生了信息丢失.

**位数脱落**

数值==差别极大==的两个数进项==加法==运算时,会发生==信息丢失==.

数值==几乎相同==的两个数进行==减法==运算时,会发生==位数脱落==.

```ruby
1.23456*10^-2 - 1.23444*1-^-2 = 1.2*10^-6
```

**截止误差**

浮点数的大小和精度都有限度,绝对无法表示除不尽的无理数.到某一位截止,总是有近似这就产生了误差.

#### 误差导致的严重问题

#### BigDecimal是什么

浮点数运算的陷阱:

1. 能够表示的精度有限
2. 以二进制表示

这些代价换来的是速度上的优势.

`BigDecimal`:

* 与 `Bignum`一样,有效数字自动扩展.
* 以十进制计算
* 以 C 语言技术,比内嵌的浮点数类`Float`要慢.

#### 分数,有理数

有理数(rational number); 能精确地表示为两个整数之比的数.

整数和通常所说的分数都是有理数.

无理数是指==无限不循环==小数.

**无理数和有理数的区别**

1. 有理数是有限小数和无限循环小数. 无理数是无限不循环小数.
2. 所有的有理数都可以写成两个整数之比;无理数不能.



