# 第四章 设计模式

### 设计模式(1)

#### 设计模式是程序抽象化的延伸

#### Singleton 模式

Singleton 模式用来保证某个类的实例只有一个.

#### Proxy 模式

Proxy(代理) 模式是为某个对象提供代理对象的模式. 假设有个生成代价非常大的对象.如果在还并不知道是否真正需要该对象的时候就事先生成它的话,可能会带来很大的浪费.在需要的时候生成它.

**我自己在php的理解**

在客户端与实体之间建立一个代理对象(proxy),客户端对实体进行的操作全部委派给代理对象,隐藏实体的具体实现细节.

其实`php`的魔术方法`__call`和`ruby`的`method_mission`类似.

**我自己整理`Proxy`模式的适用场景**

* 远程代理(Remote Proxy) 为一个位于不同的地址空间的对象提供一个本地的代理对象.这个不同的地址空间可以是在同一台主机中,也可是在另一台主机中,远程代理又叫做大使(Ambassador).
* 虚拟代理(Virtual Proxy) 根据需要创建开销很大的对象(作者就是举的该例子)
* 保护代理(Protection Proxy) 控制对原始对象的访问.保护代理用于对象应该有不同的访问权限的时候.
* 智能指引(Smart Reference) 取代了简单的指针,它在访问对象时执行了一些附加操作.
* Copy-on-Write代理: 他是虚拟代理的一种,把==复制(克隆)==操作延迟到只有在客户端真正需要时才执行.一般来说,对象的深克隆是一个开销较大的操作,Copy-on-Write代理可以让这个操作延迟,只有对象被用到的时候才被克隆.

#### Iterator 模式

Iterator(迭代器) 模式提供按顺序访问集合对象中个元素的方法.即使不知道对象的内部构造,也可以按顺序访问其中的某个元素.

称这个循环控制对象为 `Iterator`,也称为==游标==.

#### 外部迭代器的缺陷

外部迭代器的缺陷在于迭代器(游标)对象需要引用集合对象的内部信息.为了按顺序访问集合对象的各个元素,迭代器对象==需要访问集合的内部构造==.

### 设计模式(2)

#### 模式与动态语言的关系

设计模式可以分为3大类:

* 有关生成的模式(5个),`Singleton`.
* 有关构造的模式(7个),`Proxy`.
* 有关行为的模式(11个),`Iterator`

#### 重复使用即存对象的 Prototype 模式

Prototype(原型)模式"明确一个实例作为要生成对象的种类原型,通过复制该实例来生成新的对象".

`Self`语言认为类并不是必需的.`Self`中不存在所谓的类,基本操作并不是从类来生成对象,而是复制对象.

在需要新种类对象的时候,首先复制一个即存的对象,给复制的对象直接增加方法或实例变量等功能,生成最初的第一个新种类对象.如果该对象需要不止一个的话,那就从第一个雏形来复制,需要几个就复制几个.

雏形对应的英文是`Prototype`.像这样的不用类,而是用原型模式和复制方法的编程语言称为原型模式的编程语言.

#### 亲身体验Io语言

```Io
// 复制Object 
Dog := Object clone

// 把sit 方法教给雏形Dog 
Dog sit := method("I'm sitting.\n" print)

// Dog 是狗, 所以会坐
Dog sit

// 从雏形DOg 生成新的myDog
myDog := Dog clone
```

上文的 Object 只是具有代表性的对象,除最基本的以外其他什么都不知道.

#### 编写抽象算法的Template Method模式


