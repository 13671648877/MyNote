# 第四章 设计模式

设计模式就是给做得好的设计起个名字,并将它们进行分类.分类中的很多设计模式之所以优秀,是因为能够经得起`OCP`所要求的变化.

### 设计模式(1)

#### 设计模式是程序抽象化的延伸

#### Singleton 模式

Singleton 模式用来保证某个类的实例只有一个.

#### Proxy 模式

Proxy(代理) 模式是为某个对象提供代理对象的模式. 假设有个生成代价非常大的对象.如果在还并不知道是否真正需要该对象的时候就事先生成它的话,可能会带来很大的浪费.在需要的时候生成它.

**我自己在php的理解**

在客户端与实体之间建立一个代理对象(proxy),客户端对实体进行的操作全部委派给代理对象,隐藏实体的具体实现细节.

其实`php`的魔术方法`__call`和`ruby`的`method_mission`类似.

**我自己整理`Proxy`模式的适用场景**

* 远程代理(Remote Proxy) 为一个位于不同的地址空间的对象提供一个本地的代理对象.这个不同的地址空间可以是在同一台主机中,也可是在另一台主机中,远程代理又叫做大使(Ambassador).
* 虚拟代理(Virtual Proxy) 根据需要创建开销很大的对象(作者就是举的该例子)
* 保护代理(Protection Proxy) 控制对原始对象的访问.保护代理用于对象应该有不同的访问权限的时候.
* 智能指引(Smart Reference) 取代了简单的指针,它在访问对象时执行了一些附加操作.
* Copy-on-Write代理: 他是虚拟代理的一种,把==复制(克隆)==操作延迟到只有在客户端真正需要时才执行.一般来说,对象的深克隆是一个开销较大的操作,Copy-on-Write代理可以让这个操作延迟,只有对象被用到的时候才被克隆.

#### Iterator 模式

Iterator(迭代器) 模式提供按顺序访问集合对象中个元素的方法.即使不知道对象的内部构造,也可以按顺序访问其中的某个元素.

称这个循环控制对象为 `Iterator`,也称为==游标==.

#### 外部迭代器的缺陷

外部迭代器的缺陷在于迭代器(游标)对象需要引用集合对象的内部信息.为了按顺序访问集合对象的各个元素,迭代器对象==需要访问集合的内部构造==.

### 设计模式(2)

#### 模式与动态语言的关系

设计模式可以分为3大类:

* 有关生成的模式(5个),`Singleton`.
* 有关构造的模式(7个),`Proxy`.
* 有关行为的模式(11个),`Iterator`

#### 重复使用即存对象的 Prototype 模式

Prototype(原型)模式"明确一个实例作为要生成对象的种类原型,通过复制该实例来生成新的对象".

`Self`语言认为类并不是必需的.`Self`中不存在所谓的类,基本操作并不是从类来生成对象,而是复制对象.

在需要新种类对象的时候,首先复制一个即存的对象,给复制的对象直接增加方法或实例变量等功能,生成最初的第一个新种类对象.如果该对象需要不止一个的话,那就从第一个雏形来复制,需要几个就复制几个.

雏形对应的英文是`Prototype`.像这样的不用类,而是用原型模式和复制方法的编程语言称为原型模式的编程语言.

#### 亲身体验Io语言

```Io
// 复制Object 
Dog := Object clone

// 把sit 方法教给雏形Dog 
Dog sit := method("I'm sitting.\n" print)

// Dog 是狗, 所以会坐
Dog sit

// 从雏形DOg 生成新的myDog
myDog := Dog clone
```

上文的 Object 只是具有代表性的对象,除最基本的以外其他什么都不知道.

#### 编写抽象算法的 Template Method 模式

Template Method 模式是:"在父类的一个方法中定义算法的框架,其中几个步骤的具体内容则留给子类来实现.使用 `Template Method` 模式,可以在不改变算法接口的前提下,在子类中定义算法的一些步骤."


在父类中定义抽象化的算法,调用隐藏了实现细节的方法,然后在子类中实现具体的细节,这就是`Template Method`模式.

也就是说,算法是在抽象水平很高的状态下表述的,同样的代码能够适用于各种各样的情况.

#### 避免高度依赖性的 Observer 模式

Observer(观察者) 模式是当某个对象的朱葬台发生变化时,依存于该状态的全部对象都自动得到通知,而且为了让它们都得到更新,定义了对象间一对多的依存关系.

这是控制类于类之间依存关系的一种模式.

* Observer(观察者), 接受变更通知.
* Subject(对象) 或 Observable(被观察者), 发出变更通知.

### 设计模式(3)

#### 软件开发的悲剧

软件开发过程中遇到的各种问题归结起来主要有两个方面:

* 复杂性
* 变化性

#### 开放 - 封闭原则

开发 - 封闭原则 (open-closed principle).

对模块扩展必须开放 (Open), 对修改必须封闭 (Closed).

**对模块扩展必须开放**

模块可以扩展.比如,对数据结构能够追加新的字段,或是追加新的功能.

某一模块会被用到什么地方,不可能完全预测.为了应对将来的需要,对于扩展必须是开放的.

**对修改必须封闭**

指某一模块被别的模块引用时的要求.必须做成这个样子: 即使被引用一方的实现细节发生变化,也不会带来问题.

即使某一模块的内部结构变了,对外接口也应当是不变的.如果对外接口不能保持不变,模块就不能稳定使用.

#### 面向对象的情况

使用面向对象语言,==功能使用方可以不必知道功能提供方各种类的详细内容==,而只需啊哟着眼于它们具有什么样的==接口==就可以

功能提供方提供了新功能,或是内部有了更改,功能使用方都不用做任何更改.也就是说,从功能的使用方来看,模块对于修改是封闭的.(==因为使用了接口定义了双方的契约==)

功能的提供方还要生成与即存对象具有相同接口的对象,任何时候都能追加新的功能.也就是说对于功能扩展而言是开放的.

**开放封闭在面向对象的体现**

==因为有继承而允许功能的追加(对功能扩展而言是开放的),因为有多态而维持模块接口的稳定性(对修改而言是封闭的),开放封闭能同时实现.==

**对面向对象的总结**

面向对象无非是编程的一种工具,是不是理论上上正确的面向对象不重要,是否符合OCP,生产性高不高,维护性好不好,能否适应将来的更改,等等,这些才是重点.

#### OCP 与 Template Method 模式

Template Method 模式多到底无非就是继承.

#### 使用 Strategy 模式

Strategy (策略) 模式:"定义算法的集合,将各算法封装,使它们能够交换.利用`Stragegy`模式,算法和利用这些算法的客户程序可以分别独立进行修改而不互相影响."

`Strategy` 模式,就是将容易变化的处理归纳为独立的对象,然后使它们能够互相交换.

==使用方法与将容易变化的处理教给子类的`Template Method`模式相类似.==两个模式最大的区别在于,==`Strategy` 模式是独立的对象,能够动态交换处理逻辑==.


