#第一章 UNIX基础知识

###1.2 UNIX体系结构

**内核(kernel)**

较小,位于环境的`核心`.`控制`计算机硬件资源,提供程序运行环境.

**shell**

一个特殊的应用程序,为运行其他应用程序提供了一个接口.

###1.3登录

####/etc/passwd

用户登录时,系统在`/etc/passwd`中查看登录名.等录项由"冒号`:`"分隔,依次是:

* 登录名
* 加密口令
* 数字用户id(如:205)
* 数字组id(如:105)
* 注释字段
* 起始目录(如:家目录 /home/xxx)
* shell程序(如:/bin/ksh).系统了解应该为登录用户执行哪一个shell

####shell

shell是一个`命令行解释器`,`读取`用户`输入`,然后`执行`命令.

shell的用户输入来自

* 用户输入(`交互式shell`)
* 文件(`shell脚本`)

系统从口令文件中(/etc/passwd)相应用户登录项的最后一个字段中了解到应该为登录用户执行哪一个shell.

###1.4文件和目录

####文件系统

UNIX文件系统是`目录`和`文件`的一种层次结构. 所有东西的`起点`是成为`根(root)`的目录,这个目录的名称是一个字符`\`.

**目录和目录项**

`目录(directory)`是一个包含`目录项`的`文件`(目录即是文件).`逻辑`上,每个目录项都包含:

* 文件名
* 包含说明该`文件属性`的信息

`文件属性`

* 文件类型(普通文件还是目录)
* 文件大小
* 文件所有者
* 文件权限(其他用户能否访问该文件)
* 文件最后的修改时间等

**目录项的逻辑是师徒与实际存放在磁盘上的方式是`不同的`.UNIX文件系统的大多数实现并`不在目录项中存放属性`**

因为当一个文件有多个`硬链接`时,很难保持多个属性副本之间的同步.

**目录,目录项,索引节点的关系(知识点整理)**

一个目录文件包含了`一组`目录项,目录项是放在data block中的.

一个目录项主要包括了`文件名`和`索引节点号`.索引节点号是指向索引节点表(system inode table)中对应的索引节点的.

内核的后来版本采用`ext`文件系统,`目录项中就不是存放索引节点号,然后找到索引节点表,再找到索引节点了.而是目录项中存放文件名和一个指向索引节点的指针.`

`索引节点`就是文件系统处理文件所需要的所有信息都存放在称为索引节点的数据结构中.主要就是文件的属性,包括链接数,文件所有者,文件建立和修改的时间,文件在磁盘的位置,文件大小,使用权限等等.

####文件名

目录中的各个名字称为`文件名`(filename). 不能出现在文件名的字符:

* 斜线(`/`): 用来分隔成路径名的各文件名.
* 空字符: 用来终止一个路径名.

`POSIX.1`推荐文件名限制在以下字符集:

* 字母(a~z,A~Z)
* 数字(0~9)
* 句点(.)
* 短横线(-)
* 下划线(_)

创建新目录时会自动创建了两个文件名: `.`(点)和`..`(点点).

* `.`: 指向当前目录.
* `..`:指向父目录

在`最高层`的根本目录中,点点(`..`)与点(`.`)相同.

####路径名

**路径名**

由斜线分隔的一个或多个文件名组成的序列(也可以斜线开头)构成路径名(pathname).

* 以斜线开头的路径名称为`绝对路径名(absolute pathname)`
* `相对路径名(relative pathname)`指向相对于当前目录的文件

文件系统根的名字(`/`)是一个特殊的绝对路径名,不包含文件名.

**exit的参数**

程序结束时,用`参数`调用`exit`程序,参数分为:

* `0`: 正常结束
* `1~255`: 表述出错

####工作目录

每个进程都有一个**工作目录(working directory)**,或称为**当前工作目录(current working directory)**.所有`相对路径名都从工作目录开始解释`.

`chdir()`函数可以更改其工作目录.

####起始目录

`登录时`,工作目录设置为`起始目录(home directory)`,该其实目录从口令文件中相应用户的登录项中取得.

###1.5 输入和输出

####文件描述符

**文件描述符(file descriptor)**

通常是一个小的`非负`整数,内核用以表示`一个特定进程正在访问的文件`. 当内核`打开`一个现有文件或`创建`一个新文件时, 它都`返回`一个`文件描述符`.在`读`,`写`文件时,可以使用这个文件描述符.

变化范围是`0~OPEN_MAX-1`(允许每个进程最多打开的文件数).

当打开一个现有文件或创建一个新文件时,内核向进程返回一个文件描述符.当读或写一个文件时,使用`open`或`create`返回的文件描述符标识该文件,将其作为参数传送给`read`或`write`.

####标准输入,标准输出和标准错误

每当运行一个新程序时,shell都为其打开3个文件描述符:

* 标准输入(standard input),`0`.
* 标准输出(standard output),`1`.
* 标准错误(standard error) ,`2`.

这3个描述符都链接向终端.

**STDIN_FILENO**

标准输入,定义在`<unistd.h>`头文件中.在`POSIX`标准中,值是`0`.

**STDOUT_FILENO**

标准输出,定义在`<unistd.h>`头文件中.在`POSIX`标准中,值是`1`.

**stdin**

`标准IO常量`,义在`<stdio.h>`头文件中,标准输入.

**stdout**

`标准IO常量`,义在`<stdio.h>`头文件中,标准输出.

####不带缓冲的I/O

**read()**

`ssize_t read(int fd,void *buf,size_t nbyte)`

read函数是负责从fd中读取内容.成功时,read返回实际所读的字节数,如果返回的值是0,表示已经读到文件的结束了.小于0表示出现了错误.如果错误为EINTR说明读是由中断引起的, 如果是ECONNREST表示网络连接出了问题.

**write()**

`ssize_t write(int fd,const void *buf,size_t nbytes)`

write函数将buf中的nbytes字节内容写入文件描述符fd.成功时返回写的字节数.失败时返回-1. 并设置errno变量. 在网络程序中,当我们向套接字文件描述符写时有俩种可能. 

1. write的返回值大于0,表示写了部分或者是全部的数据. 
2. 返回的值小于0,此时出现了错误.我们要根据错误类型来处理.  如果错误为EINTR表示在写的时候出现了中断错误. 
如果为EPIPE表示网络连接出现了问题(对方已经关闭了连接).

**open()**

打开或创建一个文件.若成功则返回文件描述符,若出错则返回-1.

		#include<fcntl.h>
    	int open(const char *pathname, int oflag, ... /* mode_t mode */);
    	创建文件时,使用第三个参数

**lseek()**

显示地为一个打开的文件设置其偏移量.若成功则返回新的文件偏移量,若出错则返回-1.

		 #include<unistd.h>
    	 off_t lseek(int filedes, off_t offset, int whence);

**close()**

关闭一个打开的文件。若成功则返回0，若出错则返回-1。

    #include<unistd.h>
    int close(int filedes);

关闭一个文件时还会释放该进程加在该文件上的所有记录锁。

当一个进程终止时,内核自动关闭它所有打开的文件.很多程序都利用这一功能而不显示地用close关闭打开的文件.

####标准IO

标准IO函数为那些不带缓冲的`I/O`函数提供了一个`带缓冲的接口`.

###1.6程序和进程

####程序

`程序(program)`是一个存储在磁盘上某个目录中的可执行文件.

**exec**

内核使用`exec`函数,将程序读入内存,并执行程序.

####进程和进程ID

**进程(process)**

`程序`的执行`实例`被称为进程(`process`).在一些操作系统称为`任务(task)`.

**进程ID(processID)**

UNIX系统确保每个进程都有一个`唯一`的数字标识符,称为`进程ID(processID)`.进程ID总是一个`非负整数`.

用`getpid()`得到进程ID,返回一个`pid_t`数据类型.标准保证能保存在一个`长整型`中.

####进程控制

**fork()**

通过复制调用fork的进程创建一个新进程.

调用`fork()`创建一个新进程,新进程是`调用进程的一个副本`.

* 调用进程为`父进程`.
* 新创建的进程为`子进程`.

fork()对父进程返回新的子进程的进程ID(一个非负整数),对子进程则返回0.

fork()创建一个新进程,被`调用一次`(由父进程),`返回两次`(分别在父进程和子进程).

**exec()**

有7种变体.当进程调用一种exec函数时,该进程的用户空间代码和数据完全被新程序替换,从新程序的启动例程开始执行.

用新的程序文件替换了子进程原先执行的程序文件.

`fork`和`exec`两者的组合就是某些操作系统所称的产生`spawn`一个新进程.

**waitpid()**

进程用这个函数来`等待`其子进程`状态的改变`,并获取子进程所改变的信息.对于一个已经终止的子进程,用wait能够让系统释放与子进程相关的资源;如果不用wait则终止的进程会变为僵尸进程(`z`).

子进程调用`exec`执行新程序文件,父进程通过调用`wait(waitpid)`等待子进程终止.

**子进程的状态改变**

* 子进程终止
* 子进程被一个信号终止来
* 子进程被一个信号恢复

####线程和线程ID

一个进程至少有一个`控制线程(thread)`.

一个进程内的所有线程`共享`同一个地址空间,文件描述符,栈以及与进程相关的属性.

**线程ID**

线程ID值在它所属的进程内起作用.一个进程中的线程ID在另一个进程中没有意义.

###1.7出错处理

**errno**

当UNIX系统函数出错时,`errno`通常被设置为具有特定信息的值.

文件`<errno.h>`中定义了`errno`以及可以赋予它的各种常量.

errno的两条规则:

* 如果没有出错，其值不会被例程(函数)清楚.因此仅当函数的返回值指明出错时,才检验其值.
* 任何函数都不会将`errno值`设置为`0`.

**strerror()**

将`errnum`(errno的值)映射为一个出错消息字符串,并且返回字符串的指针.

**perror()**

基于errno的当前值, 在标准错误上产生一条出错信息,然后返回.

###1.8用户标识

####用户ID

用户ID(user ID)是一个数值,每个用户有一个唯一的用户ID.

**root**

用户ID为`0`的用户为`根用户(root)`或`超级用户(superuser)`.

**getuid()**

返回用户ID.

####组ID

组被用于将若干用户集合到项目或部门中去. 这种机制允许同组的各个成员之间共享资源.

* 口令文件包含了登录名和用户ID的映射关系
* 组文件(/etc/group)包含了组名和组ID之间的之间的映射关系.

整数数比较更节省时间,占空间更少.

**getgid()**

返回组ID.

####附属组ID

允许一个用户属于多至16个其他的组.登录时,读文件`/etc/group`,寻找列有该用户作为其成员的前16个记录项就可以得到该用户的`附属组ID(supplementary group ID)`.

###1.9信号

**信号(signal)**

用于通知进程发生了某种情况.

**处理信号的方式**

* 忽略信号
* 按系统默认方式处理
* 提供一个函数,信号发生时调用该函数,被称为捕捉该信号.

**中断当前运行的进程**

* 中断键 `interrupt key`: `Ctrl + C`
* 退出键 `quit key`: `Ctrl + \`

**kill函数**

调用`kill`函数.在一个进程中调用此函数就可向另一个进程发送一个信号.

**发送信号的限制**

当想一个进程发送信号时, 我们必须是那个进程的`所有者`或者是`超级用户`.

###1.10时间值

**日历时间**

1970年1月1日00:00:00 经过的秒数累计值.

使用`time_t`类型保存这种时间值.

**进程时间**

用于度量进程使用的中央处理器资源.进程时间以时钟滴答计算.

使用`clock_t`类型保存这种时间值.

UNIX系统为一个进程维护了3个进程时间值:

* 时钟时间: 进程运行的时间总量.
* 用户CPU时间: 执行用户指令所用的时间量.
* 系统CPU时间: 该进程执行内核程序所经历的时间.

用户CPU时间和系统CPU时间之和常被称为CPU时间.

**时钟时间**

从进程从开始运行到结束,时钟走过的时间,这其中包含了进程在阻塞和等待状态的时间.

时钟时间 ＝ 阻塞时间 ＋ 就绪时间 ＋运行时间

**用户CPU时间**

就是用户的进程获得了CPU资源以后,在用户态执行的时间.

用户CPU时间 ＝ 运行状态下用户空间的时间

**系统CPU时间**

用户进程获得了CPU资源以后,在内核态的执行时间.

系统CPU时间 =  运行状态下系统空间的时间

`用户CPU时间+系统CPU时间=运行时间`

**time()**

获取上述3种进程时间.


###1.11系统调用和库函数

**系统调用(system call)**

直接进入内核的入口点(由此程序向内核请求服务),这些入口点被称为`系统调用`.

**UNIX实现系统调用**

为每个系统调用在标准C库中设置一个具有同样名字的函数.用户进程用标准C调用序列来调用这些函数,然后,函数又用系统所要求的技术调用相应的内核服务.

**系统调用和库函数**

* 系统调用通常提供一种最小接口
* 库函数通常提供比较复杂的功能

##知识点整理





不管是内核空间还是用户空间,它们都处于虚拟空间中.


