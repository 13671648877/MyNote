###带缓冲I/O和不带缓冲I/O详解 

---

**不带缓冲意味着系统调用**

`不带缓冲`,`不是`指内核不提供缓冲,是值**`单纯的系统调用户,不是函数库的调用`**.

**不带缓冲的I/O是指进程不提供缓冲功能**

系统内核对磁盘的读写都会提供一个块缓冲,当用`write`函数对其写数据时,直接调用系统调用,将数据写入到块缓冲进行排队,当缓冲达到一定的量时,才会把数据写入磁盘.因此所谓的不带缓冲的I/O是指`进程不提供缓冲功能`.每调用一次`write`或`read`函数,`直接`系统调用.

**带缓冲的I/O:流缓冲区(进程)->块缓冲区(内核)->磁盘**

带缓冲的I/O是指进程对输入输出流进行了改进,提供了一个`流缓冲`,当用`fwrite`函数往磁盘写数据时,先把数据写入`流缓冲区`中.当达到一定条件,比如流缓冲区满了,或刷新流缓冲,这时候才会把数据一次送往内核提供的`块缓冲`,再经`块缓冲`写入磁盘.

`流缓冲区(进程)->块缓冲区(内核)->磁盘`

**带缓冲与不带缓冲的差别**

`带缓存的文件操作`:

`带缓存`的文件操作是`标准C库`的实现,第一次调用带缓存的文件操作函数时标准库会`自动分配内存并且读出一段固定大小的内容存储在缓存中`.所以以后每次的读写操作并不是针对硬盘上的文件直接进行的,而是针对内存中的缓存的.何时从硬盘中读取文件或者向硬盘中写入文件有标准库的机制控制.

`不带缓存的文件操作`:

`不带缓存`的文件操作通常都是系统提供的系统调用,更加`低级`,直接从硬盘中读取和写入文件,由于IO瓶颈的原因,速度并不如意,而且原子操作需要程序员自己保证,但使用得当的话效率并不差.

`带缓存文件IO 是调用系统提供的不带缓存IO实现的`.

*术语不带缓冲指的是每个read和write都调用嗯内核中的一个系统调用.所有的磁盘I/O都要经过内核的块缓冲(也称内核的缓冲区高速缓存,唯一例外的是对原始磁盘设备的I/O.既然read或write的数据都要被内核缓冲,那么术语"不带缓冲的I/O"指的是在用户的进程中对这两个函数不会自动缓冲,每次read或write就要进行一次系统调用.*

**read/write 和 fread/fwrite**

`fread`和`fwrite`在`用户层`进行一次数据的缓存.`read`和`write`是系统调用,他们在用户层是没有缓存的,所以称它们是无缓存的I/O,`但是对于内核来说还是进行了缓存,不过用户层看不到罢了`.

**延迟写**

当将数据写到文件上时,内核先将该数据写到缓存,如果该缓存未满,则并不将其排入输出队列，直到缓存写满或者内核再次需要重新使用此缓存时才将其排入输入队列,待其到达队首,在进行实际的I/O操作,也就是此时才把数据真正写到磁盘,这种技术叫`延迟写`.

现在假设内核所设的缓存是100个字节,如果你使用write,且buff的size为10,当你要把9个同样的buff写到文件时,你需要调用9次`write`,也就是9次`系统调用`,此时也并没有写到硬盘,如果想立即写到硬盘,调用`fsync`,可以进行实际的I/O操作.

**标准IO操作流程:fwrite->write->fflush->fsync**

标准I/O, 带缓存的I/O采用FILE*, `FILE实际上包含了为管理流所需要的所有信息`:

* 实际I/O的文件描述符
* 指向流缓存的指针(标准I/o缓存,由malloc分配,又称为`用户态`进程空间的缓存,区别月内核所设的缓存)
* 缓存长度
* 当前在缓存中的字节数
* 出错标志

`frwite` 调用 `write`系统调用, 把数据写到流缓存

当满了以后调用`fflush`时才填入`内核缓存`

`fflush`将流所有未写的数据送入(刷新)到内核(内核缓冲区),`fsync`将所有内核缓冲区的数据写到文件(磁盘).
