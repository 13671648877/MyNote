# 第一章 分布式架构

---

## 分布式的特点

分布式系统是一个硬件或软件组件分布在不同的网络计算机上, 彼此之间仅仅通过消息传递进行通信和协调的系统.

### 分布式的特征

#### 分布性

分布式系统中的多台计算都会在空间上随意分布, 同时, 机器的分布情况也会随时变动.

#### 对等性

分布式系统中的计算机没有主/从之分, 既没有控制整个系统的主机, 也没有被控制的从机, 组成分布式系统的所有计算机节点都是**对等的**. 副本(Replica)是分布式系统最常见的概念之一, 指的是分布式系统对数据和服务提供的一种**冗余**方式. 为了对外提供高可用的服务, 会对数据和服务进行副本处理.

**数据副本**是指在不同的节点上持久化同一份数据, 当某一个节点上存储的数据丢失时, 可以从副本上读取到该数据, 这是解决分布式系统数据丢失问题最为有效的手段. 

**服务副本**是指多个节点提供同样的服务, 每个节点都有能力接收来自外部的请求并进行相应的处理.

#### 并发性

同一个分布式系统中的多个节点, 可能会**并发地操作一些共享的资源**, 诸如数据库或分布式存储等, **如何准确并高效地协调分布式并发操作**也成为了分布式系统架构与设计中最大的挑战之一. 

#### 缺乏全局时钟

一个典型的分布式系统是由一系列在空间上随意分布的多个进程组成的, 具有明显的分布性, 这些进程之间通过交换消息来进行相互通信. **在分布式系统中, 很难定义两个事件究竟谁先谁后**, 原因就是因为**分布式系统缺乏一个全局的时钟序列控制**.

#### 故障总是会发生

任何设计阶段考虑到的异常情况, 一定会在系统实际运行中发生, 并且, 在系统实际运行过程中还会遇到很多在设计时未能考虑到的异常故障.

### 分布式环境的各种问题

#### 通信异常

* 网络本身的不可靠性.
* 网络的延时性(远远大于单机的内存).

因此消息的丢失和消息延迟变得非常普遍.

#### 网络分区

当网络由于发生异常情况, 导致分布式系统中部分节点之间的网络延时不断增大, 最终导致组成分布式系统的所有节点中, 只有部分节点之间能够进行正常通信, 而另一些节点则不能. 称之为**网络分区(脑裂)**.

#### 三态

分布式系统的每一次请求与相应, 存在特有的**三态**概念.

* 成功
* 失败
* 超时

在传统的单机系统中, 应用程序在调用一个函数之后, 能够得到一个非常明确的响应:

* 成功
* 失败

而在分布式系统中, 由于网络是不可靠的, 虽然在绝大部分情况下, 网络通信也能够接收到成功或失败的影响, 但是当网络出现异常的情况下, 就可能会出现超时现象:

* 由于网络原因, 该请求(消息)并没有被成功地发送到接收方, **在发送过程就发生了消息丢失现象**.
* 该请求(消息)成功的被接收方接收后, 并进行了处理, 但是在**将响应反馈给发送方的过程中, 发生了消息丢失现象**.

#### 节点故障

组成分布式系统的服务器节点出现的宕机或僵死现象.

## 从 ACID 到 CAP/BASE

### ACID

事务(Transaction)是由一系列对系统中数据进行访问与更新的操作所组成的**一个程序执行逻辑单元(Unit)**.

狭义上的事务特指数据库事务.

* 当多个应用程序并发访问数据库时, 事务可以在这些应用程序之间提供一个隔离方法(隔离性), 以防止彼此的操作互相干扰.
* 事务为数据库操作序列提供一个从失败中恢复到正常状态的方法, 同时提供了数据库即使在异常状态下仍能保持数据一致性的方法.

#### 事务特征

* 原子性(`A`tomicity)
* 一致性(`C`onsistency)
* 隔离性(`I`solation)
* 持久性(`D`urability)

#### 原子性

事务的原子性是指事务必须是一个原子的操作序列单元. 事务中包含的各项操作在一次执行过程中, 值允许出现以下两种状态之一:

* 全部成功执行.
* 全部不执行.

任何一项操作失败豆浆导致整个事务失败, 同时其他已经被执行的操作都将被撤销并回滚, 只有所有的操作全部成功, 整个事务才算是成功完成.

#### 一致性

事务的一致性是指事务的执行不能破坏数据库的完整性和一致性, 一个事务在执行之前和执行之后, 数据库都必须处于一致性状态.

**什么是一致**事务执行结果必须是使数据库从一个一致性转变到另一个一致性状态, 因此当数据库只包含成功事务提交的结果时, 就能说数据库处于一致性状态.

**什么是不一致**数据库系统在运行过程中发生故障, 有些事务尚未完成就被迫中断, 这些未完成的事务对数据库所做的修改有一部分已经写入物理数据库, 这时数据处于一种不正确的状态, 或者说是不一致状态.

#### 隔离性

事务的隔离性是指在并发环境中, 并发的事务是相互隔离的, 一个事务的执行不能被其他事务干扰.

不同的事务并发操作相同的数据时, 每个事务都有各自完整的数据空间, 即一个事务内部的操作及使用的数据对其他并发事务是隔离的, 并发执行的各个事务之间不能互相干扰.

##### 隔离级别

**未授权读取**也称读未提交(Read Uncommitted), 该隔离级别允许脏读取, 其隔离级别最低.

**授权读取**也称读已提交(Read Committed), 它和未授权读取非常相近, 唯一的区别就是授权读取只允许获取已经被

**可重复读取**保证在事务处理过程中, 多次读取一个数据时, 其值都和事务开始时刻是一致的.(如果是`RC`,则多次多去可能会取得其他事务执行完成的值). 可能会出现**幻影数据**, 就是指同样的事务操作, 在前后两个时间段内执行对同一个数据项的读取, 可能出现不一致的结果.

可重复读取隔离级别能够保证事务在第一次事务操作过程中, 始终对数据项读取到1, 但是在下一次事务操作中, 采用同样的查询方式, 就可能会读取到10或20. 

mysql采用`next key-lock`解决幻读.

**串行化**(Serializable)是最严格的事务隔离级别. 它要求所有事务都被串行执行, 即事务只能一个接一个地执行处理, 不能并发执行.

#### 持久性

一个事务一旦提交成功, 它对数据控中对应数据的状态变更就应该是永久性的. 一旦某个事务成功结束, 它对数据库所做的更新就必须被永久保存下来, 即使发生系统崩溃或机器宕机等故障, 只要数据库能够重新启动, 那么一定能够将其恢复到事务成功结束时的状态.

### 分布式事务

一个分布式事务可以看做是由多个分布式的操作序列组成的, 通常可以把这一系列分布式的操作序列称为**子事务**. 分布式事务也可以被定义为一种嵌套型的事务, 同时也就具有了`ACID`事务特性.

### CAP 和 BASE 理论

#### CAP 定理

一个分布式系统不可能同时满足:

* 一致性(`C`onsistency)
* 可用性(`A`vailability)
* 分区容错性(`P`artition tolerance)

这三个需求, 最多只能同时满足2个.

#### 一致性

数据在多个副本之间是否能够保证一致的特性.

在分布式系统中, 如果能够做到针对一个数据项的更新操作执行成功后, 所有的用户都可以读取到最新的值, 那么这样的系统就被认为具有强一致性(或严格的一致性).

#### 可用性

系统提供的服务必须一直处于可用的状态, 对于用户的每一个操作请求总是能够在有限的时间内返回结果.

**有限的时间**对于用户的一个操作请求, 系统必须能够在指定的时间(即响应时间)内返回对应的处理结果.

**返回结果**要求系统在完成对用户请求的处理后, 返回一个正常的响应结果.

#### 分区容错性

分区容错性约束了一个分布式系统需要具有如下特征: 分布式系统在遇到任何网络分区故障的时候, 仍然需要能够保证对外提供满足一致性和可用性的服务, 除非是整个网路环境都发生了故障.

#### BASE 理论

* `B`asically Available: 基本可用
* `S`oft state: 软状态
* `E`ventuall consistent: 最终一致性

其核心思想史即使无法做到强一致性(Strong consistency), 但每个应用都可以根据自身的业务特点, 采用适当的方式来使系统达到最终一致性(Eventual consistency).

#### 基本可用

分布式系统在出现不可预知故障的时候, 允许损失部分可用性.

* 响应时间上的损失.
* 功能上的损失.

#### 弱状态

也成为软状态, 和硬状态相对, 是指允许系统中的数据存在中间状态. 即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时.

#### 最终一致性

系统中所有的数据副本, 在经过一段时间的同步后, 最终能够达到一个一致的状态. 最终一致性的本质是需要系统保证最终数据能够达到一致, 而不需要实时保证系统数据的强一致性.

最终一致性的五类变种:

**因果一致性(Causual consistency)**

如果进程 A 在更新完某个数据项后通知了进程 B, 那么进程 B 之后对该数据项的访问都应该能够获取到进程 A 更新后的最新值, 并且如果进程 B 要对该数据项进行更新操作的话, 务必基于进程 A 更新后的新值, 即不能发生丢失更新的情况. 于此同时, 与进程 A 无因果关系的进程V的数据访问则没有这样的限制.

**读己之所写(Read your writes)**

进程 A 更新一个数据项之后, 它自己总是能够访问到更新过的最新值, 而不会看到旧值.

对于单个数据获取者来说, 其读取到的数据, 一定不会比自己上次写入的值旧.

**会话一致性(Session consistency)**

系统能够保证在同一个有效会话中实现"读己之所写"的一致性.

**单调读一致性(Monotonic read consistency)**

如果一个进程从系统中读取出一个数据项的某个值后, 那么系统对于该进程后续的任何数据访问都不应该返回更旧的值.

**单调写一致性(Monotonic write consistency)**

一个系统需要能够保证来自同一个进程的写操作被**顺序执行**.

#### BASE 和 ACID 的区别

通过牺牲强一致性来获得可用性, 并允许数据在一段时间内是不一致的, 但最终达到一致状态.

# 知识点

## 不可重复读和幻读的区别

不可重复读的重点是**修改**.同样的条件,你读取过的数据,再次读取出来发现值不一样了.

幻读的重点在于新增或者删除同样的条件, 第1次和第2次读出来的记录数不一样.

## Innodb Next-Key Lock

InnoDB有三种行锁的算法：

1. Record Lock: 单个行记录上的锁.
2. Gap Lock: 间隙锁, 锁定一个范围, 但不包括记录本身. GAP锁的目的, 是为了防止同一事务的两次当前读, 出现幻读的情况.
3. Next-Key Lock: 1+2, 锁定一个范围, 并且锁定记录本身. 对于行的查询, 都是采用该方法, 主要目的是解决幻读的问题.

## 悲观锁和乐观锁

* 悲观锁: mysql, `for update`.
* 乐观锁: 增加一个`version`.



