#第2章 基本规则

[地址](http://www.imooc.com/learn/345 "地址")

###笔记

---

**工作区和GOPATH**

`工作区`: 是防止Go源码文件的目录.

一般情况下, Go源码文件都需要存放到工作区中, 但是对于`命令源码文件`来说,`不是必须`的

`工作区结构`:

* `src 目录`: 放源码的, 以`代码包`为组织形式
* `pkg(package 目录)`: 存放归档文件(`.a`为后缀的文件)
* `bin 目录`: 用于存放当前工作区中的Go程序的可执行文件
	* 当环境变量`GOBIN`已`有效设置`时, 该目录会变的`无意义`
	* 当GOPATH的值中包含多个工作区的路径时, 必须设置GOBIN, 否则无法成功安装Go程序的可执行文件 

`平台相关目录`: 两个隐含Go语言环境变量: GOOS(Go源安装目标的操作系统) 和 GOARCH (Go源安装目标的计算架构)
		
		以 $GOOS_$GOARCH 为命名方式, 如: linux_amd64
		
**源码文件的分类和含义**

`Go源码文件`: 名称以`.go`为后缀, 内容以Go语言代码组织的文件,多个Go源码文件是需要用`代码包`组织起来的		
	
* 命令源码文件
* 库源码文件
* 测试源码文件
		
`命令源码文件`: 

* 声明自己属于`main`代码包, 包含无参数声明和结果声明的`main函数`.
* 被安装后, 响应的可执行文件会被存放到`GOBIN指向的目录`或`<当前工作区目录>/bin`下.
* `命令源码文件`是Go程序的`入口`.

`库源码文件`: 

* `不具备`命令源码文件按的那`两个特征`的源码文件.
*  被安装后, 相应的归档文件会被存放到`<当前工作区目录>/pkg/<平台相关目录>下`.

`测试源码文件`:

* `不具备`命令源码文件按的那`两个特征`的源码文件.		
* 名称以`_test.go`为后缀
* 测试函数:
	* `Test` 为前缀. 接受一个类型为 `*tesing.T` 的参数. 功能测试函数.
	
			func TestFind(t *testing.T){
				...
			}
			
	* `Benchmark` 为前缀. 接受一个类型为 `*testing.B` 的参数. 基准(性能)测试函数
	
			func BenchmarkFind(b *tesing.b){
				...
			}
			
	* 至少有以上的一个函数
		
**代码包的作用**

* 编译和归档Go程序的基本单位
* `代码划分`, `集结` 和 `依赖` 的有效组织形式, 也是`权限控制`的辅助手段.		
**代码包的规则**

* 一个由导入路径代表的目录
	* `导入路径` : `<工作区目录>/src` 或 `<工作区目录>/pkg/<平台相关目录>` 之下的某段`子路径` 
		
			代码包 hypermind.cn 可以对应于 
			/home/hypermind/golib/src/hypermind.cn 目录 (其中, /home/hypermind/go/lib 是一个工作区目录)
		
**代码包的声明**

* 每个源码文件`必须`声明其所属的代码包
* 同一个代码包中的所有源码文件声明的代码包应该是`相同的`	
	
**代码包声明与代码包导入路径的区别**

代码包声明语句中的包名称应该是该代码包的导入路径的`最右子路径`

		xxxx.com/pkgtool
		
		对应代码:
		
		package pkgtool
		
**代码包的导入**

代码包导入语句中使用的`包名称`应该与其`导入路径` `一致`

		flag
		fmt
		srings
		
		导入到当前源码中
		
		import(
			"flag"
			"fmt"
			"strings"
		)
		
带`别名`导入

	import str "strings"
	
	以后使用用 str 即可
	
	str.HasPerfix("abc","a")
	
`本地化`导入

	import . "strings" (注意前面有一个 点)
	
	使用
	
	HasPerfix("abc","a") (不用写前缀)
	
仅仅`初始化`

	impot_ "strings"
	
	仅执行代码包的初始化函数
	
**代码包初始化**

由`代码包初始化函数`提供功能. 

`代码包初始化函数`: 无参数声明和结果声明的 `init` 函数.

`init 函数` 可以被声明在`任何`文件中, 且可以有多个.

`init` 函数的执行时机 - 单一代码包内:

* 对所有全局变量进行求值, 执行`所有` init 函数. (同一个代码包的init函数`执行顺序` `不确定`)
		
`init` 函数的执行时机 - 不同代码包之间:

* 执行`被导入`的代码包中的`init函数`. (`先`执行)
* 执行`导入它`的那个代码包的`init函数`. (`后`执行)

		代码包 A B C
		
		A 导入 B
		B 导入 C
		
		这三个代码包的 init函数 执行顺序是:
		
		C B A (与导入顺序相反)

* 同一个代码包中被导入的多个代码包的init函数的执行顺序不确定

		代码包 A B C
		
		A 导入 B
		A 导入 C
		
		不能确定 B 和 C 的 init函数 谁先执行

`init` 函数 `先于` `main` 函数 执行

每一个`init`函数只会执行`一次`

###整理知识点

---