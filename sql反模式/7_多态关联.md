# 7 多态关联

## 笔记

---

### 目标引用多个父表

这里描述的场景是一个`comments`既可以用于`Bugs`也可以用于`Feature_Requests`中.

即一个给定的评论只能引用一个`Bug`或者一个特性.

### 反模式: 使用双用途外键

==多态关联==

#### 定义多态关联

用一个`Type`记录这条评论关联的表名. 但是不能使用外键了, 因为一个外键必须指定一个确切的表, 使用多态关联就意味着无法在元数据中定义这样的关系.

#### 使用多态关联进行查询

`SQL`的语法规定, 在联结查询时必须指明所有需要查询的表, 没办法根据`type`的值来切换不同的表.

#### 非面向对象的范例

`Order`和`User`都和`Address`相关.

`Address`就必须要记录

* `parent`: `User`or`Orders`
* `users_usage`
* `orders_usage`

### 如何识别反模式

* 这种标记架构可以让你将标记(或者其他属性)和数据库中的任何其他资源联系起来.(应该怀疑任何声称有无限扩展性的设计)
* 你不能再我们的数据库设计中声明外键.(一个没有适当的引用完整性的设计会有很多的问题).
* `entity_type`这列是干嘛的?哦,那个列是用来告诉你这条记录的其他列是和什么东西相关的.

### 合理使用反模式

应该尽可能地避免使用多态关联--应该使用外键约束等来确保引用完整性. 多态关联通常过度依赖上层程序代码而不是数据库的元数据.

### 解决方案: 让关系变得简单

#### 反向引用

多态关联是一个反向关联

#### 创建交叉表

上述列子中创建`BugsComments`和`FeaturesComments`关联表.移除对`Comments`的`type`列的依赖.

把关系记录在交叉表中.

*我比较常用的解决方案*

#### 设立交通灯

如果你希望在交叉表中实现一条评论都只涉及一个`Bug`或者一个`Features`. 可以在每张交叉表的`comment_id`列上声明一个`UNIQUE`的约束来支持.

#### 双向查找

交叉表可以获得试用多态关联所不能提供的引用完整性约束(外键).

#### 合并跑道

`COALESCE()`这个函数返回第一个非空的结果.

```sql
COALESCE(b.issue_id, f.issue_id) AS issue_id
...
```

联表查询出所需要的`Comments`记录和`Bug`或`Features`数据.

#### 创建公用的超级表

让`Bugs`和`FeatureRequests`都继承一个共同的`Issues`表. 让`Comments`表和`Issues`表使用外键来约束.

### 整理知识点

---