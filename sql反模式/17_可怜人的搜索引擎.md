# 17 可怜人的搜索引擎

### 笔记

---

#### 目标: 全文搜索

==SQL的一个基本原理就是一列中的单个数据是原子性的==. 你能对两个值进行比较, 但通常是把两个值当做两个整体来比较. 在`SQL`中比较字符串总是意味着低效和不精确.

#### 反模式: 模式匹配断言

使用`LIKE`和`REGEXP`, 但是性能和效率较低.

#### 如何识别反模式

* 我要怎么在`LIKE`表达式的两个通配符之间插入一个变量?
* 我要怎么写一个正则表达式来检查一个字符串是否包含多个单词, 不包含一个特定的单词, 或者包含给定单词的任意形式?
* 我们网站的搜索功能在加了很多文档进去之后慢的不可理喻了.

#### 合理使用反模式

为一个很少使用的查询维护一个索引, 可能就和用不高效的方法执行查询一样消耗资源.

使用模式匹配操作进行复杂查询是很困难的, 但是为了一些简单的需求设计这样的模式匹配, 能帮助你用最少的工作量获得正确的结果.

#### 解决方案: 使用正确的工具

最好的方案是使用特殊的搜索引擎技术, 而不是使用`SQL`.

##### 数据库扩展

**`MySQL`中的全文索引**

仅支持`MyISAM`存储引擎

这里我只是列了`MySQL`, 因为我平时使用`MySQL`居多.

##### 第三方搜索引擎

* Sphinx Search
* Apache Lucence

**反向索引**

反向索引就是一个所有可能被搜索的单词列表, 在多对对的关系中, 索引将这些单词和包含这些单词的文本关联起来.

* `keywords`表
	* `keyword` 关键词
	* `keyword_id` 关键词id

* `bugs`表
	* `bug_id` bug的id
	* `description` bug的描述
	* `summary` bug简介
	* ...

* `bugs_keywords`关联表 (多对多)
	* `keyword_id` 关键词id
	* `bug_id` bug的id

这样可以根据关系表查询出`keyword`对应的`bug`, 但是:

* `bugs_keywords`, 需要每次自己更新, 如果词被查过则可以很快获取到结果. 如果没有被查过则需要主动更新到关系表中.
* 如果更新一条新的bug, 需要主动更新到关系表(查询所有已知keyword的映射关系)

### 整理知识点

---