# 24 外交豁免权

### 笔记

---

==技术债务(technical debt)==会不断给项目带来风险和额外的工作, 直到你重构, 测试并且代码编写文档.

#### 目标: 采用最佳实践

好的软件实践方法:

* 将源代码使用版本控制工具管理起来
* 为程序编写自动化单元测试脚本或者功能测试脚本
* 编写文档, 规格说明以及代码注释来记录程序的需求和实现机制

#### 反模式: 将`SQL`视为二等公民

**外交豁免权**将数据库代码排除在这些实践方法之外.

#### 如何识别反模式

* 我们正在适应一个新的开发流程: 一个轻量级的版本.
* 新的版本控制系统的训练不需要`DBA`员工的参加, 因为他们根本用不到.
* 我要怎么跟踪数据库中的表盒列的使用情况? 我们不清楚这些条目的作用, 还有就是如果它们是孤立的, 我们就考虑删除它们了.
* 有没有什么功能能比较两个数据库结构, 并给出两者的不同之处, 然后生成一个将其中一个接口修改成另一个的脚本.

#### 合理使用反模式

代码是否临时使用, 就是在你使用完之后是否立刻删掉它们. 如果不是, 则最好用最佳实践方法来管理它们.

#### 解决方案: 建立一个质量至上的文化

软件工程的质量保证流程:

* 清晰定义项目需求, 并且写成文档.
* 设计并实现一个需求方案来满足需求.
* 验证并测试解决方案符合需求.

##### 陈列A: 编写文档

应该将数据库的需求和实现也写成文档, 就像对待程序代码那样.

**清单**

* `实体关系图(ER)`
* `表,列以及视图`
	* 表 
		* 每张表与其存储多少行数据
		* 希望如何对这张表进行查询
		* 表中有哪些索引
	* 列
		* 哪些值对于这一列是有意义的(取值范围)
		* 是否接受NULL
		* 有没有唯一性约束, 如果有, 为什么要有?
	* 视图(存储了对于一张或多张表的常用查询结果)
		* 为什么要创建视图
		* 哪个产品或者用户需要使用这个视图
		* 是不是视图提取表之间的复杂关系
		* 视图会不会让没有权限的用户查询一张需要授权的表的部分数据
		* 是否可以更新
* `关系`, 引用完整性约束表示了表和表之间的依赖关系, 但是还需要表示出设计的约束模型.
* `触发器` 触发器实现的业务逻辑
* `存储过程` 
	* 要解决什么问题
	* 是否会改变数据
	* 输入输出参数的类型和意义
	* 是否用来替换一种查询请求, 就能够解决某个性能瓶颈
	* 是否会让没有权限的用户访问的需要权限的表
* `SQL 安全`
	* 账户, 权限
* `数据库基础设置`	
	*  冗余备份
	*  集群
	*  访问代理
	*  备份方案
* `ORM` 如果应有数据库处理的逻辑卸载了程序代码中(基于`ORM`类的层的一部分).

##### 寻找证据: 源代码版本控制

需要将和数据库开发相关的文件都提交到版本控制服务中去.

* 数据定义脚本
* 触发器和存储过程
* 初始数据
* ER 图及文档
* DBA 脚本

##### 举证: 测试

测试的一个重要原则就是隔离, 即同一时间点只测试系统的一个部分, 如果存在缺陷, 你可以尽可能缩小出错的范围.

验证数据库清单:

* `表,列和视图`, 测试一下所希望存在的表, 视图是否真的在数据库中存在.
* `约束`, 验证约束是否有效.
* `触发器`, 通过执行一个语句来引发这个触发器测试这些场景, 然后再进行一次查询来验证触发器是否按照你所期望的方式执行了.
* `存储过程`, 类似单元测试那样测试存储过程.
* `初始数据`, 用一下查询语句进行查询来验证初始数据是否存在.
* `查询`, 在测试环境中执行一些查询操作来验证语法和结果.
* `ORM类`(我们不怎么使用`orm`, 个人觉得`orm`测试起来不太方便)

##### 例证: 同时处理多个分支

每个项目组内的开发人员使用独立的数据库实例, 从而在不影响整个团队中其他人开发进度的情况下, 能够完成开发任务.

### 整理知识点

---