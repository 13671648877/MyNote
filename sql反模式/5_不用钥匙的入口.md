# 5 不用钥匙的入口

### 笔记

---

**目标:简化数据库架构**

`引用完整性`式合理的数据库设计和操作的非常重要的一部分.

#### 反模式:无视约束

**假设无暇代码**

编写特定的程序代码来确保数据间的关系的完整性.但是:

要避免在没有外检约束的情况下产生引用的不完整状态,需要在任何改变生效前执行`额外的SELECT查询,以此来确保这些改变不会导致引用错误`.如果恰巧在删除操作的查询和删除语句的执行间隙插入了一条新的缺陷记录,就需要引入"`锁`".在检查数据时显示地锁住表,然后在删除完成之后再解锁.`在高并发和大数据量查询时的表现都非常糟糕`.

**检查错误**

需要额外的玩不脚本来检查错误的数据.

**那不是我的错**

比如对数据库的操作封装了一些函数,但是可能用户直接通过命令行来操作数据库.那么通过程序来保证的引用完整性则将无效.

需要仰仗数据库中的引用关系始终是正常的不出错的.但你不能确定所有的应用程序或者脚本在访问数据库时所作的事情都是正确合理的.

**进退维谷**

维护外键使得更新多张表中的相关联的列变得比较麻烦.

#### 如何识别反模式

* 查找那些孤立的行.
* 有没有一种简单的方法来判断在一张表中存在的数据是否也在第二张表中存在.
* 外键,会影响数据库的效率.

#### 合理使用反模式

对与我目前的程序设计,尽量避免使用MyISAM在主库的情况下.但是现在从库其实也可以用使用InnoDB了.

#### 解决方案:生命约束

`防差错技术`,通过使用外键来确保引用完整性.

那些现存的代码以及临时的查询都将遵守同样的约束,因而,不会给任何被遗忘的代码片段或涨其他的访问方式绕开约束的方法.数据库本身就会拒绝所有不合理的改变,无论这个改变是通过什么方式造成的.

**支持同步修改**

级联更新.

**系统开销过度?不见得**

* 不需要再更新或删除记录前执行`SELECT`进行检查.
* 在同步修改时不需要再锁住整张表.
* 不再需要执行定期的监控脚本来修改不可避免的孤立数据.

外键使用方便,提高性能,还能帮助你再任何简单活复杂形势的数据变更下始终维持引用完整性.

### 整理知识点

---

#### 外键的示例和使用