# 25 魔豆

### 笔记

---

#### 目标: 简化`MVC`的模型

当使用`模型-视图-控制器(MVC)`架构的时候, 我们同事在使用设计模式和软件框架.

**MVC**

* 控制器: 接收用户的收入, 定义一些程序需要完成的==响应逻辑==. 再委托合适的模型执行操作, 然后将返回结果返回给视图.
* 模型: 处理所有其他的事情, 它们是程序的==核心==, 包括输入验证, 业务逻辑和数据库交互.
* 视图: 处理在用户界面展示信息.

#### 反模式: 模型仅仅是活动记录

**ORM**

模型是数据中某个表的映射对象, 也是一种对象-关系映射(`ORM`), 只有基本的`CRUD`操作.

它也是一种设计模式, 称之为`活动记录`.

大部分WEB框架使用这种模式作为数据访问对象(`DAO`).

**抽象泄露**

框架暴露的使用`SQL`内部不接口越多, 你就会越觉得不如直接使用`SQL`来得方便.

抽象模式因此不再能隐藏它的秘密.

##### 活动记录模式连接程序模型和数据库结构

一个普通的活动记录只能表示数据库中一张表或者一个视图. 活动记录中每一个字段对应于相关表中的一列.

如果需要重构数据库来表示一个新数据结构, 模型就需要跟着改变.

*我的理解就是模型和具体的存储强耦合了, 与其说是面向对象编程倒不如说是面向数据表的编程*

##### 活动记录模式暴露了`CRUD`系列函数

将活动记录类的`CRUD`方法暴露给驱动模型类是否真的有意义? 要如何阻止那些使用这些方法的程序的不合理调用?

*别的程序员可以跳过你封装的方法而直接使用`CRUD`方法来操作你的模型,因为`CRUD`也是`public`类型的可以调用*

##### 活动记录模式支持弱域模型

一个活动记录模型通常除了`CRUD`方法之外, 没有别的行为. 这个模型没有对应业务逻辑的方法.

**弱域模型**

将模型简单地当成数据访问对象, 鼓励开发人员将业务逻辑放在模型类之外去实现, 这些业务逻辑就会被拆分到多个==控制类==中, ==减少了模型本身的内聚行为==.

**缺点**

如果增加一个控制器, 即使这个控制器对模型对象的查询逻辑和其他的控制器中的实现很类似.

##### 魔豆难以进行单元测试

无法将数据访问与模型行为分开测试.

#### 如何识别反模式

* 我要怎么传递一个自定义的`SQL`查询给模型
* 我应该复制复杂的模型查询到我所有的控制器内, 还是在一个抽象的控制器内实现这些代码.
	* 应该将复杂的查询代码卸载模型类里面, 作为模型类的接口暴露出来
* 我不得不写更多的数据库固定工具来对模型进行单元测试

#### 合理使用反模式

使用活动记录的好地方是原型开发.

#### 解决方案: 模型包含活动记录

* 控制器处理程序输入
* 视图处理程序输出
* 模型包含了面向对象设计中的其余部分

##### 领会模型的意义

**信息专家**

一个对象应该有所有需要的数据来满足它所负责的操作.

模型和活动记录之类的`DAO`之间的关系应该是`HAS-A(聚合)`而不是`IS-A(继承)`. 大多数依赖于活动记录模式的框架都使用`IS-A`的解决方案.

**创造者**

一个模型如何维护数据库应该是它的==内部实现细节==.

程序的控制器和视图应该使用领域模型的接口, 而不用关心这个模型使用哪种数据库交互式对数据进行存取. 就算以后修改数据库查询, 只需要修改一个地方.

**低耦合**

解耦程序中的逻辑区块是非常重要的, 这么做能够让你更加灵活地改变某一个类的实现, 同时又不影响这个类的调用方式.

**高内聚**

领域模型的接口应该反映出他所期望的调用方式, 而不是数据库物理结构的`CRUD`操作.

```php
assignUser() 的理解要优于 find(), first(), insert(), save()
```

##### 将领域模型应用到实际工作中

书中给出的解决方案就是在`活动记录`上次包含一个领域模型, 由领域模型来封装业务逻辑.

##### 回到地球 

### 整理知识点

---