# 13 乱用索引

### 笔记

---

#### 目标: 优化性能

改善性能最好的技术就是在数据库中合理地使用索引.

索引也是**数据结构**, 它能使数据库将指定列中某个值快速定位在相应的行.

#### 发模式: 无规划地使用索引

* 不使用索引或索引不足
* 使用了太多的索引或者使用了一些无效索引
* 执行一些让索引无能为力的查询

##### 无索引

数据库在保持索引同步的时候会有**额外的开销**.我们每次使用 `INSERT`, `UPDATE`, `DELETE` 时, 数据库就不得不更新索引的数据结构来使得所记录的表数据是一致的.

**索引能够通过带给你更多的好处来抵消它的额外开销**.

##### 过多索引

* 为主键建立索引(建立额外的索引),数据库会为主键自动创建索引,额外定义一个索引就是一个冗余操作.
* 对于`长字符串`的索引要比更为紧凑数据类型的索引要大很多.
* 对于不需要搜索的列建立索引.
* 复合索引需要考虑最左前缀原则.

##### 索引也无能为力

参考复合索引的最左前缀, 以及那些情况不能使用索引.

[复合索引](https://github.com/chloroplast1983/readingNotes/blob/master/%E6%9D%82%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E5%A4%8D%E5%90%88%E7%B4%A2%E5%BC%95.md "复合索引") 

#### 如何识别反模式

* 这是我的查询语句, 我要怎么才能让它更快?
* 我在每个字段上都定义了索引, 为什么它没有变得更快?
* 我听说索引会使数据库变慢, 所以我不会使用它.

#### 合理使用反模式

**低分离率索引**

`分离率`是衡量数据索引的一个指标. 它是一张表中, ==所有不重复的值得数量和总记录条数之比==.

```sql
SELECT COUNT(DISTINCT status) / COUNT(status) as selectivity FROM Bugs;
```

`分离率`的值`越低`, 索引的效率就`越低`.

比如一个单词在书本中频繁地出现, 就可能会有很多页码(索引). 要找到所需要找到的部分, 就不得不翻到这个列表中的每一页去查看.

需要频繁地在索引和页面间来回查找所需要的内容.

如果一个给定的值出现在这张表的很多条记录中, 查询索引比简单地扫描一遍整张表更麻烦.

**抛弃分离率低的索引**

#### 解决方案: MENTOR 你的索引

使用 `MENTOR`方法来分析数据库索引的使用

* `M`easure: 测量
* `E`xplain: 解释
* `N`ominate: 挑选
* `T`est: 测试
* `O`ptimize: 优化
* `R`ebuild: 重建

##### 测量

`Mysql`的慢查询日志来测量最耗时的查询.

**做查询性能测试时候要进制所有的查询结果缓存**

##### 解释

**查询执行计划**

每个数据库都使用一种优化工具为每次查询选择合适的索引.

`Mysql`的`EXPLAIN`工具.

##### 挑选

* MySQL Enterprise Query Analyzer

**索引覆盖**

如果一个索引包含了我们所需要的所有列, 那就不需要再从表中获取数据了.

可以定义让一个索引包含额外的列, 即使这些列对于这个索引来说并不是必须包含的.

##### 测试

创建完索引之后, 需要重新跟踪那些查询. 需要确认你的改动确实提升了性能.

##### 优化

索引是小型的, 频繁使用的数据结构, 因而很适合将它们常驻在内存中.

**预载入方法**

`Mysql` 使用 `LOAD INDEX INTO CACHE` (只能用于 `MyISAM`).

##### 重建

索引在平衡的时候其效率最高, 当你更新或者删除记录时, 索引就主键变得不平衡. 要定期对索引进行维护.

`Mysql`: `ALALYZE TABLE` or `OPTIMIZE TABLE`.

### 整理知识点

---