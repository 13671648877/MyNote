# 19 隐式的列

### 笔记

---

#### 目标: 减少输入

符号`*`意味着所有的列, 因此列的列表时==隐式==定义的, 而==不是显示==的.

```sql
SELECT * FROM xxx;
```

不需要列出列名让`SQL`语句更短.

```sql
INSERT INTO xxx VALUES (xxx,xxx,xxx);
```

#### 反模式: 捷径会让你迷失方向

* 通配符
* 未命名列

能够达到减少输入的目的, 这个习惯会带来一些危害.

##### 破坏代码结构

**INSERT**

使用隐式模式执行`INSERT`时, 输入必须严格按照定义表时的那些列的顺序. 如果列变了, 这条语句就会抛出一个错误, 甚至有可能吧数据写到错误的列里面去.

**SELECT**

使用了通配符, 就无法预测这个查询会返回多少行.

##### 隐藏的开销

在查询中使用通配符可能会影响性能和扩展性. 一次查询所获取的列越多, 客户端程序和数据库之间的网络传输的字节数越多.

##### 你请求, 你获得

`SQL` 不支持这种"除了我不想要的, 其他都要"的语法. 你只能使用通配符获取一张表的所有列, 或者一个个显式地列出所有你想要的列.

#### 如何识别反模式

* 程序由于还使用老的列明而挂掉了. 我们尝试了更新所有相关的代码, 但可能还有地方漏掉了.
* 我们花了几天时间终于找到了网络的瓶颈, 最终我们见笑了到数据库服务器的庞大的通信量. 根据我们的统计信息, 平均每个查询请求获取`2MB`的数据, 但是只有十分之一是用来显示的.

#### 合理使用反模式

#### 解决方案: 明确列出别名

每次查询时都列出所有你需要的列, 而不是使用通配符或者隐式列的列表.

##### 预防错误

查询时指明所需要选择的列, 这能让`SQL`查询更好地应付错误以及更早地暴露问题.

* 如果这张表中某一列的位置被移动过, 它不会对返回结果中这一列的位置造成影响.
* 如果这张表新加入一列, 它是不会出现在查询结果中的.
* 如果从这张表中删除一列, 你的查询会得到一个错误 -- 但是这样挺好, 因为你直接就能定位到出错的查询语句, 而不是在时候追查问题的起因.

**尽早出错**原则

##### 你不需要它

一旦你禁止了`SQL`通配符, 就很自然地有针对性地去除那些你不需要的列, 同时也意味着更少的输入. 这也能使得网络带宽的使用更加有效率.

##### 无论如何你都需要放弃使用通配符

一开始就不适用通配符, 那之后要对查询进行修改就会变得更加方便.

### 整理知识点

---