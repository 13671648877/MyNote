# 16 随机选择

### 笔记

---

#### 目标: 获取样本记录

相比于将整个数据集读入程序中再取出样例数据集, 直接通过数据库查询拿出这些样例数据集会更好,

目的: 写出一个仅返回随机数据杨蓓的高效`SQL`查询.

#### 反模式: 随机排序

```sql
ORDER BY rand()
```

排序的依据是给每一条记录分配一个随机值的函数,

使用不定表达式(`rand()`)意味着整个排序过程无法使用利用索引, 因为没有索引会基于随机函数返回的值. ==每次选择的时候都不同并且不可预测==.

不使用索引的后果就是查询结果不得不由数据库"手动地"重新排序, 这杯称为一次**全表遍历**, 并且经常伴随着将整个结果集保存到临时表中以及通过物理交换表内数据顺序操作来进行排序的情况. 一次全表排序比使用索引排序要慢得多, 并且性能的差异随着数据量的增长而更加显著.

#### 如何识别反模式

* 在`SQL`中, 返回一个随机行真慢啊!
* 我要怎么增加我的程序的可使用内存大小? 我要获取所有的记录然后随机选择一个.
* 你是不是也觉得有些列出现的频率比别的要高一些? 这个随机算法貌似不是很随机.

#### 合理使用反模式

随机排序的性能问题在数量很小的时候是可容忍的.

#### 解决方案: 没有具体的顺序

随机选择是需要全表遍历并且耗时地进行手动排序的一个典型案例.

##### 从`1`到最大值之间随机选择

避免对所有数据进行排序的方法, 就是在`1`到最大的主键值之间随机选择一个.

**使用场景**

确信==主键是从1到最大值连续的时候, 可以使用这个方案==.

##### 选择下一个最大值

解决了在`1`到最大值之间有缝隙的情况, 这个查询会返回它随机找到的第一个有效的值.

**使用场景**

当队列中的缝隙不大并且每个值都要被等概率选择的重要性==不高时==, 可以考虑使用这种方案.

##### 获取所有键值, 随机选择一个

使用程序代码来获取所有的主键值, 然后随机选择一个.

**优点**

* 避免了对全表的排序
* 选择每个键的概率相同

**缺点**

* 得到一个过长的列表, 可能会超出程序所能处理的内存极限.
* 查询必须执行两次:
	* 获取主键的列表
	* 获取对应的记录

**使用场景**

* 查询逻辑简单
* 数据量适度的时候

##### 使用偏移量选择随机行

计算总的数据行数, 随机选择`0`到总行数之间的一个值, 然后用这个值作为`位移`(`LIMIT 1, OFFSET`)来获取随机行.

**使用场景**

* 不能保证主键是连续的
* 需要每行都有相同的选中概率

##### 专有解决方案

检查数据库是否有专有的数据解决方案.

### 整理知识点

---