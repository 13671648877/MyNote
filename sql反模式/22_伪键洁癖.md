# 22 伪键洁癖

### 笔记

---

#### 目标: 整理数据

```
bug_id	status
1		xxx
2		xxx
4		xxx
```

`bug_id 3`这行不见了

#### 反模式: 填充角落

人们对于断档的第一反应就是想要填补其中的空缺.

##### 不按照顺序分配编号

将找到的第一个未分配的主键编号分配给新行.

```sql
SELECT MAX(bug_id) + 1
```

如果使用这种方式分配主键, 那么当有两个程序同时想要找到最小的未使用值时, 会出现并发访问的问题.

##### 为现有行重新编号

更新现有的所有主键, 让其变得连续, 从而消除断档.

当数据库生成一个新的伪键时, 这个值是根据上次生成的值来计算的(即使上次生成的这条记录已经被删除了, 也不会有任何影响), 并不是按照现有记录中的最大值来计算的.

##### 知道数据差异

如果别的外部系统愈来愈数据库中的主键来定义数据, 那么你的更新操作就会使这个系统中的引用失效.

**断档**往往是由于一些合理的删除或者回滚数据所造成的.

#### 如何识别反模式

* 在我回滚了一个插入操作后, 要怎么重用哪个自动生成的标识?
* `bug_id 4`的这条记录怎么了?
* 我要怎么找到第一个未使用的`ID`.
* 如果达到了数字标识的最大值怎么办?(2^32 每秒插1000条需要插入136年, 或者可以使用64位整形)

#### 合理使用反模式

没有理由改变伪键的值, 因为它的值本身没有什么重要的意义. 如果这个主键列有实际的意义, 那么就是一个自然键, 而不是伪键. 改变自然键的值并不奇怪.

#### 解决方案: 客服心里障碍

主键的值必须是==唯一==且==非空==的, 因为你才能使用主键来唯一确定一行记录, 但这是主键的唯一约束 -- 它们不一定非得是连续值才能用来标记行.

##### 定义行号

大多数伪键返回的数字看起来就像行号一样, 因为它们就是==依次递增==的(每一个新返回的值都比前一个值大`1`), 但这只是由于伪键实现机制所造成的巧合而已. 按照这样的方式生成主键值能比较方便地确保唯一.

别把主键和行号混为一谈. ==主键是用来表示表中记录的, 而行号是用来表示查询结果集中记录的==.

##### 使用`GUID`

使用数据库提供**全局唯一标识符(GUID)**

**优点**

* 都在多个数据库服务器上并发地生成伪键, 不同担心生成同样的值

**缺点**

* `GUID`的值太长, 不便于输入
* `GUID`的值是随机的, 没法依靠最大值来判断哪一行是最新插入的
* `GUID`的存储需要`16`字节. 比传统的`4`字节整型伪键占用更多的空间, 并且查询速度更慢.

### 整理知识点

---