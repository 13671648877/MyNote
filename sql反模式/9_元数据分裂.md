# 9 元数据分裂

### 笔记

---

#### 目标: 支持可扩展性

优化数据库的结构来提升查询的性能以及支持表的平滑扩展.

#### 反模式: 克隆表与克隆列

反模式的两种表现形式:

1. 将一张很长的表拆分成多张较小的表, 使用表中某一个特定的数据字段来给这些拆分出来的表命名.
2. 讲一个列拆分成多个子列, 使用别的列中的不同值给拆分出来的列命名.

为了要达成减少每张表记录数的目的, 不得不创建一些有很多列的表, 或者创建很多很多表. 但在这个两个方案中, 你会发现随着数据量的增长, 会有越来越多的表或者列, 因为新的数据迫使你创建新的`Schema`对象.

##### 不断产生的新表

比如按照年份来拆表:

```
CREATE TABLE Bugs_2008 (...)
CREATE TABLE Bugs_2009 (...)
CREATE TABLE Bugs_2010 (...)
```

如果到了`2011`年就要创建一张新的表. 意味着新的数据可能会需要新的元数据对象.

##### 管理数据完整性

没有任何办法自动地对数据和相关表名做限制, 但可以在每张表中都声明一个`CHECK`的约束.

##### 同步数据

如果上面的表中的数据要修改日期, 就不是一个简单的`UPDATE`聚聚.

需要先溢出, 然后插入到另一张表中.

##### 确保唯一性

需要确保所有被分割出来的表中的主键都是唯一的. 如果需要从一张表中移动一条记录到另一张表中, 需要保证被移动记录的主键值不会和目标表中的主键记录冲突.

可能不得不定义一张额外的表来存储产品中主键的值.

##### 跨表查询

只能使用`UNIOn`来将所有分割表联合起来得到一个重构过的集合. 比如查询`Bug`总数, 就需要查所有的表然后汇总.

##### 同步元数据

如果给一张旧的表插入一个新的列, 那么就要同步到其他所有表才可以.

##### 管理引用完整性

关联表不能声明一个外键了. 一个外键必须指定单个表.

如果`Bug`表关联了一个`Account`, 那么当需要查一个账户的所有`Bug`就必须`UNION`所有的`Bug`表.

##### 标识元数据分裂列

列也可能根据元数据分裂.

比如在一张表中:

```
CREATE TABLE ProjectHistory (
 bugs_fixed_2008 INT,
 bugs_fixed_2009 INT,
 bugs_fixed_2010 INT
);
```

#### 如何识别反模式

* 那么我们需要每....创建一张表(或者列).
* 数据库所支持的最大数量的表(或者列)是多少.
* 我们终于发现为什么今早程序添加新记录失败了: 我们忘记为新的一年添加新表了.
* 我要怎样同时查询很多张表? 每张表的列都是一样的.
* 我要怎样将表名作为一个变量传递.

#### 合理使用反模式

手动分割表的一个合理使用场景是**归档数据**--将历史数据从日常使用的数据中移除. 通常在过期数据的查询变得非常稀少的情况下, 才会进行如此的操作.

#### 解决方案: 分区及标准化

**水平分区**, **垂直分区** 以及使用 **关联表**.

##### 使用水平分区

根据==行==来对表进行拆分.

可以使用**水平分区**或者**分片**的数据库特性来分割大数据量的表, 同时又不用担心那些分割表所带来的缺陷. 

物理上来说, 表的确是被拆分了, 但你依旧可以像查询单一表那样执行`SQL`查询语句.

```sql
CREATE TABLE Bugs(
	bug_id SERIAL PRIMARY KEY,
	...
	date_reported DATE
) PARTITION BY HASH ( YEAR(date_reported) )
  PARTITIONS 4;
```

##### 使用垂直分区

根据==列==来对标进行拆分. 

当某些列非常庞大或者很少使用的时候, 对表进行按列拆分会比较有优势.

把`BLOB`类型和`TEXT`类型单独拆分成一张表.

##### 解决元数据分裂列

就解决元数据分裂的改进方案就是创建关联表.

```sql
CREATE TABLE ProjectHistory (
	project_id BIGINT,
	year SMALLINT,
	bugs_fixed INT,
	PRIMARY KEY (project_id, year),
	FOREIGN KEY (project_id) REFERENCES Projects(project_id)
);
```

每行一个项目, 每一**列**记录一年的`Bug`修复数量, 还不如使用**多行**,仅用**一列**记录修复的`Bug`数量. 如果你这样定义表, 就不需要为随后的年份增加新列, 随着时间的整张, 可以为每个项目存储任意数量的记录.

### 整理知识点

---