# 11 每日新花样

### 笔记

---

#### 目标: 限定列的有效值

将一列的有效字段值约束在一个固定的集合内是非常有用处的. 如果我们可以确保一列中永远不会包含无效字段, 那么对于使用方来说, 逻辑会变得非常简单.

#### 反模式: 在列定义上指定可选值

**`MySQL`中使用`ENUM`的排序问题**

虽然使用字符串表示`ENUM`里的值, 但实际存储在列中的数据是这些值在定义时的序数. 这列的数据是==字节对齐==的, 当你进行一次排序查询时, 结果是按照实际存储的序列号进行排序的, 而==非对应字符串的字母序==.

##### 中间的是哪个

从数据获取一个`ENUM`列中的所有值较为麻烦.

##### 添加新口味

修改一个`ENUM`值, 没有什么语法支持从`ENUM`或者`Check`约束中添加或删除一个值. 只能用一个新的集合重新定义这一列.

##### 老的口味永不消失

从`ENUM`中废弃一项(移除一项), 如何修改老数据? 改变其值,设置其为空?

##### 可移植性低下

`Check`约束在各种数据控中的支持并不同意.

`ENUM`是`MySQL`独有的特性.

#### 如何识别反模式

如果后悬置的集合是需要改变的, 那么使用`ENUM`不见得是好主意.

* 我们不得不将数据库下线, 才能在程序菜单中加入一个新的选项. 如果一切顺利, 整个过程将不超过3小时.
* 这个`status`列可以填入这些候选值中的一个. 我们不应该改变这个候选值列表.
* 程序代码中关于业务规则的选项列表和数据中的值有不同步了.

#### 合理使用反模式

`ENUM`在存储没有业务逻辑且不需要改变的候选值时是非常方便的.

#### 解决方案: 在数据中指定值

创建一张**检查表**, 每一行包含一个允许在`Bugs.status`类中出现的候选值; 然后顶一个外键约束, 让`Bugs.status`引用这张新表.

##### 查询候选值集合

可以直接使用`SELECT`查询. *感觉就是类似数据字典*

##### 更新检查表中的值

如果有任何值修改可以直接修改这张**检查表**.

如果有更新也可以使用外键约束`ON UPDATE CASCADE`选项.

*书中的例子是检查表直接存储`string`, `Bugs.status`外键这个`string`, 我觉得为什么不建立一个主键id, 直接引用这个id, 这样修改值也不会引起联动触发, 根据状态查询使用int也会更快一些*

##### 支持废弃数据

在原来的检查表中增加一列`active`, 来标记时启用还是废弃. 这样就可以标记哪些废弃的标记.

```
bugStatus表

status			activity
new				active
fixed			active
duplicate		inactive
```

可以使用`inactive`来废弃`duplicate`标记.

##### 良好的可移植性

**检查表** 只依赖于最基本的`SQL`特性: 使用外键确保引用完整性, 这使得该解决方案的兼容性得到了保证.


### 整理知识点

---