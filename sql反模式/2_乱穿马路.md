# 2 乱穿马路

### 笔记

---

`乱穿马路`: 用`逗号分隔的列表`来避免在`多对多`的关系中创建`交叉表`.

**目标:存储多值属性**

原来每一个产品有一个联系人,随着业务发展现在需要一个产品可能会有多个联系人.

`货物表`: Products 
`账号表`: Accounts

**反模式:格式化的逗号分隔列表**

原来用`int`存储账户ID(一个),改成`varchar`并且每个账号ID之间用逗号分隔(1,2,3).

**弊端**

1. 查询指定账号的产品(account_id=xx)

		SELECT * FROM Products WHERE account_id REGEXP '[[:<:]]xx[[:>:]]'

	* 可能返回错误结果
	* 不能使用`索引`
	* 模式匹配表达式(REGEXP)的语法在不同品牌的数据库中是`不同`的(数据库不兼容),`SQL不是平台中立`
	
2. 查询指定产品的账号

		SELECT * FROM Products AS p JOIN Accounts AS a ON a.coount_id REGEXP '[[:<:]]' || a.account_id || '[[:>:]]' WHERE p.product_id = 123

	* `不能`使用索引. 查询必须`扫描两张表`,创建一个`交叉结果`,然后使用`正则表达式` `遍历`每一行联合后的数据进行匹配.
	
3. 聚合查询(COUNT(),SUM(),AVG() 这些函数是针对`分组`而设计的, `不是`为了逗号分隔的列表)

	为了查询每个产品的账号总数:
	
			SELECT product_id, LENGTH(account_id) - LENGTH(REPLACE(account_id, ',' ,'')) + 1 AS contacts_per_product FROM Products;
			
	* 查询目的不清晰
	* 不能使用聚合函数

4. 更新制定产品的账号

	`使用字符串拼接的方式增加一个新的ID`:
	
		.... 
		SET account_id = account_id || ',' || 56
		....

	`从列表中删除一个条目`:
	
	* 提取老的列表
	* 存储更新后的列表
	
5. 验证产品ID
	
	`无法防止用户输入非法字段`(int 改为 varchar后)
	
			INSERT INTO ...(account_id) VALUES ('1,2,banana')
			
	* 不是数据库错误, 但是数据无法验证(从数据库手段上)

6. 合适的分隔符

	`用逗号做分隔符, 但是输入的数据可能包含逗号. 就算换了字符还是不能保证这个新字符永远不会出现在数据录入的内容里面`

7. 列表长度限制

	在一个`varchar(30)`的结构中存多少数据, 依赖于每个条目的长度. (每个条目只有2个字符长, 能存10个条目, 包括逗号. 每个条目的长度为6, 只能存4个). 无法确定`varchar(30)`能够支持未来所需的最长列表.
	
**反模式违反范式**

以上用逗号分隔已经`违反`了数据库第一范式. 

**解决方案:创建`交叉表`**


`account_id`不在存储在`Products`, 存储在新的`Contacts`表(存储`account_id` 和 `product_id` 的关系).

一张表有指向另外两张表的外键时, 称为`交叉表`.

		Accounts(账号) -- Contacts(联系,中间表) --- Products(产品)

`优势`: 

* 可以使用`索引`, 查询效率高.
* 可以`关联`其他信息, 比如联系人加入的时间可以单独在`交叉表`创建新的一列(用逗号分隔的形式不能解决)

**总结**

1. 遵循数据库`范式`
2. 了解`交叉表`
3. 示例:

	`一个字段存储用逗号分隔的数据`(违反第一范式)
	
		uid 	oid
		1		1,2,3
		
	`交叉表`(效率高)
	
		uid		oid
		1		1
		1		2
		1		3

###整理知识点

---