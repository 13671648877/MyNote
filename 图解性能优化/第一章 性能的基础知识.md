# 第一章 性能的基础知识

---

## 1.1 性能的基础知识

算法.

## 1.2 算法的优缺点与学习方法

通过有效的缩小查找范围, 只需要很少的次数就能快速找到需要的东西. 这样的策略或方法就称为"算法".

算法的基础:

1. 箱子连成一排
2. 地址
3. 可以在箱子里面放地址
4. 知道地址的话就能立即访问

## 1.3 算法的应用实例及性能差异

### 评价算法的指标

计算机原则上是处理大数据的东西, 所以我们只关心当前数据量变大时决定性能优劣的关键(Key). 这个关键就是复杂度(Order). 如`y = n`或`y = 2n`其复杂度标记为`O(n)`. 而`O(1)`则表示不会受到数据量增加的影响.

为什么`y = 2n`中的`2`是可以忽略的. 因为如果和`y = n^2`比较, `2n`的`2`对整体是不产生影响的.

**在比较算法优劣时, 会忽略掉一些微小的系统开销. 应该关注的是随着数据个数的变化, 所花费的时间会以怎样的曲线发生变化.**

### 树

在树的根节点放置一个数据, 接着将比它大的数据放在右边, 比它小的数据放在左边, 以此方法进行分类. **这一过程就是把数据对半分的操作**. 这种操作的复杂度标记为`O(logn)`.`logn`指的是把`n`除以`2`多少次后会变为`1`.

复杂度介于`O(1)`和`O(n)`之间.

## 1.4 响应与吞吐的区别

性能的两个重要概念:

* **响应**表示的是应答的快慢.
* **吞吐**表示的是处理数量的多少.

擅长高并发处理的系统被称为"偏重吞吐的系统".

## 1.5 算法的具体例子

### B+树, B树 和 B*树

### 散列算法

**散列碰撞**, 获得相同散列值的现象称为"碰撞". 解决方法:

1. 用链表结构连接起来.
2. **重散列(ReHash)**, 再一次计算散列值, 将其缝在另外一个位置.

### 队列

先入先出(`FIFO`).

### 栈

先入后出(`FILO`).

只要占用必要的空间, 不会让空间产生碎片. 只要处理一完成, 那部分空间就会被腾出来, 行程连续的内置空间.

**OS在执行程序的时候, 也使用这样的机制**. 以栈的形式展现了哪个函数调用了哪个函数.

### 排序

#### 快速排序

#### 归并排序

### 缓存(回写)

**回写(`Write Back`)** 在更新数据的时候, 不更新数据实际存放的地方的数据, 只更新缓存内的数据, 之后再更新数据实际存放的地方.

### 缓存(直写)

数据实际存放的地方也必须更新.

### 锁与性能

**锁**就是在某个处理进行期间起到保护作用的机制, 为了防止别的处理侵入.

#### 解决锁等待的方法

比如`DB`, 不对**表**加锁, 而是对**行**枷锁. 这样就能并行执行了.

#### Tese and Set

#### Compare and Swap

