# 第三章寄存器(内存访问)

---

### 笔记

---

#### 内存中的字存储

在 0 地址处开始存放 20000 (4E20H)

* 20 存低地址 0
* 4E 存高地址 1

**字单元和单元 字节型和字型**

* 0 地址`单元`存放的`字节型`数据是: 20
* 0 地址`字单元`存放`字型`数据是多少: 4E20

字型要考虑2个字节,高地址对应高位,低地址对应低位.

**结论**

任何两个地址连续的内存单元,N(低位) 号单元和 N+1(高位) 号单元,可以将它们看成两个内存单元,也可以看成一个地址为N的字单元中的高位字节单元和低位字节单元.

#### DS 和 [address]

CPU 要读取一个内存单元的时候,必须要先给出这个内存单元的地址.

在 8086PC 中,内存地址由段地址和偏移地址组成.

8086CPU中有一个`DS`(`D`ata `S`egmant)寄存器,通常用来存放要访问的`数据的段地址`.

**示例**

		读取 10000H 单元的内容
		
		mov bx,1000H //段,所以会乘16 左移1位
		mv ds,bx
		mv al,[0]
		
		将 10000H(1000:0) 中的数据读到al中

**mov指令**

* 将数据直接送入寄存器 `mov ax,2`
* 将一个寄存器中的内容送入另一个寄存器 `mov bx,ax`
* 将一个内存单元中的内容送入一个寄存器
		
		将偏移地址位0的内容送入寄存器,根据段地址
		mov al,[0]


**从哪个内存单元送到哪个寄存器中**

		mov 寄存器名,内存单元地址
		
8086cpu不支持将数据直接送入段寄存器的操作,ds是一个段寄存器.只能直接送入通用寄存器.

		数据 -> 通用寄存器 -> 段寄存器

将数据从寄存器送入内存单元:
		
		
		mov bx,1000H
		mov ds,bx
		mov [0],al			
			
#### 字的传送

8086CPU是16位结构,有16根数据线,所以,可以一次性传送16位的数据,也就是一次性传送一个字.

		mov bx,1000H
		mov ds,bx
		mov ax,[0]  //将1000:0处的字型数据送入ax
		mov [0],cx  //将cx中的16位数据送到1000:0处

因为以前CPU是 `8` 位,所以用`字节`.
后来 `16` 位, 用`字`.
后来 `32` 位, 用 `双字`

#### mov,add,sub 指令

**mov**

		mov 寄存器, 数据 		mov ax,6
		mov 寄存器, 寄存器	mov bx,ax
		mov 寄存器, 内存单元 	mov ax,[0] (偏移地址)
		mov 内存单元, 寄存器	mov [0],ax
		mov 段寄存器, 寄存器	mov ds,ax
		
可以推导出

		mov 寄存器, 段寄存器	mov ax,ds
		
**add 和 sub**

		add 寄存器,数据		add ax,8
		add 寄存器,寄存器		add ax,bx
		add 寄存器,内存单元	add ax,[0]
		add 内存单元,寄存器	add [0],ax
		sub 寄存器,数据		sub ax,9
		sub 寄存器,寄存器		sub ax,bx
		sub 寄存器,内存单元	sub ax,[0]
		sub 内存单元,寄存器	sub [0],ax	

#### 数据段

我们可以根据需要将一组内存单元定义为一个段(可以使代码段,数据段等).

我们可以将一组长度为N(N<=64K),地址连续,其实地址为16倍数的内存单元当做专门存储数据的内存空间,从而定义了一个数据段.

		比如我们用123B0H ~ 123B9H这段空间来存放数据:
		段地址: 123BH 也可以吧段地址看做 1230
		长度: 10字节 (0~9)

如何访问数据段中的数据?

将一段内存当做数据段,使我们在编程时的一种安排,我们可以在具体操作的时候,用ds存储数据段的段地址,再根据需要,用相关质量访问数据段中的具体单元.

#### 栈

栈是一种具有特殊的访问方式的存储空间.它的特殊性就在于,最后进入这个空间的数据,最先出去.

**栈的基本操作**

* 入栈, 将一个新的元素放到栈顶.
* 出栈, 从栈顶取出一个元素.

LIFO, Last In First Out.
		
#### CPU提供的栈机制

**指令**

* `PUSH`, 入栈
* `POP`, 出栈

		push ax 将寄存器ax中的数据送入栈中.
		pop ax 从栈顶取出数据送入ax
		
8086CPU的入栈和出栈操作都是以字为单位进行的.
		
**CPU如何知道一段内存空间被当做栈使用?**

* 段寄存器`SS` 存放`栈顶`的段地址
* 寄存器`SP` 存放`栈顶`的偏移地址

任意时刻, SS:SP 指向栈顶元素.

**执行push和pop的时候,如何知道哪个单元是栈顶单元?**

当我们执行 push ax 时, CPU 内部执行了如下运算:

* SP = SP-2
* 将ax中的内容送入SS:SP指向的内存单元处,SS:SP此时指向新栈顶.

pop则是相反.

* 取出数据
* SP = SP+2

		pop ax
		1. 将 SS:SP 指向的内存单元处的数据送入(是复制不是剪切) ax 中.
		2. 将 SP = SP + 2, SS:SP 指向当前栈顶下面的单元,以当前栈顶下面的单元为新的栈顶


pop取出数据的时候,数据是存在的.下一次push会覆盖.类似硬盘格式化,数据还是存在的,只是硬盘头索引放生了变化. 一般粉碎工具就是不断重复的覆盖数据.

**当栈是空的时候,SP指向?**

10000H ~ 1000FH 这段空间当做栈,初始状态栈是空的.

SP 指向最高地址的下一个地址. 0010H (1000FH的下一个地址是 10010H).

#### 栈顶超界的问题

SS和SP只记录了栈顶的地址,依靠SS和SP可以保证入栈和出栈时找到栈顶.可是,如何能够保证在入栈和出栈时栈顶不会超出栈空间.

当栈满的时候再使用push指令入栈,栈空的时候再使用pop指令出栈,都将发生栈顶越界的问题.

栈顶越界一般就是我们说的溢出.

**栈顶超界是危险的**

因为我们既然将一段控件安排为栈(也就是我们认为这段空间是栈),那么在栈空间之外的空间里很可能存放了具有其他用途的数据,代码等,这些数据,嗲吗可能是我们自己的程序中的,也可能是别的程序中的.

**8086CPU不保证对栈的操作不会超界**

8086CPU 只知道栈顶在何处(由SS:SP指示),而不知道读者安排的栈控件有多大.这点就好像,CPU只知道当前要执行的指令在何处(由CS:SP指示)而不知道读者要执行的指令有多少.

可以得出, 8086CPU的工作机理,只考虑从当前的情况:

* 当前栈顶在何处
* 当前要执行的指令是哪一条

**结论**

我们在编程的时候要自己操心栈顶超界的问题,要根据可能用到的最大栈控件,来安排栈的大小,防止入栈的数据太多而导致的超界.出栈同理.

		我们在做C语言编程的时候,编译器会帮我们申请要栈空间,程序员自己申请的是堆.
		
`堆`是一堆连续的内存,线性表组成的.

#### push,pop指令

push 和 pop 指令是可以在寄存器和内存之间的传送数据的.

**栈与内存**

栈空间当然也是内存空间的一部分,它只是一段可以以一种特殊的方式进行访问的内存空间.

**指令格式:寄存器**

* push 寄存器
* pop 寄存器

**指令格式:段寄存器**

* push 段寄存器: 将一个段寄存器中的数据入栈.
* pop 段寄存器: 出栈,用一个段寄存器接收出栈的数据.

		push ds
		pop es

**指令格式:内存单元**

* push 内存单元: 将一个内存单元处的字入栈(栈操作都是以字为单位).
* pop 内存单元: 出栈,用一个内存单元接收出栈的数据.

		push [0]
		pop [2]

指令执行时,CPU要知道内存单元的地址,可以在 push,pop 指令中给出内存单元的偏移地址,段地址在指令执行时,CPU从`ds`中取得.

**结论**

push,pop 实质上就是一种内存传送指令,可以在寄存器和内存之间传送数据,与`mov`指令不同的是,`push`和`pop`指令访问的内存单元的地址不是在指令中给出的,而是由`SS:SP`指出的.

同时,`push`和`pop`指令还要改变`SP`中的内容.

CPU执行`mov`指令只需`一步`操作,就是传送.而执行`push`,`pop`指令却需要`两步`操作.

* 执行`push`时(写内存):
	* 先改变`SP`(-2).
	* 后向`SS:SP`处传送.
* 执行`pop`时(读内存):
	* 先读取`SS:SP`处的数据
	* 后改变`SP`(+2).

`push`,`pop`等栈操作指令,修改的只是`SP`(+2,-2).也就是说,栈顶的变化范围最大为:`0~FFFF`H(H:16进制,2^16).`64KB`范围.现在CPU没这么小,这里是因为16位CPU.

FFFFH = 0 ~ FFFFH = = 65535 + 1 = 65536 Byte = 65536 / 1024 = 64 KiB

#### 栈段

对于8086PC机,在编程时,我们可以根据需要,将一组内存单元定义为一个段.

我们可以将长度为 N (N<=64K)的一组地址连续,起始地址为16的倍数的内存单元,当作栈来使用,从而定义了一个栈段.

		比如我们将10010H~1001FH,这段长度为16字节的内存空间当作栈来用,以栈的方式进行访问.
		这段空间就可以成为栈段,段地址为1000H,大小为16字节(10-1F).
		
将一段内存当作栈段,仅仅是我们在编程时的一种安排,CPU并不会由于这种安排,就在执行PUSH,POP等栈操作指令时就自动地将我们定义的栈段当作栈空间来空间来访问.CPU只认`SS:SP`.

任意时刻,`SS:SP`指向栈顶元素,当栈为空的时候,栈中没有元素,也就不存在栈顶元素,所以`SP`只能指向栈的对底部单元下面的单元,该单元的偏移地址为栈地步的字单元的偏移地址+2,栈最底部字单元的地址为1000:FFFE(假设),所以栈空时,SP=0000H.

**一个栈段最大可以设为多少?为什么**

栈顶的变化范围是0~FFFFH,从栈空时候的SP=0,一直压栈,知道栈满时SP=0;如果再次压栈,栈顶将环绕,覆盖了原来栈中的内容.

最大是64KB,在8086CPU中,现在不止这么大.

**栈为什么重要**

早起栈用于保存返回地址.C语言从main函数开始,main函数结尾.假设A函数调用B函数,需要把A函数中寄存器数据临时保存起来,所以用栈,当调用结束的时候可以恢复.

栈可以说为了函数而存在.

#### 总结

* 任意时刻,`SS:SP`指向栈顶元素.
* 8086CPU只记录栈顶, 栈控件的大小我们要自己管理.
* 用栈来暂存以后需要恢复的寄存器的内容时,寄存器出栈的顺序要和入栈的顺序`相反`.
* `push`,`pop`实质上一种内存传送指令.

CPU 将内存中的某段内存当作代码,是以为内`CS:IP`指向了那里.CPU将某段内存当做栈,是以为内SS:IP指向了那里.

### 整理知识点

---

#### 函数局部变量

局部变量存在栈中,所以当函数出了栈,局部变量失效.

#### 函数

		main 函数调用 a 函数. main 函数中的所有寄存器都会入栈, 调用完 a 函数后,所有寄存器出栈,继续做自己函数的事情.
		
#### 清空一个寄存器的几种方法.		
		
mov ax,0 = sub ax,ax = 系统使用 xor ax,ax (xor 亦或,一样就置为0,不一样置为1,以为ax=ax,所以为0)

sub 机器码是两个字节, mov 机器码是三个字节.

#### KiB,MiB与KB,MB的区别 

MB等单位以10为底数的指数,MiB是以2为底数的指数.

1KB=10^3=1000, 1MB=10^6=1000000=1000KB,1GB=10^9=1000000000=1000MB

KiB=2^10=1024,1MiB=2^20=1048576=1024KiB

操作系统报的数量要比产品标出或商家号称的小一些,主要原因是标出的是以MB,GB为单位的.1GB就是1,000,000,000 Byte,而操作系统是以2进制为处理单位的,因此检查硬盘容量时是以MiB,GiB为单位.

1GB=2^30=1,073,741,824,相比较而言,1GiB要比1GB多出1,073,741,824-1,000,000,000=73,741,824,所以检测实际结果要比标出的少一些.

		十进制单位                              二进制单位
		------------------------------------------------------ 	 
		名字 	缩写 	次方 	 名字 	缩写 	次方
		kilobyte 	KB 	10^3 	kibibyte 	KiB 	2^10
		megabyte 	MB 	10^6 	mebibyte 	MiB 	2^20
		gigabyte 	GB 	10^9 	gibibyte 	GiB 	2^30
		terabyte 	TB 	10^12 	tebibyte 	TiB 	2^40
		petabyte 	PB 	10^15 	pebibyte 	PiB 	2^50
		exabyte 	EB 	10^18 	exbibyte 	EiB 	2^60
		zettabyte 	ZB 	10^21 	zebibyte 	ZiB 	2^70
		yottabyte 	YB 	10^24 	yobibyte 	YiB 	2^80