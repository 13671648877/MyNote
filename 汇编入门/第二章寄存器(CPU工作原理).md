# 第二章寄存器

---

### 笔记

---

#### CPU概述

一个典型的CPU由`运算器`,`控制器`,`寄存器`等器件组成,这些器件靠内部总线相连.

**区别**

内部总线实现CPU内部各个器件之间的联系.

外部总线实现CPU和主板上其他器件的联系.

**8086 CPU有14个寄存器**

* AX
* BX
* CX
* DX
* SI
* DI
* SP
* BP
* IP
* CS
* SS
* DS
* ES
* PSW

8086 CPU所有的寄存器都是16位的,可以存放连个字节.

`AX`,`BX`,`CX`,`DX`通常用来存放一般性数据被称为通用寄存器.

**AX 通用寄存器示例**

![ax](./images/2-1.png "ax")

16位数据在寄存器中的存放情况

数据: 18
二进制表示: 10010
在寄存器中AX中的存储:

![ax](./images/2-2.png "ax")

**16位寄存器所能存储的数据最大值**

2^16 - 1

16个格子 2^16, 因为数字是从0开始,所以需要 `-1`.

**兼容性**

8086上一代CPU中的寄存器都是8位的.

为保证兼容性,这四个寄存器都可以分为两个独立的8位寄存器使用.

AX 可以分为 AH(`H`igh,高位), AL(`L`ow,低位).

同样:

BX 可以分为 BH和BL
CX
DX

如果为8位,H位全部填0.

AX的低8位(0位 - 7位)构成了AL寄存器, 高8位(8位 - 15位)构成了AH寄存器.

AH和AL寄存器是可以独立使用的8位寄存器.

#### `字`在寄存器中的存储

一次读取16位的内存单元称为字, = 2个字节.

一个字可以存在一个16位寄存器中,这个字的高位字节和低位字节自然就存在这个寄存器的高8位寄存器和低8位寄存器中.

#### 物理地址

CPU访问内存单元时要给出内存单元的地址.所有的内存单元构成的存储控件是一个`一维的线性空间`.

我们将这个唯一的地址成为物理地址.

#### 16位结构的CPU

**特征**

* 运算器一次最多可以处理16位数据.
* (通用)寄存器的最大宽度为16位.
* 寄存器和运算器之间的通路是16位的.

#### 8086CPU给出的物理地址的方法

* 8086有20位地址总线,可传送20位地址,寻址能力位1M(2^20).
* 8086内部位16位结构,它只能传送16位的地址,表现出的寻址能力却只有64k(2^16 = 65536(B)/1024=64KB).

**8086CPU的解决方案**

8086CPU采用一种在内部用两个16位地址合成的方法来形成一个20位的物理地址.

* 段地址 16位
* 偏移地址 16位

通过`地址加法器`加为20位物理地址

**地址加法器合成物理地址的方法**

		物理地址 = 段地址 X 16 + 偏移地址
		
段地址x16 就是数据左移4位(二进制位).因为数据存储是以二进制形式存储.

#### 数据移位

* 一个数据的二进制形式左移1位,相当于该数据乘以2.
* 一个数据的二进制形式左移N位,相当于该数据乘以2的N次方.

* 一个数据的十六进制形式左移1位,相当于乘以16.
* 一个数据的十进制形式左移1位,相当于乘以10.
* 一个数据的x进制形式左移1位,相当于乘以x.

#### 段的概念

内存并没有分段,段的划分来自于CPU,由于8086CPU用"段地址*16 + 偏移地址 = 物理地址"的方式给出内存单元的物理地址,使得我们可以用分段的方式来管理内存.

是因为8086CPU

#### 内存单元小结

* CPU访问内存单元时,必须向内存提供内存单元的物理地址
* 8086CPU在内部用段地址和偏移地址移位相加的方法形成最终的物理地址
* CPU可以用不同的段地址和偏移地址形成同一个物理地址

		物理地址		段地址		偏移地址
		21F60H		2000H		1F60H
					2100H		0F60H
					21F0H		0060H
					21F6H		0000H
					1F00H		2F60H
* 偏移地址范围

		0000H - FFFFH,最多可以寻到64K个内存单元
		
		段地址 1000H, 偏移地址寻址,CPU的寻址范围为: 10000H ~ 1FFFFH

* 可以根据需要,将地址连续,起始地址为16的倍数的一组内存单元定义为一个段

#### 段寄存器

**段寄存器就是提供段地址的**

8086CPU有4个段寄存器:

* CS(`segment`) (`code`代码段地址寄存器)
* DS (`data`数据段)
* SS (`stack`堆栈段)
* ES (附加段)

当8086CPU要访问内存时,由这4个段寄存器提供内存单元的段地址.

**CS 和 IP**

`IP`(CPU内部的`偏移`地址寄存器)为指令指针寄存器.

`CS`和`IP`是8086CPU中最关键的寄存器,它们指示了`当前要读取指令的地址`.

**8086PC工作过程的简要描述**

1. 从`CS:IP`指向内存单元读取质量,读取的指令进入指令缓冲器.
2. `IP = IP + 读取指令的长度`,从而指向下一条指令.
3. 执行指令. 转到步骤(1),重复这个过程.

**8086开机**

* 在 8086CPU 加电启动或复位后(即CPU刚开始工作时)CS和IP被设置为:
	* CS=FFFFH
	* IP=0000H
* 即在8086PC机刚启动时,CPU从内存`FFFF0H`单元中读取指令执行.
* `FFFF0H`单元中的指令是8086PC机开机后执行的第一条指令.

**修改CS,IP的值**

CS,IP 的值不能使用 `mov` 修改.

可以使用`jmp 段地址:偏移地址` 修改.

		jmp 2AE3:3
		jmp 3:0B16 (0003(0) + 0B16 = B46H)

使用指令中给出的段地址修改CS,偏移地址修改IP.

		jmp bx  -> 修改 偏移地址(IP)

**代码段**

可以将长度为`N` ( N <= 64KB) 的`一组代码`,存在一组地址连续,起始地址位 16 的倍数的内存单元中,这段内存是用来存放代码的,从而定了一个`代码段`.

		mov ax,0000 	(B8 00 00)
		add ax,0123		(05 23 01)
		mov bx,ax		(8B	D8)
		jmp bx			(FF E3)

这段长度为 10 (1个字节 = 8 位 = 2个16进制  B8 00 .. 每个代表一个字节) 字节的字节的指令,存在从 123B0H ~ 123B9H 的一组内存单元中,我们就可以认为, 123B0H ~ 123B9H 这段内存单元是用来存放代码的,是一个代码段,它的段地址位123BH,长度位10字节.

**如何使得代码段中的指令被执行呢**

CPU 只认被 CS:IP 指向的内存单元中的内容位指令.例如DS中的会被认为是数据.

### 整理知识点

---