# 第六章 多核时代的编程

## 摩尔定律

### 高速缓存

高速缓存, 实际上是消耗一定数量的晶体管用作`CPU`内部高速存储空间, 从而提升速度的一种技术.

### CPU的分支预测

利用分支指令跳转目标上的偏向性, 实现对跳转的目标进行猜测, 并执行相应的**取出**指令操作.

### CPU的投机执行

对条件分支后的跳转目标进行预测后, 不仅仅是执行取出命令的操作, 还会进一步执行实际的运算操作. 

当条件分支的预测错误时, 需要取消刚才的执行, 但当预测正确时, 对性能的提升就可以比仅进行分支预测来的更加高效.

### 流水线 和 超标量

流水线是一种在垂直方向对指令处理进行重叠来提升性能的技术.

在水平方向上将指令进行重叠的技术成为超标量(superscalar). 在没有相互依赖关系的前提下, 多条指令可以同时执行.

### 乱序执行

```
a = b + c
d = a + e (依赖第1行)
g = d + h (依赖第2行)
j = k + l
m = n + o
```

如果将顺序改为:

```
a = b + c
j = k + l
d = a + e (依赖第1行)
m = n + o
g = d + h (依赖第3行)
```

可以填满空闲的执行单元. 稀释指令之间的相互依赖关系, 从而提高执行效率.

### 超线程

通过同时处理多个取出并执行指令的控制流程, 从而将没有相互依赖关系的运算同时送入运算器中, 通过这一手段, 可以提高超标量的利用率.

## UNIX管道

UNIX将文件定义为单纯的字节流. 对于这些字节流应当如何解释, 则交给每个应用程序来负责.

`UNIX`进程都具有标准输入和标准输出(还有标准错误输出)等默认的输入输出目标, 而`Shell`在启动命令时可以对这些输入输出目标进行连接和替换. 通过这样的方式, 就可以将某个命令的输出作为另一个命令的输入, 并将输出进一步作为另一个命令的输入, 也就是实现了命令的"串联".

## 非阻塞I/O

### 事件监视的边沿触发与电平触发

#### 边沿触发(`edge trigger`)

在状态变化的瞬间发出通知.

**边沿触发只在数据到达的瞬间产生事件, 因此总体来看事件发生的次数会比较少, 也就意味着回调函数的启动次数也会比较少, 可以提高效率**

#### 电平触发(`level trigger`)

在状态法伤变化的整个过程中都持续发出通知.

* `select`系统调用属于电平触发.
* `epoll`默认也是电平触发, 可以通过显示设置来实现边沿触发.

## node.js

### 事件驱动编程

传统的过程型编程中, 各项操作都是按照**预先设定好的顺序**来执行的.

事件驱动编程中, 不存在事先设定好的工作顺序, 而是**对来自外部的事件作出响应**.

主程序一般是用一个循环来等待事件的发生, 当检测到事件发生时, 找到并启动与该事件相对应的处理程序(回调函数). 当回调函数运行完毕后, 再次返回到循环中, 等待下一个事件.

## ZeroMQ

### 多CPU的运用方法

* 线程方式
* 进程方式

**线程**是一个**进程**中工作的控制流程. 所有的处理都必须在同一个进程中完成.

### 进程间通信

#### 管道

从一侧输出, 然后从另一侧读取. 的文件描述符对. `Shell`中的管道等也是通过这一方式实现的.

#### SysV IPC

* 消息队列
* 信号量, 带有互斥计数器的标志(`flag`)
* 共享内存, 一块在进程间共享的内存空间.

### 套接字

`UDP`几乎是原原本本直接使用了作为其基础的`IP`协议. 结构简单, 对系统产生的负荷也较小.

`TCP`为了维持可靠性, 在`IP`协议之上构建了各种机制.


