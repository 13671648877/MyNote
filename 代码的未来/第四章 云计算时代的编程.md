# 第四章 云计算时代的编程

## 可扩展性

### 大数据的查找

`O(n)`指的是计算量随参数`n`的变化情况.

`K,M,G`在表示硬盘容量等场合一般都采用十进制. 如果要表示`1024`倍递增的二进制方式, 另外有`Ki,Mi,Gi`等前缀.

#### 二分法查找

`O(log n)` 前提是, 数据之间存在大小关系, 且已经按照大小关系排序.

#### 散列表

散列表是表达一个对象到另一个对象的映射的数据结构. 从概念上来看, 它是一种采用非数值型索引的数组. 在`Python`表示为字典(`Dictionary`).

`O(1)`

##### 散列函数

用于将各个值计算成为一个称为散列值的整数. 需要满足以下性质:

* 从数据到整数值(0 ~ N-1)的映射
* 足够分散, 即便数据只有很小的差异, 散列函数的计算结果也需要有很大的差异.
* 不易冲突, 不易发生由不同的数据得到相同散列值的情况.

散列表: 以散列值为索引的数组.

##### 冲突

不同的数据拥有相同散列值的情况, 被称为"冲突".

应对冲突的方法:

* 链地址法(chaining), 将拥有相同散列值的元素存放在链表中, 随着元素个数的增加, 散列冲突和查询链表的时间也跟郑增加. 元素的删除可以用比较简单且高性能的方式来实现. (Ruby 的 Hash)
* 开放地址法(open addressing), 遇到冲突时, 再继续寻找下一个新的数据库存放空间(一般称为槽). 寻找空闲槽最简单的方法, 就是按顺序遍历, 知道找到空槽为止. (实际上会进行更复杂一些的计算, python的字典)

开放地址法中:

1. 计算数据(key)的散列值
2. 找到相应的槽(如果散列值比槽的数量大则去余数)
3. 如果槽与数据一致, 则使用该槽, 查找结束
4. 如果槽为空闲, 则不存在该数据, 查找结束
5. 计算下一个槽的位置
6. 返回第3步进行循环

开放地址缺点: 会让散列冲突发生得更加频繁, 因为会将有冲突的数据存放到"下一个槽"中, 这也就意味着"下一个槽"无法用来存放原本和散列值直接对应的数据了.

删除数据, 不能直接删除槽, 要将该元素的槽设定为一种特殊的状态, 即"空闲"(允许存放新数据)但不中断对下一个槽的计算.

#### 布隆过滤器

`Bloom filter`布隆过滤器是一种可以判断某个数据是否存在的数据结构, 或者也可以说是判断集合中是否包含某个成员的数据结构.

* 判断时间与数据无关`O(1)`
* 空间效率非常好
* 无法删除元素
* 偶尔会出错

#### DHT 分布式散列表

`Distributed Hash Table`

## C10K

`C10K`, "即在同时连接到服务器的客户端数量超过`10000`个的环境中, 即便硬件性能足够, 依然无法正常提供服务"这样一个问题.

### keep-alive

从`HTTP1.1`开始, 对同一台服务器产生的多个请求, 都通过相同的套接字连接来完成, 这就是`keep-alive`技术.

### 内存共享

程序的空间可以通过操作系统的功能进行共享, 但变量空间和栈空间是无法共享的.

#### 抖动 `thrashing`

当大量的进程导致内存开销超过物理内从容量时, 每次进行进程切换都不得不产生磁盘访问, 这样一来, 消耗的时间太长导致操作系统整体陷入一种几乎停止响应的状态, 这样的情况呗称为抖动.

#### 文件描述符

文件描述符(file descriptor), 就是用来表示输入输出对象的整数, 例如打开的文件以及网络通信用的套接字等.

#### select
 
使用一个叫`select`的系统调用来监视它们是否处于可供读写的状态.

`select`系统调用将要监视的文件描述符存入一个`fd_set`结构体, 并设定一个超时时间, 对它们的状态进行监视. 当指定的文件描述符变为可读,可写,发生异常等状态, 或者经过指定的超时时间时, 该调用就返回. 之后, 通过检查`fd_set`, 就可以得知在指定的文件描述符之中, 发生了怎样的状态变化.

`select`系统调用通过`fd_set`结构体接收要监视的文件描述符, 为了标记出实际上发生状态变化的文件描述符, 会将响应的`fd_set`进行改写.**于是, 为了通过`fd_set`得知到底哪些文件描述符已经处于可用状态, 必须每次都将监视中的文件描述符全部检查一遍**.

解决方案:

* 使用`epoll`, `kqueue`.
* 使用非阻塞`I/O`.
* 使用`select`系统调用, 但是将一个进程所处理的连接数控制在`select`的上限以下.

#### 使用epoll功能

* `FreeBSD`使用`kqueue`
* `Solariszh`使用`/dev/poll`
* `Linux`使用`epoll`

`epoll`:

* `epoll_create`创建监视描述符, 用于代表要监视的文件描述符.
* `epoll_ctl`将监视描述符进行注册.
* `epoll_wait`进行实际的监视.

优点, 决绝无畏的复制和循环操作:

* 要监视的`fd`数量没有限制.
* 内核会记忆要监视的`fd`, 无需每次都进行初始化.
* 只返回产生事件的`fd`的信息, 因此无需遍历所有的`fd`.

## HashFold

