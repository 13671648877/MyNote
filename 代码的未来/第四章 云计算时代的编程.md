# 第四章 云计算时代的编程

## 可扩展性

### 大数据的查找

`O(n)`指的是计算量随参数`n`的变化情况.

`K,M,G`在表示硬盘容量等场合一般都采用十进制. 如果要表示`1024`倍递增的二进制方式, 另外有`Ki,Mi,Gi`等前缀.

#### 二分法查找

`O(log n)` 前提是, 数据之间存在大小关系, 且已经按照大小关系排序.

#### 散列表

散列表是表达一个对象到另一个对象的映射的数据结构. 从概念上来看, 它是一种采用非数值型索引的数组. 在`Python`表示为字典(`Dictionary`).

`O(1)`

##### 散列函数

用于将各个值计算成为一个称为散列值的整数. 需要满足以下性质:

* 从数据到整数值(0 ~ N-1)的映射
* 足够分散, 即便数据只有很小的差异, 散列函数的计算结果也需要有很大的差异.
* 不易冲突, 不易发生由不同的数据得到相同散列值的情况.

散列表: 以散列值为索引的数组.

##### 冲突

不同的数据拥有相同散列值的情况, 被称为"冲突".

应对冲突的方法:

* 链地址法(chaining), 将拥有相同散列值的元素存放在链表中, 随着元素个数的增加, 散列冲突和查询链表的时间也跟郑增加. 元素的删除可以用比较简单且高性能的方式来实现. (Ruby 的 Hash)
* 开放地址法(open addressing), 遇到冲突时, 再继续寻找下一个新的数据库存放空间(一般称为槽). 寻找空闲槽最简单的方法, 就是按顺序遍历, 知道找到空槽为止. (实际上会进行更复杂一些的计算, python的字典)

开放地址法中:

1. 计算数据(key)的散列值
2. 找到相应的槽(如果散列值比槽的数量大则去余数)
3. 如果槽与数据一致, 则使用该槽, 查找结束
4. 如果槽为空闲, 则不存在该数据, 查找结束
5. 计算下一个槽的位置
6. 返回第3步进行循环

开放地址缺点: 会让散列冲突发生得更加频繁, 因为会将有冲突的数据存放到"下一个槽"中, 这也就意味着"下一个槽"无法用来存放原本和散列值直接对应的数据了.

删除数据, 不能直接删除槽, 要将该元素的槽设定为一种特殊的状态, 即"空闲"(允许存放新数据)但不中断对下一个槽的计算.

#### 布隆过滤器

`Bloom filter`布隆过滤器是一种可以判断某个数据是否存在的数据结构, 或者也可以说是判断集合中是否包含某个成员的数据结构.

* 判断时间与数据无关`O(1)`
* 空间效率非常好
* 无法删除元素
* 偶尔会出错

#### DHT 分布式散列表

`Distributed Hash Table`

## C10K

`C10K`, "即在同时连接到服务器的客户端数量超过`10000`个的环境中, 即便硬件性能足够, 依然无法正常提供服务"这样一个问题.

### keep-alive

从`HTTP1.1`开始, 对同一台服务器产生的多个请求, 都通过相同的套接字连接来完成, 这就是`keep-alive`技术.

### 内存共享

程序的空间可以通过操作系统的功能进行共享, 但变量空间和栈空间是无法共享的.

#### 抖动 `thrashing`

当大量的进程导致内存开销超过物理内从容量时, 每次进行进程切换都不得不产生磁盘访问, 这样一来, 消耗的时间太长导致操作系统整体陷入一种几乎停止响应的状态, 这样的情况呗称为抖动.

#### 文件描述符

文件描述符(file descriptor), 就是用来表示输入输出对象的整数, 例如打开的文件以及网络通信用的套接字等.

#### select
 
使用一个叫`select`的系统调用来监视它们是否处于可供读写的状态.

`select`系统调用将要监视的文件描述符存入一个`fd_set`结构体, 并设定一个超时时间, 对它们的状态进行监视. 当指定的文件描述符变为可读,可写,发生异常等状态, 或者经过指定的超时时间时, 该调用就返回. 之后, 通过检查`fd_set`, 就可以得知在指定的文件描述符之中, 发生了怎样的状态变化.

`select`系统调用通过`fd_set`结构体接收要监视的文件描述符, 为了标记出实际上发生状态变化的文件描述符, 会将响应的`fd_set`进行改写.**于是, 为了通过`fd_set`得知到底哪些文件描述符已经处于可用状态, 必须每次都将监视中的文件描述符全部检查一遍**.

解决方案:

* 使用`epoll`, `kqueue`.
* 使用非阻塞`I/O`.
* 使用`select`系统调用, 但是将一个进程所处理的连接数控制在`select`的上限以下.

#### 使用epoll功能

* `FreeBSD`使用`kqueue`
* `Solariszh`使用`/dev/poll`
* `Linux`使用`epoll`

`epoll`:

* `epoll_create`创建监视描述符, 用于代表要监视的文件描述符.
* `epoll_ctl`将监视描述符进行注册.
* `epoll_wait`进行实际的监视.

优点, 决绝无畏的复制和循环操作:

* 要监视的`fd`数量没有限制.
* 内核会记忆要监视的`fd`, 无需每次都进行初始化.
* 只返回产生事件的`fd`的信息, 因此无需遍历所有的`fd`.

## HashFold

### 时间计算

* `user`: 程序本身所消耗的时间
* `system`: 由于系统调用在操作系统内核中所消耗的时间
* `total`: 从程序启动到结束锁消耗的时间. 由于系统中还运行着其他进程, 因此这个时间要大于`user`和`system`之和.

### 父子进程通信

`fork`是创建一个当前运行中的进程的**副本**. 因为是副本, 如果对对象进行了任何变更, 或者创建了新的对象, 都**无法**直接反映到父进程中.

#### pipe

`pipe`方法会创建两个分别用来读取和写入的`IO`(输入输出)

```ruby
r,w = IO.pipe
```

写入到`w`的数据可以从`r`中读取出来.

由于子进程是父进程的副本, 在父进程中创建`pipe`, 并在子进程中对`pipe`进行写入的话, 就可以从父进程中将数据读取出来. 作为好习惯, 应该将不适用的IO:

* 父进程用于写入(因为我们让父进程读子进程写入的数据)
* 子进程用于读取的

关闭掉, 避免对资源的浪费.

#### 进程池

线程和进程在创建的时候就伴随着一定的开销, 因此像这样先创建好再重复利用的技术称为池(`pooling`).

## 进程间通信

进程指的是正在运行的程序. 

多个线程可以在同一个进程中运行, 线程间可以相互合作. 所属于同一个进程的各线程, 其内存空间是共享的.

### 线程的优缺点

* 优点: 可以避免数据传输锁带来的开销. 而各进程之间, 内存是无法共享的, 因此进程间通信就需要对数据进行拷贝, 而在线程之间进行数据共享, 就不需要进行数据的传输.
* 缺点: 多个线程会访问相同的数据, 因此容易产生**冲突**.

### 同一台计算机上的进程间通信

* 管道(pipe)
* 消息(message)
* 信号量(semaphore)
* 共享内存
* TCP套接字
* UDP套接字
* UNIX域套接字

#### 管道

管道是通过`pipe`系统调用创建一对文件描述符来进行通信的方式.

### 套接字

* TCP套接字,主机地址+端口, 连接型套接字, 和通信对方进行连接并进行连续数据传输的套接字.
* UDP套接字,主机地址+端口, 无连接型套接字, 可以保存每次写入的数据长度.
* UNIX域套接字,路径
	* 客户端可以像文件一样来进行读写操作.
	* 进程间不具备父子关系也可以进行通信. 不过它也有缺点, 由于通信对象的指定是采用路径的形式, 因此只能用于同一台主机上的进程间通信.

使用套接字进行通信, 需要在事先设定好的连接目标出, 通过双方套接字的相互连接创建一个通道.

`UNIX`域套接字是使用和文件一样的路径来指定连接目标. 只能用于同一台计算机上的进程间通信. 一般来说, 在进程间传递文件描述符, 只能通过具有父子关系的进程间共享. 但使用`UNIX`域套接字就可以在非父子关系的进程间实现文件描述符的传递了.

`C`下的`socket`函数中的一些参数

协议类型:

* `PF_INET`: IPv4协议
* `PF_INET6`: IPv6协议
* `PF_APPLETALK`: `ApleTalk`协议
* `PF_IPX`: `IPX`协议

通信类型:

* `SOCK_STREAM`: 字节流套接字, 面向连接的, `TCP`.
* `SOCK_DGRAM`: 数据报套接字, 无连接的`socket`, `UDP`.

## Rack 与 Unicorn

### WSGI

Web Server Gateway Interface(Web 服务器网关接口).

