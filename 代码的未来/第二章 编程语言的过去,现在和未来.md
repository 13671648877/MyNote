# 第二章 编程语言的过去,现在和未来

---

## 编程语言的世界

* FORTRAN
* COBOL
* LISP
* SNOBOL

### 以数学为基础的编程语言

函数型编程语言.

`ML`,`Haskell`.

倾向于直接表达要表达的概念. 相对于`How`(如何实现), 更倾向于通过`What`(想要什么)来表单问题. 这样**可以不被机器的处理方式所左右,将问题抽象地表达出来**.

### 抽象化

从编程语言的进化过程来看, 一个显著的关键词就是**抽象化**.

抽象化就是提供一个抽象的概念, 使用者即便不具备关于内部详细情况的知识, 也能够对其进行运用. 由于不必了解其内部的情况, 因此也被称为**黑箱化**.

人类一次所能掌握的概念数量是有限的, 如果能够让问题的处理方式更加抽象, 也就可以解决更复杂的问题.

### 20年后的语言

20年后的语言, 应该是在分布处理(多台计算机协作处理)和并行处理(多个CPU协作处理)功能的强化.

## DSL(特定领域语言)

`DSL`是指利用特定领域(`Domain`)所专门设计的词汇和语法, 简化程序设计过程, 提高生产效率的技术, 同时也让非编程领域专家的人直接描述逻辑称为可能.

优点: 可以直接使用其对象领域中的概念, 集中描述"想要做到什么(What)"的部分, 而不必对"如何做到(How)"进行描述.

### 领域特定语言

* `awk`
* `Makefile`
* `sed`
* `yacc`语法分析器生成工具
* `lex`词法分析器生成工具

### 外部DSL

`Unix`文化中, 由若干单一目的的小工具所组成的"工具箱系统". 各种迷你语言, 作为组成工具箱的零部件.

* XML
* SQL
* 正则表达式, 用来描述字符串模板的一种外部DSL, 其语法在不同的语言中基本上是通用的.

独立于程序开发的语言. 对于某个领域进行操作的程序, 不一定是用同一种语言来编写的.

外部`DSL`实际上是全新设计的语言和语言引擎, 因此可以根据它的目的进行自由的设计, 不必被特定的执行模块和现有语言的语法所左右. 由于自由度很高, 在特定领域中能够大幅度提高生产效率.

### 内部DSL

**不是**创造一种新的语言, 而是在现有语言中实现`DSL`, 而作为`DSL`基础的这种现有语言, 称为宿主语言.

`Lisp`,`Smalltalk`,`Ruby`适合.

内部`DSL`是"借宿"在宿主语言中的, 它借用了宿主语言的语法, 因此程序员无需学习一种新的语言.

### DSL的优势

提供生产效率.

* 为特定领域所设计的词汇,
* 可以在高级层面上编写程序.

不涉及对象领域的内部细节, 而是在高级层面上进行描述, 这就是近半个世纪依赖编程语言进行的方向--"抽象化".


### 流畅接口

流畅接口运用了方法链(Method chain).

```
cusotmer.newOrder().with(6, "Tal")
				    .with(5, "HPK").skippable()
				    .with(3, "LBV")
				    .priorituRush()
				    
				    
如果不使用流畅接口

Order o1 = new Order();
customer.addOrder(o1);

OrderLine line1 = new OrderLine(6, Product.find("TAL"));
o1.addLine(line1);

OrderLine line2 = new OrderLine(5, Product.find("HPK")).
line2.setSkippable(true);
o1.addLine(line2);
...
```

简洁性和易读性使用流畅接口会较好, 但是现在还没有普及.

### 外部DSL 示例

`YAML`和`JSON`就是为了**将对象用对人类易读的形式描述出来**这一特定目的而设计的外部`DSL`.

### DSL 设计的构成要素

* 上下文(Context)
* 语句(Sentence)
* 单位(Unit)
* 词汇(Vocabulary)
* 层次结构(Hierarchy)

## 元编程

**元编程**, 就是用程序来编写程序.

程序本身的信息是可以被访问的, 因此在程序运行过程中也可以对程序本身进行操作, 这就是元编程.

元编程的灵活性:

比如`ActiveRecord`模式, 通过元编程技术对无法预先确定的操作进行了应对, 这样一来, 未来的可能性就不会被禁锢, 体现了语言的灵活性.

## 内存管理

### 垃圾

就是需要回收的对象. 如果程序(通过某个变量等等)可能会直接或间接地引用一个对象, 那么这个对象就被视为"存活". 与之相反, 已经引用不到的对象被视为"死亡". 将这些"死亡"对象找出来, 然后作为垃圾进行回收, 就是**GC的本质**

### 根

根(Root), 就是判断对象是否可被引用的起始点. 基本是将**变量**和**运行栈空间**作为根.

### 标记清除方式

`Mark and Sweep`标记清除. 

* 首先从根开始将可能被引用的对象用递归的方式进行标记
* 将没有标记到的对象作为垃圾进行回收

清除阶段: 将全部对象按顺序扫描一遍, 将没有被标记的对象进行回收. 在扫描的同时, 还需要将存活对象的标记清除掉, 以便为下一次`GC`操作做好准备.

作为标记清除的变形, 还有一种叫做标记压缩(Mark and Compact)的算法, 它不是将被标记的对象清除, 而是将它们不断压缩.

#### 缺点

在分配了大量对象, 并且其中只有一小部分存活的情况下, 所消耗的时间会大大超过必要的值, 这是因为在清除阶段还需要对大量死亡对象进行扫描.

### 复制收集方式

`Copy and Collection`

将从根开始被引用的对象复制到另外的空间中, 然后, 再将复制的对象所能够引用的对象用递归的方式不断复制下去. 最后将旧空间废弃掉, 这样就可以将死亡对象所占用的空间一口气全部释放出来, 而没有必要再次扫描每个对象. 下次`GC`的时候, 现在的新空间也就变成了将来的旧空间.

#### 局部性

在复制收集过程中, 会按照对象被引用的顺序将对象复制到新空间中. 于是, 关系较近的对象被放在距离较近的内存空间中的可能性会提高, 这被称为"局部性". 局部性高的情况下, 内存缓存会更容易有效运作, 程序的运行性能也能够得到提高.

### 引用计数方式

`Reference Count`

在每个对象保存该对象引用计数, 当引用发生增减时对计数进行更新.

引用计数的增减, 一般发生在:

* 变量赋值
* 对象内容鞥新
* 函数结束(局部变量不再被引用)

一个对象的引用计数变为0时, 则说明它将来不会再被引用, 因此可以释放相应的内存空间.

释放操作是针对每个对象个别执行的, 因此和其他算法相比, 由`GC`而产生的中断时间(`Pause time`)就比较短.

#### 缺点

* 无法释放循环引用的对象.
* 必须在应用发生增减时对引用计数做出正确的增减.
* 不适合并行处理. 如果多个线程同时对引用计数进行增减的话, 引用计数的值就可能会产生不一致的问题. 为了避免这种情况的发生, 对引用计数的操作必须采用独占的方式来进行. 如果引用操作频繁发生, 每次都是用加锁等并发控制机制的话, 开销较大.

为了避免循环引用的问题, 都配合使用了其他的`GC`机制.

### 分代回收

目的是为了在程序运行期间, 将`GC`所消耗的时间尽量缩短.

#### 核心思想

利用了一般性程序所具备的性质

* 大部分对象都会在短时间内成为垃圾
* 经过一定时间依赖存活的对象往往拥有较长的寿命

对象按照生成时间进行分代, 刚刚生成不久的年轻对象划为新生代, 而存活较长时间的对象划为老生代(可能会划分更多的代). 那么只要仅仅扫描新生代对象, 就可以回收掉废弃对象中的很大一部分.

这种只扫描新生代对象的回收操作, 被称为小回收(`Minor GC`). 大多数分代回收的实现都采用了复制收集算法. 在扫描的过程中, 如果遇到老生代的对象, 则不对该对象继续进行递归扫描. 这样一来, 需要扫描的对象数量就会大幅减少.

对对象的更新进行监视, 将从老生代对新生代的引用, 记录在一个叫做记录集(remembered set)的表中. 在执行小回收的过程中, 这个记录集也作为一个根来对待.

随着程序的运行, 老生代区域中的"死亡"对象也在不断增加. 为了避免这些死亡的老生代对象白白占用内存空间, 偶尔需要对包括老生代区域在内的全部区域进行一次扫描回收. 像这样以全部区域为对象的`GC`操作被称为完全回收(`Full GC`)或者大回收(`Major GC`).

#### 写屏障

`Write barrier`检查程序需要对所有涉及修改对象内容的地方进行保护.

#### 优缺点

* 通过减少`GC`中扫描的对象数量, 达到缩短`GC`带来的平均终端时间的效果.
* 由于还是需要进行大回收, 因此最大终端时间并没有得到什么改善.
* 吞吐量由于扫描对象数据量的减少, 可以提升.
* 性能会被分代数量, 大回收触发条件等因素大幅度左右.

### 增量回收

`Incremental GC`

缩短`GC`的最大中断时间. 在对实时性要求很高的程序中, 必须能够对`GC`所产生的终端时间做出预测.

为了**维持程序的实时性**, 不等到`GC`全部完成, 而是将`GC`操作细分成多个部分逐一执行. 这种方式被称为增量回收.

如果已经完成扫描了, 这时对标记的对象发生了修改, 对新的对象产生了引用. 这个新对象就不会被标记, 明明是"存活"对象却被回收掉了. 在增量回收中为了避免这样的问题, 和分代回收一样也采用了写屏障. 当已经被标记的对象的引用关系发生变化时, 通过写屏障会将新被引用的对象作为扫描的起始点记录下来.

#### 优缺点

由于增量回收的过程是分步渐进式的, 可以将终端时间控制在一定长度之内. 由于终端操作需要消耗一定的时间, **`GC`所消耗**总时间就会相应增加.

### 并行回收

并行回收正式荣国最大限度利用多CPU的处理能力来进行`GC`操作.

基本原理是, 在原有的程序运行的同时进行`GC`操作, 这一点和增量回收是相似的. 区别是:

* 增量回收: 在一个CPU上进行`GC`任务分割的增量回收.
* 并行回收: 利用多CPU的性能, 尽可能让这些`GC`任务并行(同时)进行.

由于软件运行运行和`GC`操作是同时进行的, 就会遇到和增量回收相同的问题. 并行回收也需要用写屏障来对当前的状态信息保持更新. **在`GC`操作的某些特定阶段, 还是需要暂停原有程序的运行**

### GC大统一理论

* 跟踪回收(Tracing GC), 从根开始进行扫描以判断对象生死的算法:
	* 标记清除
	* 复制收集
* 引用计数算法

**任何一种`GC`算法, 都是跟踪回收和引用计数回收两种思路的组合. 两者的关系正如"物质"和"反物质"一样, 是相互对立的. 对其中一方进行改善的技术之中, 必然存在对另一方进行改善的技术, 而其结果只是两者的组合而已.**

## 异常处理

### 使用特殊返回值表示错误

```c
#inlucde <stdio.h>

int main() 
{
  FILE *f = fopen("/path/to/file", "r");
  
  if (f == NULL) {
  	puts("file open failed");
  } else {
    puts("file open succedded");
  }
}
```

#### 使用特殊返回值的缺点

* 对错误的检测不是强制进行的, 可能会出现没有注意到发生了错误而继续运行程序的情况. 例如上述列子, 如果没有注意到文件打开失败, 依然去访问`FILE`结构体的话, 整个程序就会出错崩溃.
* 原本的程序容易被错误处理埋没.

### Ruby 中的异常处理

其实问题点有两个:

* 没有检查错误就继续运行
* 错误处理将原本的程序埋没

在比较新的语言中, 采用了称为异常(`exception`)的机制, 以减轻错误处理的负担.

一旦发生意外情况, 程序就会产生异常, 并同时中断程序运行, 回溯到当前过程的调用者. 经过逐级回溯, 到达程序顶层之后, 输出错误信息, 并停止程序的运行. 如果明确声明了"在这里捕获异常"的话, 异常就会被捕获, 并进行错误处理.

也就是意味着: 当意外状况发生时, 通过自动中断程序运行的方式, 避免了每进行一步操作都要显示地检查错误, 从而避免了程序中充满错误检查代码的问题.

### 异常与错误值

如果情况完全是超出预计, 错误就应该作为异常来处理. 反之, 如果错误在某种程度上是预计范围内的, 那么就应该返回错误值.

### 小结

异常处理功能就是为了将程序员进行错误处理的负担尽量减轻而产生的一种机制.

## 闭包

### 函数对象

**函数对象**就是**作为对象来使用的函数**. (对象不一定是面向对象中的那个对象, 而更像是编程语言所操作的数据这个意思, 如C语言的函数指针, 我们可以通过函数指针间接调用该函数, 这就是C语言概念中的对象).


```c
#inlcude <stdio.h>
int two(int x) {return x*2}
int three(int x) {return x*3}

int main(int argc, char **argv)
{
	int (*times)(int);
	int n = 2;
	
	if (argc == 1) times = two;
	else times = three;
	printf("times(%d) = %d\n", n, times(n));
}
```

对指针型变量`times`的声明, 它的意思是: 变量`times`, 是指向一个拥有一个`int`型参数, 并返回`int`值的**函数的指针**.
```c
int (*times)(int)
```

当传递给程序的命令行参数为零个时. 将函数`two`(的指针)赋值给变量`times`; 当存在一个以上的参数时, 则将函数`three`的指针赋值给`times`.

### 高阶函数

函数对象, 也就是将函数作为值来利用的方法, 最大用途就是高阶函数.

**高阶函数**就是用函数作为参数的函数.

以排序函数作为示例:

```c
void sort(int *a, size_t);
```

该函数接手一个大小为`size`的整数数组`a`, 并对齐内容进行排序. 缺点:

* 只能对整数数组进行排序
* 排序条件无法从外部进行制定

#### 用函数参数提高通用性

```c
void qsort(void * base,size_t nmemb,size_t size ,int(*compar)(const void *,const void *));
```

`void*`表示"空类型指针", 与`void`不同, `void*`表示"任意类型的指针"或表示"该指针与一地址值相关,但是不清楚在此地址上的对象的类型".

* `base`类型是`void *`. 表示接收任何类型的数组.
* `nmemb`表示元素数量.
* `size`表示每个元素的大小.
* `compar`是指向一个带两个参数的函数的指针. 每个函数接收数组中两个元素的指针, 并以证书的形式返回比较结果. 当两个元素相等时, 返回`0`, 当`a`比`b`大时返回正整数, 当`a`比`b`小时返回负整数.

高阶函数这样的方式, 通过将一部分处理以函数对象的形式转移到外部, 从而实现了算法的通用化.

#### 函数指针的局限

### 作用域: 变量可见范围

#### 作用域

变量的**有效范围**, 某个变量可以被访问的范围.

### 生存周期: 变量的存在范围

生存周期就是变量的寿命. 一个变量可以在多长的周期范围内存在并被能够被访问.

从属于外部作用域的局部变量, 被函数对象给"封闭"在里面了. **闭包**这个词就是封闭起来变量的寿命, 与封闭它的函数对象寿命相等.

当封闭这个变量的函数对象不再被访问, 被垃圾回收期回收掉时, 这个变量的寿命也就同时终结了.

### 闭包与面向对象

刚才的闭包把函数(过程)与数据结合起来了, **过程与数据的结合**是形容面向对象中的"对象"时经常使用的表达式.

#### 区别

对象: 是在数据中以方法的形式内含了过程. 可以拥有多个过程.

闭包: 是在过程中以环境的形式内含了数据. 闭包则只能拥有一个, 但是可以内部通过传递参数加分支来实现.

对象和闭包是同一事物的正反两面.
 