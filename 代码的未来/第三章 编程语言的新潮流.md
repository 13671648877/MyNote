# 第三章 编程语言的新潮流

---

## 语言的设计

* 静态: 不实际运行程序, 仅通过程序代码的字面来确定结果的意思.
* 动态: 就是只有当运行时才确定结果.

### java的高性能

**一次编写, 到处运行**

并不是将程序直接转换为系统平台所对应的机器语言, 而是转换为虚拟CPU的机器语言字节码(`Bytecode`), 并通过搭载虚拟`CPU`的模拟器`JVM`来运行.

`JVM`是运行时用来解释字节码的解释器.

`JIT`(Just In Time)编译技术, 在运行时将字节码转换成机器语言, 经过转换之后就可以获得和原生编译一样快的运行速度. 在运行时进行编译, 就意味着编译时间也会包含在运行时间里面. 因此`JIT`编译器会通过侦测运行信息, 仅将需要频繁运行的瓶颈部分进行编译, 从而大大削减编译所需的时间.

#### 内联扩展

利用**运行时编译**, 可以不用考虑连接的问题而积极运用内联扩展.

内连扩展, 是指让编译器直接将完整的函数体插入到每一个调用该函数的地方, 从而提高函数调用的运行速度.

#### java的GC

采用并行回收, 分代回收.

并行回收: 将`GC`放在单独的线程中运行, 从而对程序本身的处理(基本上)不造成影响.

分代回收: 在扫描过程中忽略程序运行中一致存活的长寿对象, 从而减少扫描工作量.

### javascript

在`JavaScript`中与服务器进行异步通信的`API`叫做`XMLHttpRequest`. 也叫做`Ajax`(Asynchronous JavaScript and XML, 异步JavaScript与XML).

#### 性能提升

`JavaScript`是一种动态语言, 不带有变量和表达式的**类型**信息, 针对类型进行优化是非常困难的, 和静态语言相比有着先天的劣势.

##### 特殊化

```javascript

function fact(n) {
 if (n == 1) return 1;
 return n * fact(n-1);
}
```

当解释器对`fact`函数进行`JIT`编译时, 会生成两个版本的函数:

* `n`为任意对象的通用版本.
* `n`为整数的高速版本.

当参数`n`为整数时(即大多数情况下), 就会运行高速版的函数, 便实现了与静态语言几乎相同的运行性能.

**动态语言运行速度慢的理由之一, 就是因为在运行时需要伴随大量的类型检查, 而通过特殊化则可以回避这一不利因素**.

### CGI

是通过`Web`服务器的标准输入输出与程序进行交互, 从而生成动态`HTML`页面的接口.

只要可以对标准输入输出进行操作, 那么无论任何语言都可以编写`CGI`程序.

在`WWW`中, 来自`Web`服务器的请求信息是以**文本**的方式传递的, 反过来, 返回给`Web`服务器的响应信息也是以文本`(HTML)`方式传递的. **因此擅长文本处理的编程语言就具有得天独后的优势**


### Goroutine

轻量版的线程. 通过语言层面支持, 很好地支持了系统编程层面中对并发编程的有效利用.

### 多态

`Polymorphism`根据存放在变量中的对象的实际性质, 自动选择一种合适的处理方式(方法). 即**面向对象编程的本质**.

### 动态运行模式

动态运行模式(元编程), 运行中的程序能够识别自身, 并对自身进行操作. 对程序自身进行操作的编程. 也被称为反射(Relflection).

### 何谓类型

类型指的是对某个数据所具有的性质进行的描述.

### 静态类型的优点

程序中对类型的描述, 可以帮助对程序的阅读和理解.

### Structural Subtyping

以类型的结构来确定可代换性的类型关系, 被称为结构子类型.

像`Java`这样根据声明拥有继承关系的类型具有可代换性的类型关系, 被称为名义子类型.

## GO

### 带垃圾回收的

* 如果忘记对不需要的对象进行释放, 程序所占用的内存容量就会不断增大, 从而导致内存泄露(`Memory leak`)bug.
* 如果释放了仍然在使用中的对象, 就会导致内存空间损坏悬空指针(`Dangling pointer`)bug.

**特点**, 出问题的地方和实际引发问题的地方往往距离很远, 因此很难被发现和修复.

## Dart

## CoffeeScript

**JavaScript**是将函数作为对象来对待的.

## Lua

### 元表

在`Lua`中表和用户自定义数据类型中有元表这样一种设定, 这个设定通过`setmetatable()`函数来执行. 对于表和用户自定义数据类型来说, 在需要执行某项操作时, 就会产生与该操作相对应的事件.

针对各个事件锁进行的处理时根据事件类型而决定的, 但对于设定了元表的表和用户自定义类型来说,`Lua`会参照元表来进行处理.

`__index`, 当元表的`key`不存在时就会利用`__index`来进行搜索.