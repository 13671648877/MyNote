# 作用域的演变

---

作用域是指名字的**有效范围**.

## 动态作用域

### 如何操作

```
sub shori{
	$old_i = $i;
	$i = 0; # 各种处理
	$i = $old_i;
```

1. 开头把变量i带入变量old_i中.
2. 函数结束时再把变量old_i中的值返回给变量i.

这是一种先把原来的值另存起来随后返回的方法.

计算机实现的原理:

```
sub shori{
  local $i;
  $i = 0;
}
```

这样的作用域称为**动态作用域**

### 问题

动态作用域中改写的值会影响到被调用的函数.

```
$x = "global";

sub yobu{
	local $x = "yobu";
	&yobareru();
}

sub yobareru{
	print "$x\n"; $会输出yobu
}

&yobu
```

## 静态作用域

### 动态作用域对照表

代码:

```
$x = "global"

函数 yobu
	local $x = "yobu"
	
函数 yobareru
	print "$x"
```

对照表:

* 全局对照表
	* `x: "global"` 
* 动态作用域对照表
	* `x: "yobu"`(yobu函数的)

所以执行到函数`yobareru`中参照变量`x`时, 未推出函数`yobu`, 该张对照表还有效. 于是程序首先读取这张新的对照表, 返回其中记录的内容`yobu`. 如果需要访问该张对照表中没有记录的变量时, 就要翻转到下一张对照表, 也就是全局对照表进行查找.

**参照变量时按照由近及远的顺序读取**.

### 静态作用域按函数区分对照表

**多个函数公用一张对照表, 这是动态作用域的问题点**.

静态作用域针对上面的函数会有3张对照表:

* 全局对照表
	* `x: "global"` 
* 局部对照表
	* `x: "yobu"`(yobu局部对照表)
	* yobareru 局部对照表

所以当执行到函数`yobareru`中参照变量`x`时, 要访问的**不是**函数`yobu`专用的对照表, 而是函数`yobareru`专用的对照表. 这张对照表中因为没有写入函数`yobu`改写的变量值, 所以全局变量的值会被读取出来.

## 小结

面向对象中的`private`,`protocted`,`public`等, 在**限制可访问范围的作用上和作用域是非常相似的**.

作用域是**编写易于理解的代码的有力工具**.