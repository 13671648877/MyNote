# 32_01_mysql系列之一关系型数据库基础理论

---

## 笔记

---

### 概述

* MYSQL 基础知识
* SQL 语句使用
* MYSQL 事务, 隔离, 并发控制, 锁
* 用户和权限
* 监控
	* STATUS
* 索引类型, 索引结构, 索引和查询的关系
	* VARIABLES
* 备份和恢复
* 复制功能
* 集群

### DBS 和 RDBS

最早是靠**文件**来管理数据, 缺陷:

* 无法解决数据冗余问题, 同样的数据出现很多次
* 数据不一致问题, 同一个数据存了多份, 每次修改都要修改保存在不同文件的同一份数据
* 数据访问困难, 文件包含大量数据, 从文件中查找一条记录, 需要把文件加载到内存才能查询
* 数据是孤立的, 数据是分散在不同文件当中
* 完整性问题, 操作了一半突然停电了.
* 原子性问题, 要么都操作完成, 要么都操作不完成. 数据从一个稳定的状态转换到另外一个稳定状态.
* 并发访问异常问题. 多个人同时访问一个文件的数据.(一个人在修改数据的时候, 必须锁住一个文件, 锁的粒度太大)
* 安全性问题. 用户的权限. 

DBMS 数据库管理系统

* 层次模型
* 网状模型
* 关系模型
	* 列: 一个属性
	* 行: 一个记录(实体)
	* 表: 同一类实体记录的集合

RDBMS 关系型数据库管理系统

#### 文件

* 表示层
	* 表示为一个文件(一页纸保存了很多数据)
* 逻辑层: 用户看到的表示层和最终存储在物理层建立对应关系, 完成之间的映射.
	* 文件系统: 将底层的数据块抽象为文件. 存储时, 靠文件系统将文件解构为物理层数据. 可以将文件系统理解为存储引擎(从二进制代码还原成各式各样的数据).
* 物理层
	* 元数据
	* 数据: 存储在数据块中

在磁盘和最终用户角度来看文件, 展示形式不一样.

#### 关系

关系: 关系代数运算

* 交集: 两个集合共有的部分
* 并集: 属于A 或者 属于B 的
* 差集: 属于A 但不属于B. 属于B 但不属于 A
* 补集: 全集减去集合的内容
* ...

#### 关系模型

关系模型: (结构化数据模型, 每一行表示数据格式相同)

* 关系模型
* 实体-关系模型: 拆分表存储(数据 和 数据状态 两张表存储)
* 对象关系模型: 基于对象的数据模型
* 半结构化数据模型: (EAV设计, 即保存数据, 还存储了数据本身的意义)

#### SQL

`Structure Query Language`结构化查询语言.

诞生于`IMB`的`System R`. 世界上第一款关系型数据库. `SQL`是基于`System R`的接口. 后面`Ingres, Oracle, Sybase`都基于`SQL`接口实现,

ANSI; SQL 标准. ansi-sql

`SQL`就是一些列的命令, 有如下几类:

* `DML`: 数据操作语言
	* INSERT
	* DELETE
	* SELECT
	* UPDATE
* `DDL`: 数据定义语言(操作`RDB`的对象), 实现数据的存储和定义(定义完以后就决定了怎么存储)
	* CREATE
	* DROP
	* ALTER
* `DCL`: 数据控制语言. 定义数据库中用户的**访问权限**.
	* GRANT
	* REVOKE

`RDB`的对象(可以使用`CREATE`定义的)

* 库
* 表
* 索引
* 视图
* 用户
* 存储过程
* 存储函数 
* 触发器
* 事件调度器(Mysql中定义的, 定时执行计划任务)
* ...

约束(`constraint`): 明确定义存储范围, 有效数据范围.

* 域约束: 数据类型约束(整型,日期时间型).
* 外键约束: 引用完整性约束.
* 主键约束: 某一个字段或者某些字段组合起来能够唯一的标识表中的每一个实体. 不能为空.
	* 一张表只能有一个主键.
* 唯一性约束: 每一个行的某字段都不允许出现相同值, 可以为空.
	* 一张表可以有多个唯一键.
* 检查性约束: 自定义的约束.

#### 数据库的逻辑关系

* 表示层: 库,表(最重要),索引,视图... 
* 逻辑层: 存储引擎.
* 物理层: 数据文件(是**文件**的表示层), 数据文件要抽象为表.

数据文件还包含元数据, 需要使用存储引擎负责解释(结构)还原为表.

#### 数据存储和查询

* 存储管理器
* 查询管理器, 接收用户的请求, 将用户的查询转换成存储管理器理解的语句.

##### 存储管理器

1. 权限及完整性(约束)管理器.
2. 事务管理器: 保证用户的操作具有原子性.
3. 文件管理器: 最终`表`要存储为文件. 需要保存`表`和文件的对应关系. 管理这些文件的创建, 删除, 扩展.
4. 缓冲区管理器: 数据查询修改都要在内存. 需要从磁盘里把数据读到内存当中. 当空间不够时还需要交换数据.

##### 查询管理器

接收用户的查询请求, 理解用户的查询请求, 并提交给**存储管理器**

* DML解释器, 理解DML语句表示的意思.
* DDL解释器
* DCL解释器
* 查询执行引擎(重要): 上面的解释器解释的结果教给查询执行引擎, 需要管理(操作,查询)数据.

#### 怎么和`MySQL`交互

进程间通信.

`CS`架构. 靠协议通信.

`tcp/ip`把请求送到服务端. 需要应用层协议, `mysql`协议.

为了数据库安全, 避免权限交叉, 一个线程响应一个请求. `MySQL`为每一个用户请求生成一个线程.

`MySQL`: ==单进程多线程==的系统:

* 守护线程, 定期将数据从内存写到磁盘.
* 应用线程, 用户请求进来生成, 退出没有.
	* 10个用户
		* 第一个用户查询请求256MB
		* 第二个用户查询请求1G
		* 第三个用户查询请求256MB 

所以数据库不如web服务器并发那么高. 所以要尽可能少链接数据库.

线程重用(thread reuse): 一个用户退出后, 把线程放到空闲线程池里, 后面的用户可以重用.

每个进程使用的地址空间有限的. 

* 32位系统使用4G(1G内核), 大概可以使用2.7G内存.
* 64位系统
	* SMP: 对称多处理器.

`MySQL`对`SMP`支持很差. `MySQL`一个单独的语句只能在一个处理器上查询.

#### 总结: 关系型数据库系统的体系结构

从上到下的关系.

* 应用程序, SQL用户, 程序员, DBA
* 查询处理器, 接收用户的请求
	* DML 解释器
	* DDL 解释器 
	* 查询执行引擎
* 存储管理器
	* 权限及完整性(约束)管理器 
	* 事务管理器
	* 文件管理器
	* 缓冲区管理器
* 磁盘 (真正实现数据存储的位置)

#### 关系运算

为了实现`MySQL`语句的执行.

* `投影`: 只输出指定字段(属性)显示.
* `选择`: 值输出符合条件的行.
* `自然连接`: 两张表上各自出一个字段, 值相等, 就连接输出.

		user表								shell表
		user_id user_name shell_id			shell_id shell_name
			
		user.shell_id = shell.shell_id
			
* `笛卡尔积`: 用一张表中的每一行和另外一张表中的每一行分别连接.

		(a+b)*(c+d) = ac+ad+bc+bd
		
* `并`: 两张表`UNION`. 集合运算. 
	     

## 整理知识点

---