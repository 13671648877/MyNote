#14_01_Linux系统启动流程详解之一 运行级别及grub

###笔记

---

**Linux系统启动流程**

1. 系统自举(`POST`将BIOS映射到物理地址空间,`ROM`映射到`RAM`),CPU读取到`ROM`的指令信息,完成硬件健康状态检查.
2. `BIOS`(Boot Sequence),启动次序决定去哪找操作系统的`MBR`(哪个外部IO设备找操作系统).
3. `MBR`(bootloader,446个字节,`MBR只是存储空间`),现在的硬盘(硬盘不大于2T)一般不支持`MBR`机制.`bootloader`根据`MBR`的分区表查找活动分区.找到操作系统所在的分区,并加载那个分区操作系统的内核.如果第一个设备(根据Boot Sequence)没有`MBR`,则继续查找第二块设备.如果第二个设备有`MBR`,损坏了.也`不会`继续查找后面的设备. 如果`bootloader`获得控制权,则`BIOS`会退出.
4. `内核`(`Kernel`),内核装载进内存在内存中完成解压缩,控制权转交给内核.内核取得整个系统的控制权.`bootloader`退出.内核初始值初始化内核的`核心`没有外部`ko`.
5. 内核通过`initrd`(红帽5,下文有介绍)访问`/sbin/init`.`initrd`由`bootloader`装载,由`kernel`使用.
6. 内核尝试探测每一个硬件,加载基本硬件完成后(驱动装载),主要目的是空内核空间管理用户空间.启动`init`进程.`init`是用户空间的主导程序.所有用户空间的进程都有`init`管理.除非需要和硬件打交道,才会切换到内核空间.

		[root@dev-server-2 chloroplast]# which init
		/usr/sbin/init
		
		我的阿里云上显示是/usr/目录下
		
		[chloroplast@dev-server-2 ~]$ ll  /
		...
		lrwxrwxrwx    1 root root     8 1月   9 15:20 sbin -> usr/sbin
		...
		
		/sbin -> /usr/sbin/


6. 根所在的分区叫做根文件系统(`rootfs`).这个是整个操作系统的访问入口.访问任何文件都要从`根`进入.内核装载根文件系统后,才能找见`/sbin/init`.

		/a/b
		b一定在a目录里面(a的分区里面),但是b目录当中的文件不一定在a所在的分区上,可以在其他分区
		
		/user
		usr目录在根的分区里面,但是usr目录里面的文件不一定在根的分区内.

**内核的设计结构**

内核设计风格:

1. `单内核`(所有功能做进内核,内核靠一个进程完成所有功能),工作逻辑简单.`Linux`,线程称为轻量级进程(`LWP`).
	* 模块化风格: 核心和各种外部ko组成.`ko`(kernel object)内核对象,内核独用模块.核心动态加载外围内核模块`ko`.
	
2. `微内核`(外围功能,做成子系统.需要需要哪个子系统,内核负责调用并装载入内).`Windows,Solaries`.支持真正意义上的多线程.

**单内核的模块化设计**

内核模块目录: `/lib/modules/"内核版本号命名的目录"/`,系统可以多个内核并存的.

		[chloroplast@dev-server-2 net]$ pwd
		/lib/modules/3.10.0-327.4.4.el7.x86_64/kernel/drivers/net
		
		[chloroplast@dev-server-2 net]$ ls
		bonding   ethernet  ieee802154  macvlan.ko  mdio.ko  netconsole.ko  ntb_netdev.ko  ppp   team    usb      virtio_net.ko  vxlan.ko  wireless
		dummy.ko  hyperv    ifb.ko      macvtap.ko  mii.ko   nlmon.ko       phy            slip  tun.ko  veth.ko  vmxnet3        wan       xen-netfront.ko

这样设计的`好处`是,保持内核自身很小.

`模块文件夹大小`:

		[chloroplast@dev-server-2 net]$ du -sh /lib/modules/3.10.0-327.4.4.el7.x86_64/
		117M	/lib/modules/3.10.0-327.4.4.el7.x86_64/

`内核核心文件夹大小`:

		[chloroplast@dev-server-2 net]$ du -sh /boot/vmlinuz-3.10.0-327.4.4.el7.x86_64
		5.0M	/boot/vmlinuz-3.10.0-327.4.4.el7.x86_64

**chroot:根切换 示例**

提示没有`bash`

		[root@dev-server-2 chloroplast]# chroot /home/chloroplast/virroot/
		chroot: failed to run command ‘/bin/bash’: No such file or directory
		
复制`/bin/bash`后再次运行,还是提示没有找见`/bin/bash`
		
		[root@dev-server-2 chloroplast]# mkdir /home/chloroplast/virroot/bin
		[root@dev-server-2 chloroplast]# cp /bin/bash /home/chloroplast/virroot/bin/
		[root@dev-server-2 chloroplast]# chroot /home/chloroplast/virroot/
		chroot: failed to run command ‘/bin/bash’: No such file or directory		

因为我们缺少`/bin/bash`的依赖文件,通过`ldd`命令查找依赖

		[root@dev-server-2 chloroplast]# ldd /bin/bash
		linux-vdso.so.1 =>  (0x00007ffd84543000)
		libtinfo.so.5 => /lib64/libtinfo.so.5 (0x00007f7ad74a9000)
		libdl.so.2 => /lib64/libdl.so.2 (0x00007f7ad72a5000)
		libc.so.6 => /lib64/libc.so.6 (0x00007f7ad6ee3000)
		/lib64/ld-linux-x86-64.so.2 (0x00007f7ad76dd000)


复制依赖文件

		[root@dev-server-2 chloroplast]# mkdir /home/chloroplast/virroot/lib64
		[root@dev-server-2 chloroplast]# cp /lib64/libtinfo.so.5 /home/chloroplast/virroot/lib64/
		[root@dev-server-2 chloroplast]# cp /lib64/libdl.so.2 /home/chloroplast/virroot/lib64/
		[root@dev-server-2 chloroplast]# cp /lib64/libc.so.6 /home/chloroplast/virroot/lib64/
		[root@dev-server-2 chloroplast]# cp /lib64/ld-linux-x86-64.so.2 /home/chloroplast/virroot/lib64/
		
再次运行`chroot`,运行成功
		
		[root@dev-server-2 chloroplast]# chroot /home/chloroplast/virroot/
		bash-4.2# cd /bin/
		bash-4.2# pwd
		/bin
		bash-4.2#
				
也可以使用 `chroot 路径 /bin/bash`

**ldd**

显示二进制文件所依赖的共享库

`ldd /PATH/TO/BINARY_FILE`				
				
**ram disk**

把内存模拟成磁盘来用.

红帽5 叫 `ram disk` -> `initrd`  
红帽6 叫 `ramfs` -> `initramfs`

**运行级别**

不同级别启动不同的服务

`0-6`,一共`7`个级别.

* `0`: halt(关机) 
* `1`: single user mode(单用户模式,直接以管理员身份切入)
* `2`: multi user mode(多用户模式,不启用`NFS`)
* `3`: multi user mode,`text mode`(正常级别,`text mode`文本模式,只有命令行)
* `4`: reserved (保留级别,未定义)
* `5`: mulit user mode`graphic mode` 
* `6`: reboot(重启)

运行级别由`/sbin/init`控制.配置文件在`/etc/inittab`

**`bootloader`**

`bootloader`(`MBR`)

* `LILO`: LInux LOader,不支持大硬盘
* `GRUB`: GRand Unified Bootloader,2阶段程序
	* `Stage1`: 装在`MBR`中(446个字节),用于引导`Stage2`,突破`446字节`限制.
	* `Stage1_5`: 用于识别常见的不同类别的文件系统
	* `Stage2`: `/boot/grub/`,配置文件`/boot/grub/grub.conf`

Centos 6.5 在这个位置, 7 不在.

`示例(来源6.5)`:

		cat /etc/grub.conf
		
		# grub.conf generated by anaconda
		#
		# Note that you do not have to rerun grub after making changes to this file
		# NOTICE:  You do not have a /boot partition.  This means that
		#          all kernel and initrd paths are relative to /, eg.
		#          root (hd0,0)
		#          kernel /boot/vmlinuz-version ro root=/dev/xvda1
		#          initrd /boot/initrd-[generic-]version.img
		#boot=/dev/xvda
		default=0 
		timeout=5
		splashimage=(hd0,0)/boot/grub/splash.xpm.gz
		hiddenmenu
		title CentOS (3.10.5-3.el6.x86_64)
			root (hd0,0)
			kernel /boot/vmlinuz-3.10.5-3.el6.x86_64 ro root=UUID=94e4e384-0ace-437f-bc96-057dd64f42ee rd_NO_LUKS rd_NO_LVM LANG=en_US.UTF-8 rd_NO_MD SYSFONT=latarcyrheb-sun16 crashkernel=auto  KEYBOARDTYPE=pc KEYTABLE=us rd_NO_DM rhgb quiet
			initrd /boot/initramfs-3.10.5-3.el6.x86_64.img
		title CentOS (2.6.32-431.23.3.el6.x86_64)
			root (hd0,0)
			kernel /boot/vmlinuz-2.6.32-431.23.3.el6.x86_64 ro root=UUID=94e4e384-0ace-437f-bc96-057dd64f42ee rd_NO_LUKS rd_NO_LVM LANG=en_US.UTF-8 rd_NO_MD SYSFONT=latarcyrheb-sun16 crashkernel=auto  KEYBOARDTYPE=pc KEYTABLE=us rd_NO_DM rhgb quiet
			initrd /boot/initramfs-2.6.32-431.23.3.el6.x86_64.img
			
* `default=0`: 设定默认启动的title编号,从0开始
* `timeout=5`: 等待用户选的超时时长,单位是秒
* `splashimage=(hd0,0)/boot/grub/splash.xpm.gz`: grub的背景图片
* `hiddenmenu`: 隐藏菜单,去掉该项不隐藏
* `title CentOS (3.10.5-3.el6.x86_64)`: 内核标题,或操作系统标题,纯字符串可自由修改
* `root (hd0,0)`: 内核文件所在的设备,对`grub`所有硬盘类型一率为`hd`,`hd#,N`,`#`表示第几个磁盘(hd0:第一块硬盘),最后的`N`(用逗号隔开)表示对应磁盘的`分区`(0:第一个主分区)
* `kernel /boot/vmlinuz-3.10.5-3.el6.x86_64 ro root=UU...`:内核文件的路径,以及传递给内核的参数.
* `initrd /boot/initramfs-3.10.5-3.el6.x86_64.img`: ramdisk文件路径

###整理知识点

---

####initrd(红帽5)和initramfs(红帽6)的作用

Linux内核在初始化之后会执行init进程,而init进程会挂载我们的根文件系统,但由于init程序也是在根文件系统上的,所以这就有了悖论.`Linux采用两步走的方法来解决这个问题`.

**initrd(INITial Ram Disk)**

Linux初始`RAM`磁盘(initrd)是在系统引导过程中挂载的一个临时根文件系统,用来支持两阶段的引导过程.

Linux2.6版以前的方法是: 除了内核vmlinuz之外还有一个独立的initrd.img映像文件,其实它就是一个文件系统映像,linnux内核在初始化后会`mount initrd.img`作为一个临时的根文件系统,而`init进程就是在initrd.img里`的,然后init进程会挂载真正的根文件系统,然后`umount initrd.img`.

**initramfs**

Linux2.6采用的是`initramfs`(和`initrd`作用是一样的).initramfs: init ram filesystem,它是一个`cpio`格式的内存文件系统.

**总结**

这两个知识点都是Linux文件系统启动过程包含的,需要更多的知识积累在来理解.








