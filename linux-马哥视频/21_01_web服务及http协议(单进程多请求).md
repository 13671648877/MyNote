# 21_01_Web服务及http协议

---

### 笔记

---

#### HTTP

`H`yper`T`ext `T`ransfer `P`rotocol: 超文本传输协议.

纯文本: 纯`ASCII`码组成的.

超文本: 带有超级链接的文本.

超链接: 能够在文档之间实现跳转的.

`HTML`: 编写超文版的语言.`H`yper`T`ext `M`ark `L`anguage,超文本标记语言.

##### URI

统一资源标示符. 全局范围内,唯一引用独立资源的命名方式.包括但不仅限于物联网.`统一`指的是`路径格式`上的统一.

**URL**

是`URI`的子对象. `U`niform `R`resource `L`ocator.统一资源定位符.互联网资源的统一标示.

`protocol`(协议)://`HOST`:`PORT`/`path`(路径)/to/file

		http://www.magedu.com/download/linux.tar.gz 唯一标示在互联网上的一个唯一资源.
		
**web资源**

通过统一资源定位符(URL),并且可以客户端访问的.

		http://www.magedu.com/logo.gif
		
每一个可以单独访问的文件都是一个资源.多个资源可能被整合为一个html文档.

html文档将分散在多台web服务器的资源整合成一个页面,并且让浏览器显示的标记语言.

**web对象**

**HTTP方法**

资源获取的方法.

**MIME**

`M`ultipurpose `I`nternet `M`ail `E`xtension, 多用途互联网邮件扩展.

SMTP: `S`imple `M`ail `T`ransmission `P`rotocol,简单邮件传输协议.只能传输纯文本.

SMTP 协议引入 `MIME`, `MIME`: 将非文本数据在传输前重新编码为文本格式在传输.接收方能够用相反的方式将其重新还原为原来的格式,还能够调用响应的程序来打开此文件.

在HTTP中,MIME类型被定义在`Content-Type` header中.

##### 动态网页

服务器端存储的网页非HTML格式,而是编程语言开发的脚本.根据用户特性,将不同参数传递给脚本.脚本接收参数后在服务器运行一次(PHP解释器,如果C语言,先编译好在执行一次),运行完成后会生成`HTML`格式的文档,把生成的文档发给客户端.

动态网页是根据客户端的请求生成的.

执行脚本和web服务器无关,web服务器需要调用额外的功能来执行脚本.

web: index.php

客户端申请访问这个脚本,服务器端根据扩展名(php),判断出这个不是html文档.web服务器不会立即响应客户端访问,而且通过某种`协议`,去调用一个额外运行的程序(php解释器),让php解释器运行`index.php`把生成的html文档返回给web服务器.

		web --> ptotocol --> php (运行index.php)

web服务器只是一个http服务器,不负责处理动态内容.

web服务器是一个运行的进程,在用户空间.用户能访问的网页文件在磁盘上.当客户端发起请求的时候,请求先到达`内核空间`(因为请求是通过网络协议进来的,网络协议是运行在内核空间的,`tcp/ip`协议在内核).内核空间`tcp/ip`解码后发现是访问本机`80`端口的`套接字`.内核将这个用户请求`通过套接字`转给用户空间的web服务器(执行流程从`内核空间`到了`用户空间`).

这里假设访问的是`index.html`,这个时候服务器端进入`内核空间`到磁盘中将这个文件加载进来,在返回到`用户空间`.web服务器找见文件可以相应给客户端了,在`返回到内核空间`,通过网络`TCP/IP`协议栈在返回给客户端.

这里假设访问的`index.php`,通过其他协议启动另外进程(解释器),通过这个协议将这个文档传递到解释器.这个`解释器`自己在到`内核空间`(内核模式)将这个文件读取到内核中,执行一遍,将这行结果返回给web服务器.这里需要额外的进程(解释器).每次解释都需要启动一个进程(解释器),用完以后在销毁.


一个网页可以通过超链接引用n个资源,每一个资源都有一个url.所以一个动态网页应该包含:

* 静态内容(不需要改变的,图片,压缩包等等.不需要运行)
* 动态内容(需要运行)

##### 一个客户端发起一个请求到web服务器过程 

一个客户端发起一个请求到web服务器,过程:

假设访问`www.magedu.com`

1. 请求发送出去之前,先去dns服务器解析FQDN.DNS内部可能需要递归.
2. 浏览器访问到主机,发送数据包到服务器.
3. 服务器接收到请求之后,服务器(进程)怎么知道有请求来响应.多种机制都可能有(阻塞,非阻塞).这种机制叫做`监听`到某个端口等待客户端请求.
4. 请求到了以后内核`TCP/IP`协议栈(解码首部)发现有进程监听端口.将请求交给这个套接字.如果没有进程监听端口,则内核直接返回错误.服务器端需要内核注册使用某个端口.
5. TCP/IP 协议在封装报文时,IP首部里面存放`源地址,IP`,`目标地址,IP`.TCP首部封装一层端口`源端口,port`,`目标端口,port`.服务器端拆分报文,最多只能知道
	* 来源哪个主机
	* 目标哪个主机
	* 来源哪个程序(端口号)
	* 目标哪个程序(端口号)
    
	但是不知道访问具体哪个页面,URL会指定文件路径.这个路径在`TCP/IP`协议首部中不包含.`TCP/IP`协议只是帮助把报文传递到目的地,至于要获取什么样的资源还要对应具体协议的报文首部(HTTP协议).
6. HTTP首部
	* GET /2.html 具体获取某个服务器的某个路径的某个文件.
	* Host: www.magedu.com 对应哪个主机的资源,主机名称,为虚拟主机提供功能.

#### HTTP报文

* 请求报文
* 响应报文

**请求报文语法**

		<method> <request-url> <version>  //起始行
		<headers>	//报文首部
					//空白行
		<entity-body> 报文主体 //如果post 有报文主体,如果get(获取) 没有

**响应报文语法**
		
		<version> <status> <reason-phase>
		<headers>
		
		<entity-body>

* `status` 有五类
	* `1xx` : 纯粹的信息,和请求资源没有太多关系
	* `2xx` : 成功类的状态吗,资源存在
	* `3xx` : 重定向类的信息,资源存在,资源已经被挪到其他地方
	* `4xx` : 客户端类错误信息
	* `5xx` : 服务器端错误类信息

**示例**
		
		访问 / 根,默认页面
		
		请求报文:
		GET / HTTP/1.1
		Host: www.magedu.com
		Connection: keep-alive
		
		响应报文：
		HTTP/1.1 200 ok
		X-Powered-By: PHP/5.2.17  
		//额外标记的变化类内容
		Vary: Accept-Encoding,Cookie,User-Agent
		//缓存控制机制
		Cache-Control: max-age=3, must-revalidate
		//内容编码机制
		Content-Encoding: gzip
		//内容有多长		
		Content-Length: 6931

##### 访问机制

* 阻塞,一直等在那.
* 轮询(非阻塞),每隔一段时间过来看一次.

#### Web服务器的主要操作

1. `建立连接` 接收或拒绝客户端连接请求
2. `接收请求` 通过网络读取HTTP请求报文
3. `处理请求` 解析请求报文并做出相应的动作
4. `访问资源` 访问请求报文中相关的资源
5. `构建响应` 使用正确的首部生成HTTP响应报文
6. `发送响应` 想客户端发送生成的响应报文
7. `记录日志` 当已经完成的HTTP事物记录进日志文件

#### 缓存

每个资源都是单独请求,单独传输.

为了让加载快速,一般浏览器都是多线程的.

http, 是基于 tcp 的. 三次握手, 四次断开(挥手)

http 1.1:

* 增强了缓存功能(控制能力)
* 引入了长链接的机制

**长连接**

服务端不是立即断开,`同一个`客户端发起第二个请求缩短时间.服务器端为了资源有效利用,一般会给两种限定:

* 空闲超时
* 最多请求多少次(一直请求不断开)

####WEB服务器处理模型

是一个 `c/s` 架构模型.

* `C`: Client Agent:客户端代理 (browser:浏览器, spider:蜘蛛)
* `S`: Server

* Client -> request -> Server 
* Server -> response -> Client

##### 单进程/单线程服务器模型

最简单的.

一个一个进来,处理一个的时候其他等待,处理完一个(返回响应报文)在等待下一个.

##### 多进程/多线程模型

又一个服务器进程在工作,但是这个服务器进程不直接响应客户端,只接收客户端请求.生成一个子进程,交给子进程处理.其他请求进来在生成一个子进程.

多个用户连进来,可以同时响应.但是比如假如5000个请求进来,一个请求20MB内存就无能为力了.

早起很有用,比如第一个用户访问的进程崩溃了,不会影响其他人.比较稳定.

`并发响应能力太差`.

##### 单进程多请求

一堆请求过来,服务器在自己内部一个进程接收请求并响应.但是假如有5个请求过来,服务器在处理.如果要知道哪个处理完,必须要轮询过来查询看哪个处理完了.

轮询扫描效率太低.需要挨个问.但是如果每一个请求都有一个状态,只要状态改变.就认为有事情需要处理,`基于事件驱动机制`.但是仍然需要扫描一遍,只是不需要挨个问了.所以有了`通知机制`.

`事件驱动`+`通知机制`,`一个进程处理多个请求`,每个请求有自己的状态.进程根据状态转换来确认哪个请求需要处理.请求可以主动`发出通知`自己已经完成.

**事件通知机制**

* `水平触发`,只通知一次,不在通知.
* `边缘触发`,滚动通知,只要没处理.

**优点**

* 占用资源少
* 并发处理能力强

**缺点**

请求过多,多个进程来回切换也要耗费时间

##### 第二种和第三种整合起来

有一个总理进程`master`进程.不负责响应工作管理处理工作的请求,只负责接收请求并交给处理请求的进程(每个进程可以处理多个请求).

当工作完成,把空闲的销毁.

#### Server模型,HTTPD MPM(多道处理模块)

* httpd, MPM
	* prefork
	* work
	* event

### 整理知识点

---

#### 分析长链接示例

		sudo tcpdump -n host 121.199.48.143 and port 8005
		
#### Apache

`Apache`是一个软件基金会,对应的服务器是`httpd`常被叫做`apache`.