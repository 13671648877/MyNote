#18_01_加密类型及其相关算法

---

###笔记

---

####TCP/IP 安全

**机密性**

明文传输(ftp, http, smtp, telnet).不安全,别人抓包可以看见内容.机密性无从得到保证.

**完整性**

为了防止数据在互联网传输时被篡改,要保证数据完整性.

**身份验证**

保障身份的正确性.

**机密**

* [对称加密](#symmetric-key-encryption)
* [单向加密](#one-way-encrption)
* [非对称(公钥)加密](#not-symmetric-key-encryption)

**数据加密**

数据加密不是一位一位的加密,而是加密前先把数据拆分成大小相同的数据块,在进行加密.

####机密性

数据加密.数据解密.

机密本身就是一种转换规则.
	
		加密:
		abc(明文,plain text) --> 转换规则 --> xxxx (秘文,chiphertext)
		
		解密:
		xxxx (秘文,chiphertext) --> 转换规则 --> abc(明文,plain text)
		
**转换算法**

保证数据的机密性的核心不是`算法`本身,而是`秘钥`.

转换算法本事是复杂的数学原理实现的.

我们的安全性本身应该依赖于`秘钥`.		
		
#####[对称加密](id:symmetric-key-encryption)

加密和解密使用的是同一个秘钥.

好处: 算法计算速度非常快.
缺点: 安全性完全依赖于秘钥,因为很多算法是公开的.

当通信对象很多的情况下,没法解决有效的秘钥管理.		

**算法**:

* `DES`: `D`ata `E`ncrption `S`tandard, 56bit
	* 后来随着计算机性能提升,可以暴力破解了,就很少使用了
* `3DES`: 3次`DES`
* `AES`: 高级加密标准,使用 128bit 秘钥
	* `AES192`,`AES256`,`AES512`(数字指的是秘钥长度,秘钥越长安全度越高,但是速度越慢)
* `Blowfish`	
								
####完整性

数据完整性,

#####[单向加密算法](id:one-way-encrption)

* 单向加密特征: 输入一样,输出必然一样.
* 雪崩效应: 输入的微小改变,将会引起结果的巨大改变.
* 定长输出: 无论原始数据多大,结果size都是相同的.
* 不可逆的(通过指纹无法还原出来一个人): 无法根据特征码还原原来的数据.

提取数据特征码.

提取出这段数据的特征码(指纹),附加到这段数据后面传递.

验证: 获取到数据后,使用同样的算法计算出特征码(指纹),进行比对.

		A: plaintext:footprint --> B

`算法`:

* `MD4`
* `MD5`: 使用 128 位定长输出
* `SHA1`: 使用 106 位定长输出
* `SHA`
	* `SHA192`, `SHA256` , `SHA384` (数字指的是`输出`长度,因为单向加密是定长输入)
* `CRC-32`: 不是加密算法,是一种校验功能
	* 假设使用单向加密,2个输入不一样,输出一样, CRC-32允许出现

**中间人攻击**

中间人获取到明文后,修改明文重新计算特征码发送出去.
		
**协商生成秘钥**

密钥交换(Internet Key Exchange, IKE).

双方如何协商生成秘钥,但是不让第三方得到这段秘钥.

**Diffile-Hellman 协议,秘钥交换协议**		
		
		A -> B
		
`A`选择3个数字:

		p(质数,大素数), g(生成数,为了生成其他数字)
		p 和 g 在互联网传输了,其他所有人都能看见.
		
		A: 在本机内部选择一个随机数x
		
`B`:

		B: 在本机内部选择一个随机数y
		x 和 y 不在互联网传输的.	
		
`计算`:
		
		A: g^x%p(g的x次方对p取模) -> B (发送给B)	
		B: g^y%p(g的y次方对p取模) -> A (发送给A)			
		互联网只能看见4个数字:
		g, p, g^x%p, g^y%p
		根据离散对数很难推算.
		
`结果`:

		A得到: (g^y%p)^x = g^xy%p, A知道自己的x
		B得到: (g^x%p)^y = g^xy%p, B知道自己的y
		现在双方结果是一样的,互联网传输4个数字,A和B可以计算得到相同的结果.这个数字就是秘钥.
		
###[公钥加密算法: 非对称加密算法](id:not-symmetric-key-encryption)

因为上述算法`Diffile-Hellman`又一个问题,比如现在来一个`C`发送消息给`B`说我时`A`. `B`接收到消息以后无法准确判断消息的来源.所以有了`非对称加密算法`.

**2种核心功能: 加密和签名**

* 身份认证(数字签名)
* 数据加密
* 秘钥交换(是数据加密的一部分)

**算法**

* RSA: 加密,签名
* DSA: 签名
* ElGamal(商业算法): 

####密钥对:

* 公钥: p
* 私钥: s		
		
公钥是根据某种机制从私钥当中提取出来的,所以他们是成对出现的.

用公钥加对的,只能用与之配对的私钥解密,反之亦然.

发送方用自己的私钥加密传输数据,可以保证身份验证(因为只能用发送方的公钥解密数据).

发送方用对方的公钥加密数据,可以保证数据的机密性(`A`和`C`都用`B`的公钥加密数据,但是`B`无法知道数据的有效来源).	
		
解决了`对称加密`中的秘钥管理问题(每多一个数据交流的节点,都必须保存一份秘钥对.反之现在只需要保存自己的私钥和公钥即可).		
		
**公钥算法很少用来加密数据**,因为秘钥太长了,太慢了.通常用公钥来进行身份验证.		
**2种算法结合**

保证数据的身份验证和完整性.使用了非对称秘钥的方式.非对称主要用于身份验证.

		A -> 发送数据+A的私钥加密(特征码) -> B
		
		C 获取到数据后,可以看见数据,但是特征码是加密的.加入C篡改了数据,但是C要用A的公钥可以解密特征码,但是他没有A的私钥,不能在加密特征码了.于是C只能用自己的私钥加密特征码.C把数据发送给了B.
		
		B 接收到数据后(从C),用A的公钥解密,解密不了改数据(特征码).这样C就不能冒名顶替A了.
		
		B 接收到数据后(从A),用A的公钥解密数据,可以正常解密.B用同样的数据计算特征码,比较特征码.如果特征码正常,则是为A发送的数据.
		
**怎么获取公钥**

A 自己生成公钥和私钥后(`s/p`). 然后公钥提供给第三方(自己也有证),做公证(用户名+服务器地址+公钥+数字签名).

这样`B`从第三方获取`A`的公钥就能保证是获取到确实是`A`的公钥.否则`C`发给`B`,说我是`A`,`B`没有办法判断.
	
`数字签名`:	
		
第三方计算`A`(用户名+服务器地址+公钥)的特征码,然后用第三方用自己的私钥加密 = 数字签名.		
`怎么验证证书合法`:

拿到发证机构的公钥,能够解密数据.就认为这个证书是该机构发放的.在计算这段数据的完整性,如果数据也对的上就认为数据
		
**怎么获得发证机关的证书**

要保证来源是可靠的.	

###PKI

Public Key Infrastructure

CA 证书颁发架构和彼此之间的信任关系	
		
###整理知识点

---

###CRC32

CRC的全称是循环冗余校验.
