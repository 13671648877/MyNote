# 34_01_MySQL系列之九——MySQL事务和隔离级别

---

## 笔记

---

### `DML`

要先查询到, 才能完成后续操作:

* `INSERT INTO` 和查询有关系, 先查询是否符合我们指定的约束条件.
* `DELETE` 和查询有关系, 先查找到才能删除.
* `UPDATE` 和查询有关系, 要先找见才能更新.

广义的查询:

* `INSERT INTO`
* `SELECT`
* `DELETE`
* `UPDATE`

#### `INSERT INTO`

* 字符型: 单引号
* 数值型: 不需要引号
* 日期时间型: 不需要引号
* 空值: NULL (''这个是有值, 是字符串空串)

#### `REPLACE INTO`

如果重复就替换.

#### `DELETE`

`DELETE FROM tb_name WHERE condition;`

#### `TRUNCATE`

`TRUNCATE tb_name`清空表,并重置计数器.

请空表.

#### `UPDATE`

`UPDATE tb_name SET col1=..., col2=... WHERE`

`rdbms`隐藏实现的细节.

### `MySQL`管理

#### 链接管理器

1. 接受请求(监听在某个套接字上)
2. 创建线程, 使用线程池(服务器负责缓存线程), 线程重用
3. 认证用户
4. 负责建立安全链接(ssl)

#### 缓存器

每个查询结束之后, 如果结果是决定性的, mysql需要将查询结果缓存起来.

缓存空间是有限的, 简单描述内存空间分成若干区域, 每个区域内部有一个缓存槽, 每个查询结果都要占据一个槽. 每个槽都有最小下限, 假设槽的下限为512字节, 如果查询结果为4个字节, 占据槽会浪费其他空间(512-4). 如果是自动缩放空间, 则会产生内存碎片(感觉原理和memcached的slab类似). 所以为了发挥缓存有时, 不是所有结果都可以缓存.

如果每次语句都需要事先查询一次缓存, 需要计算出来一个最佳平衡点要让益处大于开销.

### 并发控制

任何时候只要有两个用户试图同时读写同一个文件(数据), 都会引起并发控制问题.

并发控制用于提升性能, 一个进程的操作不会影响另外一个进程的操作.

`MVCC`多版本并发控制. 每一个用户在操作数据的时候, 都不是操作原数据, 是操作数据的快照(数据时间版本), 最后快照合并.

实现并发控制的基础工具"锁".

#### 锁

最简单的并发控制是使用"锁". `MVCC`不是使用"锁".

* 读锁, 共享锁. 允许其他同时读, 不允许写.
* 写锁, 独占锁, 排他性. 即不允许写, 也不允许读.

锁粒度, MySQL服务器仅支持表锁, 行锁需要由存储引擎完成:

* 表锁: 锁定整张表.
* 页锁: 锁定数据块(数据页面), mysql最终存储到数据文件, 数据文件划分为多个`data block`(数据块), 一个块可以存储多个行. 锁定一个页, 锁定多个行.
* 行锁: 锁定一行, 粒度最小, 最精细.

锁的粒度越粗糙, 越容易管理. 粒度越精细, 越能够实现多个操作的并发性, 内部实现机制越复杂.

`UPDTE`语句会自动加锁.

也可以手动加锁. `LOCK TABLES`锁表. `LOCK TABLES tbl_name {READ|WRITE};`, `UNLOCK TABLES;`.

##### 锁的示例

加读锁:

* session2 可以读
* session2 写入会卡主, 等待别人释放锁

```shell
session1:
mysql> lock tables pcore_user read;
Query OK, 0 rows affected (0.01 sec)

session2:
mysql> select * from pcore_user;
Empty set (0.00 sec)
插入卡主, 等待别人释放锁
mysql> insert into pcore_user values (1,1222,1222,111,111,111,1,111,111,111,111);


session1释放锁后, session2才能插入成功, 可见最终插入了1分半.
session1:
mysql> unlock tables;
Query OK, 0 rows affected (0.00 sec)

session2:
mysql> insert into pcore_user values (1,1222,1222,111,111,111,1,111,111,111,111);
Query OK, 1 row affected (1 min 32.24 sec)
```

### 事务

服务器或存储引擎满足`ACID`测试.

`ACID`:

* A: 原子性. 事务所引起的数据库操作, 要么同时完成, 要么同时不完成.
* C: 一致性. 事务在完成之前和完成之后一致. 事务必须始终保持系统处于一致的状态. 一致性是指在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。这是说数据库事务不能破坏关系数据的完整性以及业务逻辑上的一致性.
* I: 隔离性. 两个事务在同时操作, 第一个事务的中间过程不能影响另外一个事务的执行. 彼此之间不干扰.
* D: 持久性. 一个事务成功完成了, 无论任何情况, 都要保证数据已经持久了(加入服务器宕机了, 要保证数据在下一次恢复后可用).

`InnoDB`支持事务.

事务日志来完成回滚操作.

* 重做日志(`redo log`), 每一个操作在真正写到数据库之前先写到日志, 就算崩溃可以根据重做日志再次执行一次.
* 撤销日志(`undo log`), 每一次操作在操作之前要把原有状态保留下来, 可以撤销此前任何一次操作, 还原到原来的状态.

`MySQL`在事务引擎为了完成`MySQL`事务, 它的每一次操作都是首先在日志文件中完成. 增删查改现在内存中完成, 完成后写到事务日志中, 然后在写到数据文件中去(拿重做日志在走一遍).

在事务引擎每一个写操作都要执行两遍, 日志中一次, 数据文件中一次. 写在日志中非常快, 因为日志中只是记录操作, 而不是数据本身. 而这个操作可以拿来在数据上重新执行一次, 所以叫`redo`.

事务提交了 = 完成了, 但是还不一定同步到磁盘上. 

日志文件通常不需要太大, 日志文件不能只有一个, 两个日志文件, 轮流使用. 被称为**日志组**.

#### 隔离级别

* `READ UNCOMMITED`读未提交
* `READ COMMITED`读已提交. 只有提交了才能看见. 会产生幻读.
* `REPEAT READ`可重读.
* `SERIALIZABLE`串行.

`SHOW GLOBAL VARIABLES LIKE '%iso%';`

## 整理知识点

---

### `''(空串)`和`NULL`

**空串**和**`NULL`**的区别, 空串是有值得. 