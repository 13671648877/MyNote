# 35_01_MySQL系列之十三——MySQL日志管理

---

## 笔记

---

* 错误日志, 错误和警告信息.
* 一般查询日志, 任何查询语句产生的信息, 一般不开启.
* 慢查询日志, 超出`LONG_QUERY_TIME`时间的查询.
* 二进制日志, 复制和即时点恢复.
	* 二进制日志事件
		* 基于语句: `statement`
		* 基于行: `row`
		* 混合方式: `mixed`
	* 最好不要和数据放在同一个存储位置. 每一次数据写操作都会引起二进制日志的写操作. 放在同一个磁盘上, 两个`IO`会产生竞争. 为了避免由于数据文件设备损坏.
	* `SHOW BINARY LOGS;`查看所有二进制日志.
	* `SHOW MASTER STATUS;`查看当前使用的二进制日志
	* `SHOW BINLOG EVENTS IN '二进制日志文件' FROM 'position';`查看日志中的事件.
	* `PURGE BINARY LOG '日志文件';`这个日志文件之前的日志文件都删除.
	* `FLUSH LOGS;`二进制日志滚动.
* 中继日志, 从主服务器的二进制日志文件中复制而来的事件, 并保存为的日志文件.
* 事务日志, 事务性存储引擎用于保证`ACID`.

`Mysql`服务器是用户空间进程, 它所使用的内存空间是用户进程的地址空间. 执行写操作不能直接写, 必须通过系统调用请求内核来完成写操作. 向内核发起请求. 用户写的数据在用户内存空间有一份, 向内核请求后, 内核内存空间也有一份. 内核在后台每隔一段时间真正写入磁盘.

### 二进制日志

数据库崩溃后, 用于还原数据.

* `binlog_format`: 二进制日志格式
	* `statement`
	* `row`
	* `mixed`
* `binlog_cache_size=#`: 二进制日志缓存带下. 缓存,`async`,写操作在内存完成,凑够后在写到磁盘上. 如果使用缓存,需要考虑数据安全性,最多只丢失有限的数据.
* `binlog_stmt_cache_size=#`: 二进制语句缓存大小. `binlog_cache_size`上限取决于`binlog_stmt_cache_size`大小.只调整`binlog_stmt_cache_size`大小即可. 值越大性能会提示,但是潜在数据量丢失的越大.
* `log_bin`: 是否启用二进制日志以及记录在哪个文件中,默认是`mysql-bin-000xx`. 还可以接受一个文件路径, 把二进制日志记录在另外的文件.
* `sql_log_bin={ON|OFF}`: 用于控制二进制日志信息是否记录进日志文件.动态变量, 可以手动关闭.在实现数据库恢复时,恢复的过程打中临时把二进制日志关掉.
* `sql_log_off={ON|OFF}`: 是否禁止将一般查询日志类信息记录进查询日志文件.
* `sync_binlog=#`设定多久同步一次二进制日志至磁盘文件中, `0`表示不同步, 任何正数值都表示对二进制没多少次写操作之后同步一次. 当`autocommit`的值为`1`时, 每条语句的执行都会引起二进制日志同步, 否则, 每个事物的提交都会引起二进制日志同步.
* `max_binlog_cache_size`: 缓存最大上限.
* `max_binlog_stmt_cache_size`: 缓存最大上限.
* `expire_log_days=#`: 日志过期天数. 每当过了`#`天后, 已经超过`#`天的日志会自动被删除. 自动清理二进制日志. 默认为`0`, 不清理.

就算并行执行, 但是最终写日志还是会写到同一个文件. 所以日志文件应该放到`ssd`硬盘上. 然后定期转移出去.

从服务器比主服务器慢.

### 事务日志

保证事务可靠性.

* `innodb_flush_log_at_trx_commit=1`: 内存中(缓存)的数据同步到事务日志文件中.
	* `0`: 每1秒钟同步一次. 并执行磁盘`flush`操作(告诉内核不要缓存, 直接写入磁盘).
	* `1`: 每事务同步, 并执行磁盘`flush`操作.
	* `2`: 每事务同步, 但不执行磁盘`flush`操作, 由操作系统自己决定什么时候`flush`.

`2`性能好, 因为前两种每次都要执行`IO`.但是`2`不安全.

* `innodb_log_buffer_size`: 内存缓存大小.
* `innodb_log_file_size`: 事务日志文件大小. 不管事务日志文件有没有使用, 实现都划好**连续的**硬盘空间. 默认`5MB`
	* 太小: 频繁`IO`同步到磁盘.
	* 太大: 每次失败后恢复时间长.

先在内存中写, 在同步到事务日志中, `mysql`后台服务线程自动从事务日志同步到数据文件中去.

* `innodb_log_group_home_dir`: 事务日志存储位置. 默认存在数据文件.

记录:

* TID 事务ID
* 老数据
* 新数据

每一次写操作都记录一个这样的值, 原数据文件没有做修改.

`DROP TABLE`事务不能`roll back`. 只能回滚表中数据的操作.

服务器崩溃后, 恢复:

* 在事务日志中, 已经提交的同步到数据库文件中.
* 在事务日志中, 没有提交的则撤销.

表空间中**会存在执行了一半的事务**,因为当事务日志文件满了以后, 就需要同步到数据文件中. 如果需要`rollback`,就是用旧值替换新值.

### 事务日志组

`innodb_log_files_in_group`

有两个事务日志, 写满一个在写入另外一个. 老的同步完以后在清空. 新老来回交替.

```shell
root@90af5cf2869e:/var/lib/mysql# ls -l
total 176136
-rw-rw----  1 mysql mysql       56 May 20 13:03 auto.cnf
-rw-r--r--  1 mysql mysql      385 May 20 13:00 docker-compose.yml
drwx------  3 root  root       102 Aug 11 08:00 hellodb
-rw-rw----  1 mysql mysql 50331648 Aug 20 10:13 ib_logfile0
-rw-rw----  1 mysql mysql 50331648 Aug 20 10:13 ib_logfile1
```

`ib_logfile0`和`ib_logfile1`.

`innodb_mirrored_log_groups`: 是否对事务日志组做镜像.

### 存储引擎

#### `MyISAM`

* 不支持事务.
* 操作粗糙.
* 默认只支持表锁. 锁粒度大, 并发能力不强.
* 读操作多性能好.
* B树索引, 全文索引, 空间索引(R树索引)
* 支持表压缩.
* 存储
	* `.frm`表结构
	* `.MYD`数据文件
	* `.MYI`索引文件

#### `InnoDB`

* 支持事务
* 行级锁, 锁粒度小, 并行写入.
* B树索引, 聚簇索引, 自适应hash索引
* 表空间
* raw磁盘设备(没有文件系统的磁盘分区, 可以自我管理)
* 存储
	* `.frm`表结构
	* `.ibd`表空间

#### `MRG_MyISAM`

能够将两个或两个以上的`MyISAM`表合成一个表使用.

#### `CSV`

存成文本文件.

#### `ARCHIVE`

归档, 以后不做修改, 用于数据挖掘.

#### `MEMORY`

内存存储引擎. 表中的数据都放到内存.

`MySQL`使用`MEMORY`引擎创建临时表.

## 整理知识点

---

### `sync`和`async`

`async`先在内存写,过一会在一并同步到磁盘上,性能好.数据可能会丢失.

* 可以定时写入磁盘.
* 可以凑够一组操作写入磁盘.

`synce`每一次写操作,不在内存停留,会同步写到磁盘上.因为磁盘`io`性能低.

### `FIO`

`Fusion-IO`把`SSD`硬盘接入到北桥芯片, 速度只是比内存慢一个量级.

### `IOPS`

`IO PER SECOND`. `IO`设备每秒钟执行的`IO`的操作数.

`SSD`: 能到`500`-`1000`.

