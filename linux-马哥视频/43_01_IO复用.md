# 43\_01_IO复用

---

## 笔记

### DMA

加载数据完成后产生一个中断, 告诉`CPU`已经加载完成.

### 模型

* 单进程: 阻塞.
* 多进程: 每个进程响应一个请求.
	* 进程量: 进程切换次数(上下文切换)消耗资源多.
	* 每个进程的地址空间是独立, 很多空间是重复的数据, 所以内存使用效率较低.
* 线程: thread, 轻量级进程(Light Weight Process, LWP), 是进程内部运行的子单位.
	* `linux`把所有线程都当成进程来对待.
	* 每个线程响应一个请求.
		* 线程切换(线程也是独立执行实体), 切换量级比较轻. 很多缓存数据在同一个进程, 不需要重新加载.
		* 同一个进程的线程可以额共享进程的诸多资源, 比如打开的文件, 传输的信号.
		* 对内存占用需求较之进程略有下降(可以共享).
	* 等待
		* 忙等: 自旋锁(spin lock), 一直占据CPU
		* 闲等: 退出CPU
	* 线程快速切换时会带来线程抖动
* 多进程多线程模型
* 多线程: N请求
	* 一个线程响应多个请求, 一个线程处理多个`IO`
		* 本地磁盘`IO`使用异步`IO`, 不能因为`IO`没完成阻塞我们的线程.
		* 网络上多用户`IO`的唤醒(激活, 让用户取数据). 使用多路`IO`复用机制
			* `select`, 一个线程接待多个用户请求, 每个用户请求反应在本机上就是一堆文件描述符(套接字)

#### selec模型

最多支持1024个.

### 多路IO, IO复用

多路IO的解决机制: 解决了多个用户同时过来请求, 又都能让每个用户知道自己的请求是否准备就绪的机制.



### 进程

进程地址空间具有**代码段(指令)**区域, 数据在**数据区**(全局变量,常量以及静态变量,已经初始化在`.data`段, 没有初始化在`.bss`段), **堆空间**(态分配的内存段), **栈空间**(局部变量).

在代码段, 指令一条一条的执行, 需要用到数据的时候到数据区, 堆栈区去取数据.

## 整理知识点

* Linux支持多少种类型的线程库? 如何切换线程库?

