# 34_02_MySQL系列之十——MySQL事务和隔离级别

---

## 笔记

---

### 事务

经由`ACID`测试.

事务: 多项操作作为一个处理单元. 要么同时都完成, 要么同时都不完成.

```sql
START TRANSACTION: 启动一个事务
	SQL
COMMIT: 提交
ROLLBACK: 回滚,撤销
```

事务同时执行: 最好彼此之间互不影响的方式进行.

* 事务之间交互:
	* 通过数据集(第一个事务修改数据, 第二个事务看见数据)

#### 隔离性

靠数据库内部事务调度实现. 事务调度: 事务之间影响降至最低.

#### 持久性

如何保证持久性.

* 事务**提交之前**就已经写出数据至持久性存储, 效率低, 假如事务不执行了, 还需要从持久性存储撤销(不采用该方法).
* 结合事务日志完成, 没有直接写到数据文件, 先写到事务日志. ==将随机IO转为换顺序IO== 
	* 顺序IO, 每个操作按顺序写到磁盘连续的存储块中(顺序IO速度快). 数据文件并非如此(分布在不同的存储块, 随机IO速度慢).
	* 数据文件: 随机IO.后续后台进程在讲事务日志同步到数据文件中.

#### 事务状态

* 活动的: active, 事务正在执行当中.
* 部分提交的: 有一部分已经写入, 还有部分正在执行. 一般指最后一条语句执行后, 最后一条语句正处于写的过程当中.
* 失败的, 事务正常提交, 提交未能完成.
* 终止的, 没提交.
* 提交的, 提交了, 且成功完成.

事务一旦提交, 无法撤销.

```shell
活动状态 -> 部分提交 -> 提交成功 -> 提交状态
				   -> 提交失败 -> 失败 -> 终止
		-> 失败 -> 终止
```

为了尽可提高系统资源利用率, 事务是**并发执行**的.

1. 提高吞吐量和资源利用率.
2. 减少等待时间(如果都串行, 等待时间过长).

#### 事务调度

为了保证事务的隔离性和原子性, 通过事务调度来完成.

事务调度策略:

1. 可恢复调度. 两个事务在彼此之间调度的时候, 任何两个事务的交叉执行都不会导致另外一个事务的状态改变.
2. 无级联调度. 

#### 隔离级别

* `READ UNCOMMITTED`
* `READ COMMITTED`
* `REPEATABLE READ` mysql默认.
* `SERIALIZABLE`

#### 并发控制依赖的技术手段

* 锁
* 时间戳
* 多版本和快照隔离

锁饥饿: 事务一致等待锁, 等不到.

死锁: 提前检查, 让一个事务可以回退, 释放锁.

#### 服务器变量`autocommit`

```sql
select @@autocommit;
```

自动提交.

如果没有明确使用`start transaction`(启动事务),`autocommit`可以实现自动提交. 每一个操作都直接提交.

`IO`操作越少越好, `Mysql`为了保障事务的安全性和持久性, 每一次提交都会产生一次`IO`操作.没有明确使用`start transaction`的话, 每次操作都会产生一次`IO`操作.

建议明确使用事务, 并且关闭自动提交.

```sql
set autocmmit=0
```

#### 保存点

一个很大的事务: 100个操作

加入执行到第80个的时候发现第75个错了, 撤销的话80个全都撤了.

每10个语句保存一次, 可以记录保存的位置, 可以只撤退都保存点.

设定 `SAVEPOINT identifier`.

回滚到保存点`ROLLBACK TO identifier`. 回到保存点之前的状态.

```sql
START TRANSACTION;

DELETE xxx 删除一行

SAVEPOINT ab;

DELETE xxx 在删除一行

SAVEPOINT ac;

DELETE xxx 在删除一行

SAVEPOINT ad;

ROLLBACK TO ac; 回退到ac保存点
```

### 事务隔离级别对事务的影响



## 整理知识点

---