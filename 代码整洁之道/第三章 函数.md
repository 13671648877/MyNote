# 第三章 函数

---

### 短小

函数应该短小, `20`行封顶最佳.

每个函数都只说一件事,每个函数都==依序==把你带到==下一个==函数.

### 只做一件事

* 函数应该做一件事.
* 做好这件事.
* 只做这一件事.

这三个步骤均在该函数名下的==同一抽象层上==.

如果函数只是做了该函数名下==同一抽象层上的步骤==,则函数还是只做了一件事.编写函数毕竟是为了==把大一些的概念(函数的名称)拆分为另一抽象层上的一系列步骤.

**判断函数是否不止做了一件事**

看是否能再拆出一个函数,该函数不仅只是单纯地重新诠释其实现.

**示例**

```php
function One()
{
	funciton a();
	function b();
	funciton c();
}
```

在 `One()` 是一层抽象层,所以我们认为它是做了一件事. `a()`,`b()`,`c()`这些可以理解为在那层抽象层下面分割出来的一系列步骤.

### 每个函数一个抽象层级

要确保函数只做一件事,函数中的局域都要在==同一抽象层级上==.

函数中混杂不同抽象层级. 读者无法判断某个表达式是基础概念还是细节.

#### 函数编写的顺序

**向下规则**

让每个函数后面都跟着位于下一抽象层级的函数. 在查看函数列表时,就能循抽象层级向下阅读了.

```php
function A() 
{
}

function B() 
{
	b1();
	b2();
	b3();
}

function b1()
{
	b1-1();
	b1-2();
}
function b1-1()
{
}
function b1-2()
{
}
function b2()
{
	b2-1();
}
function b2-1()
{
}
function b3()
{
}
function C()
{
}
```

`A`,`B`,`C` 是同一层抽象层. `b1`是`B`的下层抽象,`b1-1`是`b1`的下层抽象所以顺序需要自顶向下.

程序就像是一系列`TO`起头的段落,每一段落都描述当前抽象层级,并引用位于下一抽象层级的后续`TO`起头段落.

```php
TO 完成一件事我们需要做 A,B,C
TO 完成 A 我们需要...
TO 完成 B 我们需要做 b1,b2,b3
TO 完成 b1 我们需要做 b1-1,b1-2
TO 完成 b1-1 ..
TO 完成 b1-2...
TO 完成 b2 ...
...
```

让代码读起来像是一系列自顶向下的`TO`起头段落是保持抽象层级协调一致的有效技巧.

### swittch 语句

确保 `switch` 埋藏在较低的抽象层级,而且永远不重复.

尽量使用`多态`来代替`switch`, 因为`switch`违反开放封闭原则. 每当添加新类型时,就要修改`switch`语句.

### 使用描述性的名称

函数越短小,功能越集中,就越便于取个好名字.

长而具有描述性的名称,要比短而令人费解的名称好.

==选择描述性的名称能理清你关于模块的设计思路==.

命名方式要保持一致性.

```php
open()
```

这里只有 `open()` 但是人们很容易就联想到对应 `closed()`. *编写可读性代码的艺术里面也阐述了这个思想,成对的函数出现*

### 函数参数

==最理想==的参数是零.

参数不易对付. 它们带有太多概念. 因为 ==参数与函数名处在不同的抽象层级==,它要求你了解目前并不特别重要的细节.

`输出参数`(传递地址进去的参数)比如数参数还要难以理解.

#### 一元函数的普遍形式

传入单个参数的理由:

* 询问参数.比如 `boolean fileExists("xxx")`, 就是询问这个文件是否存在.
* 操作参数.比如 `InputStream fileOpen("xxx") 把 string 类型转换为 InputStream 类型的返回值`
* 事件. 有输入参数而无输出参数.

#### 标识参数

参数如果传入 `bool` 则意味着函数不止做一件事.

#### 二元函数

因为两个参数没有 ==自然的排序==, 所以很难理解, 容易搞混.

```php
Point p = new Point(0,0);
```
上例表示一个点, 笛卡尔点天生就有两个参数, 是自然排序, 所以容易理解.

#### 三元函数

比二元函数难懂.排序,琢磨,忽略的问题都会加倍体现.

#### 参数对象

如果函数需要两个,三个或三个以上参数,就说明其中一些参数应该封装为类(值对象)了.

当一组参数被共通传递,就像上例中的 `x` 和 `y` 那样, 往往就是该有自己名称的某个概念的一部分. *把这些参数封装到值对象里面*

#### 参数列表

#### 动词与关键字

函数使用==动词==.

参数使用==名词==.

### 无副作用

函数承诺只做一件事,但是会做其他被藏起来的事(修改全局变量...).

会导致古怪的时序性耦合及顺序依赖.

```php
public funciton checkPassword()
{
	...
	session.initialize();
	...
	return false;
}
```
上述的例子就是明面上看起来是一个检查密码的函数, 但是内在却有初始化session的动作.
这就是副作用,用户调用这个函数并不知道这个副作用有.

函数应该改名为: `checkPasswordAndInitializeSession()`.

### 分隔指令与询问

函数:

* 做什么事
* 回答什么事

不要混在一起.

```php
set("username", "unclebob");
```

这个函数==实际==是设置某个指定属性, 如果成功就返回`true`, 如果不存在那个属性则返回 `false`.

但是用户理解起来:

* 在问`username`属性值是否之前已经设置为`unclebob`.
* 在问`username`属性值是否成功设置为`unclebob`.

因为上面这个函数干了两件事情:

* 检查是否已经设置,已经设置返回 `false`
* 如果没有设置,设置,返回 `true`

所以函数应该修改为:

```php
if (attributeExists("username")) {
	setAttribute("username", "unclebob");
}
```

### 使用异常代替返回错误码

如果使用异常替代返回错误码,错误处理代码就能从主路径代码中分离出来.

*我个人认为,错误是应该我们主观可以预见的,而异常是不能主观预见的.不能全部使用异常代替错误*

#### 抽离 Try/Catch 代码块

把 try 和 catch 代码块的主题部分抽离出来, 另外形成函数.

```php
try{
	函数()
} catch(Exception e) {
	函数()
}
```

这样分隔, 代码块更容易理解.

#### 错误处理就是一件事

错误处理就是一件事, 在 `catch/finally` 代码块后面也不该有其他内容.

#### Error.java 依赖磁铁

使用异常代替错误码, 新异常就可以从异常==类派生==出来, 无需重新编译或重新部署.

### 别重复自己

重复可能是软件中一切邪恶的根源.

数据库范式都是为消灭数据重复而服务.

### 结构化编程

每个函数, 函数中的每个代码块都应该有一个入口, 一个出口. 意味着每个函数中只该有一个`return`语句, 循环中==不能有==`break`或`continue`, 而且永远不能有任何`goto`语句.

在大函数中,这些规则才会有明显的好处.

小函数中偶尔出现`return`,`break`,continue`语句没有坏处.

### 如何写出这样的函数

* 写
* 测试
* 重构

### 小结

函数是语言的动词, 类是名词.

编程艺术是且一直是语言设计的艺术.

大师级的程序员把系统当作故事来讲.