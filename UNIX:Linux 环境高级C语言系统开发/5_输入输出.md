#5 输入输出

[输入输出-基本函数介绍、格式字符讲解](http://www.wyzc.com/play/8704/2974/#12507 "输入输出-基本函数介绍、格式字符讲解")

[输入输出-修饰字符讲解](http://www.wyzc.com/play/8704/2974/#12508 "输入输出-修饰字符讲解")

[输入输出-变参介绍、缓冲区刷新](http://www.wyzc.com/play/8704/2974/#12509 "输入输出-变参介绍、缓冲区刷新")

[scanf函数讲解](http://www.wyzc.com/play/8704/2974/#12510"scanf函数讲解")

###笔记

---

**Input(输入)&Output(输出)(I/O)**

* 标准 IO
* 文件 IO

####格式化的输入输出函数:scanf,printf

**printf**

`int printf(const char *format,...);`

`format`: `"%[修饰符] 格式化字符"`

`格式化字符`:

* `d,i`: 十进制整数(有符号的)

		int a = 567;
		printf("%d",a);
		输出: 567

* `x,X`: 十六进制无符号整数

		int a = 255;
		printf("%x",a);
		输出: ff

* `o`: 八进制无符号整数

		int a = 65;
		printf("%o",a);
		输出: 101

* `u`: 不带符号十进制整数

		int a = 567;
		printf("%d",a);
		输出: 567		

* `e`: 单一字符

		char a = 65;
		printf("%c",a);
		输出: A

* `s`: 字符串

		printf("%s","ABC");
		输出: ABC

* `e,E`: 指数形式浮点小数

		float a=567.789;
		printf("e%",a);
		输出: 5.677890e+02

* `f`: 小数形式浮点小数
		
		float a=567.789;
		printf("f%",a);
		输出: 567.789000
		
* `g`: `e`和`f`中较短一种

		float a=567.789;
		printf("g%",a);
		输出: 567.789

* `%%`: 百分号本身

		printf("%%");
		输出: %


`修饰符`:

* `m`: 输出数据域宽,数据长度 < m, 左补空格; 否则按实际输出

		int i = 123;
		printf("i = %4d\n",i);
		输出:
		i =  123; (多了一个空格, 123 三个空格, 4-3 = 1, 补1个空格)

* `.n`:
	* 对实数,指定小数点后位数(四舍五入)
			
			float f = 123.456;
			printf("f = %8.1f\n",f);(整体占8位,小数点后保留1位)
			输出:
			f =    123.5
				
	* 对字符串,指定实际输出位数
	
			#define STRSIZE 32;
			
			char str[STRSIZE] = "helloworld";
			
			printf("%.5s\n",str);
			输出:
			hello (后面的world,只是输出不显示)
	
* `-`: 输出数据在域内左对齐(缺省右对齐)

		#define STRSIZE 32;
			
		char str[STRSIZE] = "helloworld";
			
		printf("str = %10.5s\n",str);
		
		输出:
		str =       hello
		
		printf("str = %-10.5s[over]\n",str);
		
		输出:
		str = hello     [over]

* `+`: 指定在有符号数的正数前显示正号(`+`)
* `0`: 输出数值时指定左面不使用的空位置自动填0
* `#`: 在八进制和十六进制数前显示前导0, 0x

		int i = 255;
		printf("i = %#o\n",i);
		
		i = 0377; //8进制以0开头
		
		printf("i = %#x\n",i);
		
		i = 0xff;

* `l`: 
	* 在`d,o,x,u`前, 指定输出精度为`long`型
	* 在`e,f,g`前, 指定输出精度为`double`型

			double dou = 123.456;
			printf("%lf",dou);//不加l输出float型,加l输出double型.
			
**行缓冲模式**

`printf` 遇到 `\n` 刷新缓冲区,或者等当前缓冲区满了再刷新, 或者等程序结束刷新.


**scanf**

`int scanf(const char *format, ...(地址表))`

`format: 抑制符 *`.%后的"`*`"附加说明符,用来表示跳过它相应的数据.例如:

		scanf(“%2d%*3d%2d”,&a,&b);
		如果输入如下信息:1234567。将12赋给a,67赋给b。第二个数据”345”被跳过不赋给任何变量.

`%s`的使用是比较危险的, 因为不知道存储空间大小. (字符数组越界)

`scanf`放在循环结构中要注意能否接收到正常有效的内容.

`示例`:

		int i;
		float f;
		char str[32]
		
		printf("Please enter:\n");
		scanf("%d,%f", &i, &f);//终端输入格式必须一致, 输入 345,79.98(有逗号)
		//scanf("%d%f", &i, &f);//如果不加间隔符(与上面示例不同,没有逗号),间隔符可以是回车, tab, 空格键
		
		scanf("%s", str);//不加 &, 因为数组本质就是地址


###整理知识点

---

####缓冲区

**什么是缓冲区**

缓冲区又称为缓存,它是内存空间的一部分.也就是说,在内存空间中预留了一定的存储空间,这些存储空间用来缓冲输入或输出的数据,这部分预留的空间就叫做缓冲区.

缓冲区根据其对应的是输入设备还是输出设备,分为`输入缓冲区`和`输出缓冲区`.

**为什么要引入缓冲区**

比如从磁盘里取信息,我们先把读出的数据放在缓冲区,计算机再直接从缓冲区中取数据,等缓冲区的数据取完后再去磁盘中读取,这样就可以减少磁盘的读写次数,再加上计算机对缓冲区的操作大大快于对磁盘的操作,故应用缓冲区可大大提高计算机的运行速度.

又比如,我们使用打印机打印文档,由于打印机的打印速度相对较慢,我们先把文档输出到打印机相应的缓冲区,打印机再自行逐步打印,这时我们的CPU可以处理别的事情.

缓冲区就是一块内存区,它用在输入输出设备和CPU之间,用来`缓存数据`.它使得`低速的输入输出设备和高速的CPU能够协调工作`,`避免低速的输入输出设备占用CPU`,`解放出CPU`,`使其能够高效率工作`. 

**缓冲区的类型**

1. `全缓冲`: 在这种情况下,当填满缓冲区后才进行实际I/O操作.全缓冲的典型代表是对磁盘文件的读写. 
	
    在这种情况下,实际的I/O操作只有在缓冲区被`填满`了之后才会进行.对驻留在磁盘上的文件的操作一般是有标准I/O库提供全缓冲.缓冲区一般是在第一次对流进行I/O操作时,由标准I/O函数调用malloc函数分配得到的.

    术语`flush`描述了标准I/O缓冲的写操作.缓冲区可以由标准I/O函数自动flush(例如缓冲区满的时候);或者我们对流调用flush函数.

	`满了的时候刷新,强制刷新`.	
	
	`默认,只要不是终端设备`.
		
2. `行缓冲`: 在这种情况下,当在输入和输出中遇到换行符时,执行真正的I/O操作.这时,我们输入的字符先存放在缓冲区,等按下回车键`换行`时才进行实际的I/O操作.典型代表是标准输入(stdin)和标准输出(stdout).这允许我们一次写一个字符,但是只有在写完一行之后才做I/O操作.

	`换行刷新,满了的时候刷新,强制刷新`.
	
	`标准输出是这样的,因为是终端设备`.


3. `不带缓冲`:也就是不进行缓冲,标准错误文件 stderr 是典型代表,这使得出错信息可以直接尽快地显示出来.(标准库不缓存并不意味着操作系统或者设备驱动不缓存)

`大部分系统默认使用下列类型的缓存`:

* 标准出错是不带缓冲的.
* 如果是涉及终端设备的流,则它们是行缓冲的；否则是全缓冲的.

目前主要的缓冲特征是：`stdin`和`stdout`是行缓冲；而`stderr`是无缓冲的. 

**缓冲区的大小**

缓冲区大小由 stdio.h 头文件中的宏 BUFSIZ 定义,如果希望查看它的大小,包含头文件,直接输出它的值即可：

printf("%d", BUFSIZ);

**缓冲区的刷新(清空)**

下列情况会引发缓冲区的刷新:

* 缓冲区满时
* 行缓冲区遇到回车时
* 关闭文件
* 使用特定函数刷新缓冲区

**键盘敲入的字符的特殊说明**

当我们从键盘输入字符串的时候需要敲一下回车键才能够将这个字符串送入到缓冲区中,那么敲入的这个回车键(\r)会被转换为一个换行符\n,这个换行符\n也会被存储在缓冲区中并且被当成一个字符来计算！比如我们在键盘上敲下了123456这个字符串,然后敲一下回车键(\r)将这个字符串送入了缓冲区中,那么此时缓冲区中的字节个数是7 ,而不是6.

####字符数组越界

**为什么会出现越界**

输出字符串是根据'\0'来判断是否结束的,不会管你数组是大小,就是因为这样,才有可能造成越界以后读到别人的内存.

**越界产生的原因**

定义一个变量,实际上是向操作系统申请一段内存. 例如`char a[10]`,系统会给它分配`一段连续的内存块`用来存放数据.这个内存块是随机的,它可以是目前空闲的任意一个内存段.
由于这个不确定性,所以它后面的内存块有两种可能:

* 如果恰好这段内存的后面的内存段没有被其他程序占用,那么我们对它进行使用是不会出错的.就是你上述的超过10个还可以输入输,但是它随时可能被其他程序修改得不到保证.
* 因为这段内存不属于本程序管理,它也有可能被其他程序占用,或者干脆就是操作系统禁止访问的区域,这时候就必定会导致错误了.

**字符数组的长度**

字符数组的长度计算: 必须以终止符`'/0'`作为边界.

1. char chs[7] = {'a', 'c', '0', 'z', '3','d'}; // 长度为6
2. char chs[7] = {'a', 'c', '0', 'z', '3','d', '/0'}; // 长度为6
3. char chs[] = {'a', 'c', '0', 'z', '3','d', '/0' }; // 长度为6

1,2,3 等价 不等价于 4,5

4. char chs[] = {'a', 'c', '0', 'z', '3','d'}; // 长度未知，因为数组最后没有结束符'/0'
5. char chs[6] = {'a', 'c', '0', 'z', '3','d'}// 长度未知，因为数组最后没有结束符'/0'


在C语言中没有专门的字符串变量,通常用一个字符数组来存放一个字符串.字符串总是以'/0'作为串的结束符.因此当把一个字符串存入一个数组时,也把结束符'/0'存入数组,并以此作为该字符串是否结束的标志.有了'/0'标志后,就不必再用字符数组的长度来判断字符串的长度了.

		char c[]={'c', ' ','p','r','o','g','r','a','m'};
		
		可以写为:
		
		char c[]={"C program"};
		char c[]="C program";
		 		
用字符串方式赋值比用字符逐个赋值要多占一个字节,用于存放字符串结束标志'/0'.

		上面等价于
		
		C p r o g r a m /0 

'/0'是由C编译系统自动加上的.由于采用了‘/0'标志,所以在用字符串赋初值时一般无须指定数组的长度,而由系统自行处理.

**sizeof 和 strlen 的区别**

* strlen只能用char*做参数,且该char数组必须是以`'/0'`结尾的.
* 数组做sizeof的参数不退化,传递给strlen就退化为指针了.大部分编译程序 在编译的时候就把sizeof计算过了. `sizeof`即使在字符数组没有终止符'/0' 的时候,也能够计算出数组"长度"的原因,但这里的"长度"实际上是:`编译器分配给该数组变量的内存大小`!

		char chs[] = {'a', 'c', '/0', 'z', '3','d'}; 
		sizeof(chs) = 6(1个 char 1个字节); 而strlen(chs) = 2. 
		
		int fib[10] = {1,1};//sizeof(fib) = 40 int 占4个字节