#10,11 一维数组

[一维数组的定义、初始化和数组元素](http://www.wyzc.com/play/8704/2984/#12553 "一维数组的定义、初始化和数组元素")

[一维数组之fabonacci数列](http://www.wyzc.com/play/8704/2984/#12554 "一维数组之fabonacci数列")

[一维数组之冒泡排序](http://www.wyzc.com/play/8704/2984/#12555 "一维数组之冒泡排序")

[一维数组之选择法排序](http://www.wyzc.com/play/8704/2984/#12556 "一维数组之选择法排序")

[一维数组之进制转换、删除法求质数](http://www.wyzc.com/play/8704/2984/#12557 "一维数组之进制转换、删除法求质数")

###笔记

---

**数组**

内存当中连续存储的用来存放相同类型的一块空间.

**定义**

`[存储类型]` `数据类型` `标识符` `[下标]`

		#define M 3
		
		int arr[M];
		
		for(i = 0; i < M; i++){
			printf("%p --> %d\n",&arr[i],arr[i]);//输出地址和值,证明是连续存放的
		}
		
		输出:
		0x7fff56736ab0 --> 1450404640
		0x7fff56736ab4 --> 32767
		0x7fff56736ab8 --> 0
		
		说明一个整型数占空间4个字节, 未初始化都是随机值
		
**初始化**

没有初始化,数组的值是随机的.

`部分元素初始化`, 没有初始化的值为默认值.

`static`

		static int arr[M]
		
		就算没有初始化也会把所有值默认为0

**元素引用**

		`数组名[下标]`

**数组名**

		int arr[M]
		
`arr` 是数组名,同时也是数组的起始位置(表示地址的常量).

		printf("%p", arr)
		等同于
		printf("%p", arr[0])

`为什么arr是(表示地址的)常量`:

		int arr[M] = {1,2,3}
		
		arr = {4,5,6}//报错

**数组越界**

		arr[3] = 10;//越界,是靠地址偏移找过来的
		
		a[i] 从当前数组的其实位置,移动"i"块空间, 然后取值
		*(a + i)

`为什么数组越界不检查`, 因为是用的指针偏移这个表达式来构成的.

**冒泡排序**

1. 比较相邻的元素.如果第一个比第二个大,就交换他们两个.
2. 对每一对相邻元素作同样的工作,从开始第一对到结尾的最后一对.在这一点,最后的元素应该会是最大的数.
3. 针对所有的元素重复以上的步骤,除了最后一个。
4. 持续每次对越来越少的元素重复上面的步骤,直到没有任何一对数字需要比较。

		5 7 6 8 9 2 1 4 3
		5 6 7 8 2 1 3 3 9
		5 6 7 2 1 4 3 8 .
		5 6 2 1 4 3 7 . .
		5 2 1 4 3 6 . . .
		2 1 4 3 5 . . . . 
		1 2 3 4 . . . . .
		1 2 3 . . . . . .
		1 2 . . . . . . .
		
		
`代码`:
		
		for(i = 0; i < (N-1); i++){
			
			for(j = 0; j < N-1+i; j++){
				
				if(a[j] > a[j+1]){
					tmp = a[j];
					a[j] = a[j+1];
					a[j+1] = tmp;
				}
			}
		}
		
**选择排序**

每一次从待排序的数据元素中选出最小(或最大)的一个元素,存放在序列的起始位置,直到全部待排序的数据元素排完.

		5 7 6 8 9 2 1 4 3
		
		拿5比较
		1 . . . . . 5 . . //剩下内容不变
		
		拿7比较
		1 2 . . . 7 5 . .
		
		拿6比较
		...


`代码`:

		for(i = 0; i < (N-1); i++){
			
			k = i;
			
			for(j = i+1; j < N; j++){
				
				if(a[j] < a[k]){
					k = j;
				}
			}
			
			if(i != k){
				
				tmp = a[i];
				a[i] = a[k];
				a[k] = tmp;
			}
		}		

####示例

**fibonacci数列**

		static void fibonacci(void){
		
			int fib[10] = {1,1}
			
			int i;
			for(i = 2; i < 10; i++){
				fib[i] = fib[i-1] + fib[i-2];
			}
		}

###整理知识点

---
