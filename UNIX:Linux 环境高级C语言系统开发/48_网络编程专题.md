#48 网络编程专题

[套接字-字节序问题](http://www.wyzc.com/play/8704/2403/#9111 "套接字-字节序问题")

[套接字-socket函数](http://www.wyzc.com/play/8704/2403/#9112 "套接字-socket函数")

[套接字-报式套接字相应过程](http://www.wyzc.com/play/8704/2403/#9113 "套接字-报式套接字相应过程")

[套接字-报式套接字实例](http://www.wyzc.com/play/8704/2403/#9114 "套接字-报式套接字实例")

###笔记

---

####套接字-字节序问题

**跨主机传输要注意的问题**

1. `字节序问题`: 大端存储和小端存储.
	* `大端`存储: 低地址处放高字节
	* `小端`存储: 低地址处放低字节(x86用小端) 
	
			0000 0005
			大端: 0500 0000
			小端: 0000 0005
	* 无论大小端永远都是低地址数据先出去.
	* 解决方案: 不在严格区分大小端,区分主机字节序(host)和网络字节序(network).主机到网络(主机序到网络序)`_to__:`.
		* `htons`: host to network short (16位)
		* `htonl`: host to network long (32位)
		* `ntohs`: network to host short
		* `ntohl`: network to host long 
2. 对齐: 解决方案是网络传输时不对齐.(因为对齐的话在不同环境可能会造成读取问题).

		struct{
			int i;
			float f;
			char ch;
		};

3. 类型长度的问题
		
		sizeof(int) 占多大 (16位机器 和 32位机器)
		char 有没有符号
		
	* 解决方案: `int32_t`,`uint32_t`,`int64_t`,`int8_t`,`uint8_t`
		
**SOCKET是什么**

中间层,抽象出来的是一个文件描述符.

`int socket(int domain, int type, int protocol)`

* `domain`: 协议族
* `type`: 类型,上层如何实现
* `protocol`: 协议

用某个协议族中的某个协议支持某种类型的传输.

**报式套接字**

* 数据的分组(`datagrams`),数据的完整性.(传输结构体).每个结构体之间有清晰的边界.
* 无连接的`connectionless`.
* 不可靠的(`unreliable`).
* 有最大长度`a fixed maximum length`.

不能确保数据完整性

**流式套结字**

* 有序的,可靠的`seuenced,reliable`: 只要接收方能接收到数据,那么保证当前包当中的内容是正确的,顺序是正确的.不是`不丢包`.
* 双工`two-way`.
* 基于连接的`connection-based`: 点对点的,单对单的,每个人专用的.
* 字节流式传输`byte streams`: 以字节流为单位,数据没有特别严格意义上的边界.

**有序分组(安全可靠的报式传输)**

* 有序的,可靠的`seuenced,reliable`.
* 双工`two-way`.
* 基于连接的`connection-based`.
* 有上限的报式通信`data transmission path for datagrams of fixed maximum length`.

####套接字-报式套接字相应过程

**示例**

* 被动端(先运行)
  * 取得SOCKET
  * 给SOCKET取得地址
  * 收/发消息
  * 关闭SOCKET

* 主动端
  * 取得SOCKET
  * 给SOCKET取得地址
  * 发/收消息
  * 关闭SOCKET 
  
`proto.h`:

		#ifndef PROTO_H__
		#define PROTO_H__
		
		//设定端口
		#define RCVPORT		"1989"
		
		//这里选择11,地址不对其
		#define NAMESIZE	11
		
		struct msg_st{
		 
			uint8_t char name[NAMESIZE];
			uint32_t math;
			uint32_t chinese;
		
		}__attribute__((packed));//表示告诉gcc不对齐
		
		#endif
		
`rcver.c`:

		#include <stdio.h>
		#include <stdlib.h>
		
		#include "proto.h"
		
		int main(){
			
			int sd;
			
			//man 7 ip 中的  Address format
			struct sockaddr_in laddr;
			
			//0: IPPROTO_UDP
			sd = socket(AF_INET,SOCK_DGRAM,0);
			if(sd < 0){
				perror("socket()");
				exit(1);
			}
			
			laddr.sin_family = AF_INET;
			//htons:换为网络字节顺序
			laddr.sin_port = htons(atoi(RCVPORT));
			inet_pton(AF_INET,"0.0.0.0",&laddr.sin_addr); 
			
			if(bind(sd,(void *)&laddr,sizeof(laddr)) < 0){
				perror("bind()");
				exit(1);
			}
			
			while(1){
				recvfrom();
				printf();
			}
			
			close();
			
			exit(0);
		}

`snder.c`:  

###整理知识点

---