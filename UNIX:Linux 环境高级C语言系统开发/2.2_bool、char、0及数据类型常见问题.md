#2.2 bool、char、0及数据类型常见问题

[地址](http://www.wyzc.com/play/8704/2973/#12498 "地址")

###笔记

---

**类型转换**

往精度高的类型转换.

**float类型**

		int func(float f){
			if(f < 0){
				return -1;
			}else if(f ==0){// 应该这样写 fabs(f-0) <= 1e-6
				return 0;
			}else{
				return 1;
			}
		}

`float`本身不是精确的表示.


float 和 0 比较:

		|f-0| <= 10^-6(0.000001)  

**char形是否有符号在标准C中未定义**

**不同形式的0值**

* `0`
* `'0'`
* `"0"`
* `'\0'`

**数据类型与后续代码中所使用的输入输出要相匹配**

比如: 输入使用`无符号整数`, 输出使用`%d(有符号整数)`, 会造成精度丢失


###整理知识点

---

**float类型**

`float`和`double`存储分为三个部分:

* 符号位(Sign): 0代表正, 1代表为负
* 指数为(Exponent): 用于存储可续计数法中的指数数据,并且移位存储. 该实数转化为规格化的二进制实数后的指数与127(127即所谓偏移量)之和.
* 尾数部分(Mantissa): 位于小数点后面的数

`float`的存储方式:

![float](./img/2.2_1.gif "float")

`double`的存储方式:

![double](./img/2.2_2.gif "double")

`示例` 178.125:

1. 将128.125表示成二进制数:(178.125)(十进制数)=(10110010.001)(二进制形式);
2. 将二进制形式的浮点实数转化为规格化的形式:(小数点向左移动7个二进制位可以得到)10110010.001=1.0110010001*2^7 因而产生了以下三项:
	* `符号位`: 该数为正数,故第31位为0,占一个二进制位. 
	* `阶码`: 指数为7,故其阶码为127+7=134=(10000110)(二进制),占从第30到第23共8个二进制位. (因为指数可以为负,为了便于计算,规定都先加上127(如果是`double`,则加上`1023`)).
	* `尾数`:  即0110010001.因为尾数共23个二进制位,在后面补13个0,即01100100010000000000000

178.125在内存中的实际表示方式为:

0 10000110 01100100010000000000000


**float浮点数误差**

`默认输出小数后6位`.

		float f = 123.456;
		printf("f = %f\n",f);
		输出:
		123.456001
		
`printf(%f)`:		
		
* printf的%f说明符的确既可以输出float型又可以输出double型.根据"默认参数提升"规则(在printf这样的函数的可变参数列表中,不论作用域内有没有原型,都适用这一规则)
`float型会被提升为double型`.因此printf()只会看到`双精度数`.也就会出现了`扩展的4个字节中内容`.
	
* `float(单精度)`: 打印格式为%f的时候,数据会以8字节出栈,这个时候后32bit都是0(float 占4字节).
* `double(双精度)`: 本身就是8字节存储,相比单精度存储,他后32bit是有数据的.所以这个时候取出的8字节,四舍五入.


实型数据在内存中存储的二进制位数是有限的,例如float型数据在内存中有24位二进制尾数.而一个十进制实数转化为二进制实数时,`其有效数字位数有可能会超过尾数的存储长度`,`从而导致有效数字丢失而产生误差`.








