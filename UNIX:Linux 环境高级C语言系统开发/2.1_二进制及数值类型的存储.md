#2.1 二进制及数值类型的存储

[地址](http://www.wyzc.com/play/8704/2973/#12497 "地址")

###笔记

---

**数据类型(基本数据类型)**

C 语言识别 十进制, 八进制（0开头）, 十六进制(0x开头). 不识别二进制(计算机只识别二进制).

* `整型`
	* 有符号 	
		* `(signed)int`
		* `(signed)shot`
		* `(signed)long`
	* 无符号
		* `unsigned`
		* `unsigned short`
		* `unsigned long`
* `实数`
	* 有符号
		* `float`
		* `double`  
* `字符型`
	* 有符号
		* `char`
	* 无符号
		* `unsigned char` 

**补码**

计算机储存有符号的整数时,是用该整数的补码进行储存的

###整理知识点

---

**补码**

* 正数: `原码` = `补码`
* 负数:
	* `原码`: 原码 = 正数部分(去掉负号,符号位不参与运算)的二进制值,且符号位(最左边的比特位)为1
	* `反码`: 反码 = 负数的反码是在其原码的基础上, 符号位不变,其余各个位取反
	* `补码`: 补码 = 反码 + 1
	
			-11(8位): 
			原码:  1000 1011
			反码:  1111 0100
			补码:  1111 0101
			
**为什么用补码**

加减乘数已经是最基础的运算, 要设计的尽量简单. 计算机辨别"符号位"显然会让计算机的基础电路设计变得十分复杂! 根据运算法则减去一个正数等于加上一个负数, 即: 1-1 = 1 + (-1) = 0. 所以机器可以只有加法而没有减法, 这样计算机运算的设计就更简单了.
			
`1-1 = 0`:

1. 如果用原码表示, 让符号位也参与计算, 显然对于减法来说, 结果是不正确的.这也就是为何计算机内部不使用原码表示一个数

		1 - 1 = 1 + (-1) = [00000001]原 + [10000001]原 = [10000010]原 = -2
		
2. `反码解决了原码做减法的问题`

		1 - 1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原= [0000 0001]反 + [1111 1110]反 = [1111 1111]反 = [1000 0000]原 = -0
		
	发现用反码计算减法, 结果的真值部分是正确的. 而唯一的问题其实就出现在"0"这个特殊的数值上. 虽然人们理解上+0和-0是一样的, 但是0带符号是没有任何意义的. 而且会有[0000 0000]原和[1000 0000]原两个编码表示0.
	
3. `补码`解决了0的符号以及两个编码的问题

		1-1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原 = [0000 0001]补 + [1111 1111]补 = [0000 0000]补=[0000 0000]原
		
	这样0用[0000 0000]表示, 而以前出现问题的-0则不存在了.而且可以用[1000 0000]表示-128:
	
		(-1) + (-127) = [1000 0001]原 + [1111 1111]原 = [1111 1111]补 + [1000 0001]补 = [1000 0000]补
		
	实际上是使用以前的-0的补码来表示-128, 所以-128并没有原码和反码表示.
	

`实际上并不是从10000001到11111111依次表示-1到-127，而是刚好相反的，从10000001到11111111依次表示-127到-1`


`乘法`: `(左)移位` 和 `加法` 实现

`除法`: `(右)移位` 和 `(补码,实际上是减)加法` 实现
