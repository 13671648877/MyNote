# 05 | 白话容器基础（一）：从进程说开去

## 笔记

容器本身没有价值, 有价值的是**容器编排**.

### 边界

#### 进程

程序被执行起来, 就从磁盘上的二进制文件, 编程了计算机内存中的数据, 寄存器里的值, 堆栈中的指令, 被打开的文件, 以及各种设备的状态信息的一个集合.

**像这样一个程序运行起来后的计算执行环境综合, 就是进程**

* 静态: 程序(平时安安静静待在磁盘上)
* 动态: 运行起来, 变成了计算机里的数据和状态的综合

容器技术的核心功能, 就是通过**约束和修改**进程的动态表现, 从而为其创造出一个"边界".

#### Cgroups

用来制造**约束**

#### Namespace

用来修改进程视图

#### Namespace 示例

```
$ docker run -it busybox /bin/sh
/ #

/ # ps
PID  USER   TIME COMMAND
  1 root   0:00 /bin/sh
  10 root   0:00 ps

```

当我们在宿主机运行了一个`/bin/sh`程序, 操作系统都会给它分配一个进程编号, 比如`PID=100`. 这个编号是进程的唯一标识. 类似员工工牌.

当我们通过`Docker`把这个`/bin/sh`程序运行在一个容器当中. 这时候, `Docker`就会在这个第`100`号员工入职时给它施展一个障眼法, **让他永远看不到前面的其他99个员工**, 他就会错误地以为自己就是公司里的第1号员工.

其实就是对被隔离应用的进程空间做了手脚，使得这些进程只能看到重新计算过的进程编号，比如 PID=1。可实际上，他们在宿主机的操作系统里，还是原来的第 100 号进程。

```
int pid = clone(main_function, stack_size, CLONE_NEWPID | SIGCHLD, NULL); 
```
新创建的这个进程将会“看到”一个全新的进程空间，在这个进程空间里，它的 PID 是 1。

在宿主机真实的进程空间里, 这个进程的`PID`还是真实的数值.

### Namespace 

* PID Namespace
* Mount Namespace
* UTS Namespace
* IPC Namespace
* Network Namespace
* User Namespace

#### Mount Namespace

让被隔离进程只看到当前 Namespace 里的挂载点信息.

#### Network Namespace

用于让被隔离进程看到当前 Namespace 里的网络设备和配置.

### 总结

在创建容器进程时，指定了这个进程所需要启用的一组 Namespace 参数。这样，容器就只能“看”到当前 Namespace 所限定的资源、文件、设备、状态，或者配置。而对于宿主机以及其他不相关的程序，它就完全看不到了。

**容器其实就是一种特殊的进程而已**

### Docker 和 虚拟机

![](./img/05_01.png)

左是虚拟机. `Hypervisor`通过硬件虚拟化功能, 模拟出了运行一个操作系统需要的各种硬件. 然后它在这些虚拟机的硬件上安装了一个新的操作系统, 即`Guest OS`.

`Docker engine`替换了`Hypervisor`. 所以**`Docker`被称为轻量级虚拟化技术**.

**`Docker engine`是启动时用, 运行时并不需要, 真实进程是直接run在host os上**

**使用`Docker`的时候, 并没有一个真正的"Docker 容器"运行在宿主机里面. DOcker 帮助用户启动, 还是原来的应用进程, 只不过在创建这些进程时, Docker为它们加上了各种各样的`Namespace`参数**. 

## 扩展