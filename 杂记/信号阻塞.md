### 信号阻塞

#### execve

用被执行的程序完全替换了调用进程的映像.启动一个新程序,替换原有进程,所以被执行进程的PID不会改变.

调用 `execve` 执行一个新的进程时,新进程的信号处理方式要么是忽略,要么是系统默认方式.
如果调用进程忽略该信号,则新进程也忽略该信号,如果调用进程捕捉该信号,或者执行系统默认动作,新进程则按照默认行为处理该信号,这是因为==调用进程的信号处理函数在新进程中已经无效了==.

**示例**

```php
<?php

//pcntl_signal(SIGHUP, SIG_IGN);

pcntl_exec('./command', array('arg1','arg2'), array('env'=>'test'));

echo 222, PHP_EOL;
```

上面例子,我们在发送 `kill -1 xx` 新的进程会 `Hangup`, 但是如果我们在调用进程忽略信号,被执行进程也一样忽略信号.

#### fork

如果是调用fork产生子进程,则子进程的信号处理方式完全继承父进程的处理方式.这是因为子进程复制了父进程的地址空间,因此==父进程中的信号处理函数在子进程中同样被复制了==.

#### 信号动作

当信号产生以后, 对信号材==采取了动作时, 称为向进程"递送"了一个信号==,在信号产生(`generation`) 和递送 (`delivery`) 之间的时间间隔内, 称信号是未决的(`pending`).

* 信号产生`generation`
* 信号未决`pending`
* 信号递送`delivery`

进程可以"阻塞"信号,如果为进程产生了一个阻塞的信号,而且对该信号的动作是调用信号处理函数捕捉该信号,或者是系统默认动作,则会为该进程将此信号保持为未决状态,直到:
 
 * 对此信号解除了阻塞
 * 对此信号的动作改为忽略

内核在递送一个原来被阻塞的信号给进程时(不是产生信号),才决定对它的处理方式,因此,进程在信号被递送之前仍可改变对该信号的动作.
 
如果在进程解除某个信号的阻塞之前,该信号发生了多次,则系统可以递送该信号一次或多次.如果递送多次,则称对这些信号进行了排队.==但是除非支持POSIX.1实时扩展,否则大多数UNIX并不对信号排队,也就是指递送该信号一次.==

每个进程都有一个==信号屏蔽字==,它规定了当前要阻塞的信号集.POSIX.1使用数据类型`sigset_t`表示一个信号集,进程可以调用`sigprocmask`来检测和更改当前信号屏蔽字.

对信号的处理是以==进程为单位==的,也就是说在多线程环境中,信号的处理是==进程中所有线程共享的==.但是每个线程可以有自己的信号屏蔽字,所以,==单个线程可以阻塞某些信号,当某个线程修改了某个信号的处理方式后,所有线程共享这个处理方式的改变==.


 