#Linux 进程

---


###进程的概念

####什么是进程

进程(Process)是计算机中`程序执的实体`.程序通常是由`指令`和`相关数据`组成的,在 Linux系统中,程序的运行通常是由用户通过一个`命令行解释器`(例如bash shell)发起执行,或者由`其他进程`派生而来.

####进程标识符

每个进程都有一个非负整数表示的唯一标识符,进程运行时 `PID` 是由操作系统随机分配的,进程 `ID` 可以重用.当一个进程终止后,其进程 `ID` 就可以再次使用了.大多数 UNIX 系统实现延迟重用算法,使得赋予新建进程的 ID 不同于最近终止进程所使用的 ID.

**一些特殊进程**

系统中有一些专用的进程.ID 为 `0` 的进程通常是`调度进程`,常常被称为"`交换进程`"(`swapper`).该进程是`内核的一部分`,它不是磁盘的程序.ID 为 `1` 的进程是 `init 进程`,在系统自举过程结束时由内核调用.该进程的程序文件是 `/sbin/init`.此进程`负责在自举内核后启动一个 Unix 系统`.init 通常会读取与系统有关的初始化文件(`/etc/rc* `或 `/etc/inittab`,以及 `/etc/init.d/` 中的文件),并将系统启动至某个状态.init 进程不会终止,`系统启动后产生的所有进程都由 init 进程衍生而来`.

####pid

每个进程除了一定有 `PID` 还会有 `PPID`,也就是父进程 ID,通过 `PPID` 可以找到父进程的信息.`系统启动后所有的进程都由 init 进程衍生而来`.

因为所有进程都来自于一个进程,所以 Linux 的`进程模型也叫做进程树`.

使用 `pstree` 命令可以查看系统当前的进程树:

		[chloroplast@dev-server ~]$ pstree
		init─┬─AliHids───9*[{AliHids}]
		     ├─AliYunDun───8*[{AliYunDun}]
		     ├─AliYunDunUpdate───3*[{AliYunDunUpdat}]
		     ├─crond
		     ├─docker───29*[{docker}]
		     ├─gshelld───3*[{gshelld}]
		     ├─6*[mingetty]
		     ├─nscd───7*[{nscd}]
		     ├─ntpd
		     ├─rsyslogd───3*[{rsyslogd}]
		     ├─sshd───sshd───sshd───bash───pstree
		     └─udevd───2*[udevd]
		     
####进程的内存空间

在一个多任务操作系统当中,可能存在着上千个进程,而物理内存只有一个,为了防止进程访问原本不属于本进程的内存空间,现代操作系统都会使用"`内存保护`"技术.

每一个进程都运行在它自己的内存沙箱(sandbox)中.这个沙箱被称作"`虚拟地址空间`"(virtual address space),在32位的系统中,它是一个`4GB`大小的内存地址空间,虚拟内存是线性可编址的,其使用单位是`页(page)`,对应的物理内存被称为`页框(page frame)`.这些虚拟的地址通过`页表(page table)`映射至真实的物理内存,页表由操作系统内核处理器(内存管理单元`MMU`)负责管理.`每个进程都有它自己的页表`.

这里需要注意,所有的进程都运行在"`虚拟内存`"中,即使是内核本身也一样.因此,虚拟地址空间中的一部分是专门供内核使用的.

![virtual address](./img/virtual_address.jpg "virtual address")

Linux系统中虚拟地址空间中的最高地址的 `1GB`(32位系统) 为`内核空间`(kernel space),但这并不意味着内核实际使用了这么多物理内存.在页表中,内核空间被标记为特权指令(privileged code,CPU 的 ring 0)专用,因此一个普通进程在访问时会产生页错误(page fault).`对于所有的进程来说,虚拟地址空间中的内核空间都被映射至相同的物理内存地址,而每个进程的用户空间被映射至物理内存地址的情况都不相同`.

一个进程可能不会需要同时使用所有的虚拟内存中的代码和数据,Linux 使用了请求分页技术(demand paging),某些数据可能在进程虚拟地址空间中存在,但是并没有被载入到物理内存中,仅当进程试图访问这些数据时,系统硬件将产生一个页错误(page fault),由内核负责将数据载入物理内存(如果数据已经在物理内存中存在则不需要载入),并将虚拟内存地址映射至响应的物理内存地址.

####进程的状态

系统中可能存在大量进程,而 CPU 的数量是有限的,因此进程并不一定处于运行状态.在 Linux 系统中,进程有下面这些`状态`:

![process status](./img/process_status.png "process status")

* `Executing`: 进程正在 CPU 上运行.
* `Ready`: 进程处于准备运行状态,它被放置在一个运行队列中,等待系统分配 CPU 资源给它.
* `Stopped`: 进程被停止,通常是通过接收一个信号,正在被调试的进程可能处于停止状态.
* `Uninterruptible`: 不可中断睡眠,处于这个状态的进程通常需要等待某个资源,而且在等待过程中进程会忽略任何信号.被磁盘设备 I/O 所阻塞的进程可能处于这个状态.
* `Interrruptible`: 可中断睡眠状态,进程需要等待某个特定的条件为真,才会继续运行,可中断睡眠状态的进程可以被信号唤醒.
* `Zombie`: 子进程已经结束,而父进程没有调用 `wait()` 或者 `waitpid()` 系统调用获取子进程的终止状态,导致进程的进程描述符没有被回收.

####进程描述符

为了管理进程,内核需要追踪每个进程的运行状态,例如进程的优先级,PID,进程的地址空间等信息.内核使用一个 task_struct 类型的结构体来保存这些信息,它被称为`进程描述符`,对于`每个进程,内核都为其创建一个进程描述符`,内核使用`双向链表`的结构来存储这些进程描述符.

![process descriptor](./img/process_descriptor.jpg "process descriptor")

####进程的产生方式

进程不是凭空创建的,每个进程都是由其父进程衍生而来,在 Linux 系统中,父进程通常使用`fork()`,`vfork()`,`clone()`等系统调用来生成子进程.

ork 创建的进程成被称为"`子进程`"(child process).例如,在 shell 中执行一个命令时,shell进程就会调用 `fork()` 产生一个子进程,然后子进程调用 exec() 执行命令程序,进程结束后返回控制至父进程 shell 进程.

**写时复制**

在 Linux 系统中,进程使用 fork() 产生的子进程时,并没有立即为子进程分配物理页框.Linux 系统使用了写时复制(Copy On Write, COW)技术.这意味着子进程被创建时,与其父进程共享相同的物理页框(page frame),子进程实际使用的是其父进程的堆栈空间,内核将这些共享区域标记为只读.当父、子进程中的任一个试图修改这些区域时,内核会为修改区域的那块内存制作一个副本,并标记为可写,对于原来的共享内存页框,内核会检查是否此页框只被一个进程所使用,如果只被一个进程使用,那么此页框也为可写.这样做的原因是子进程的生命周期可能很短,使用"`写时复制`"技术可以按需为进程分配内存,使得内存的分配更加高效.

**僵尸进程(Zombie)**

当一个进程完成它的工作终止之后,它的父进程需要调用 `wait()` 或者 `waitpid()` 系统调用取得子进程的终止状态.

一个进程使用 fork 创建子进程,如果子进程退出,而父进程并没有调用 `wait` 或 `waitpid` 获取子进程的状态信息,那么子进程的进程描述符仍然保存在系统中而未被释放.这种进程称之为`僵死进程`.

**孤儿进程(Orphan Process)**

如果父进程产生子进程后终止了,且子进程继续运行,子进程被称为孤儿进程,孤儿进程由 `init` 进程收养,它的 PPID 变为 1.

####进程调度

在同一个时刻,一个 CPU 核心上只能运行一个进程,CPU 在某一个时刻运行哪个进程需要依靠操作系统内核来进行调度.操作系统为每个进程分配一个优先级,系统内核根据优先级来调度进程运行.

**进程的优先级**

Linux 中共有 `0~139` 种优先级,其中 `1-99` 被称为实时优先级,`数字越大优先级越高`.100-139 被称为动态优先级,内核可以调整进程的动态优先级.还可以使用 `nice` 或 `renice` 指令调整进程的动态优先级(用户可以调整).

Linux 系统使用了抢占式的进程调度.这意味着,当一个进程进入 `TASK_RUNNING` 状态(准备运行状态)时,内核检查次进程的优先级,并与当前正在运行的进程的优先级进行比较,如果次进程的优先级更大,当前运行的进程被中断,调度器重新挑选一个进程运行.

**调度策略(运行队列和过期队列)**

Linux 系统`对每种优先级都维护一个运行队列`和`过期队列`,系统每次从优先级最高的运行队列中挑选进行运行,然后放入其过期队列中.当运行队列中的进程全部进入过期队列后,再将过期队列和运行队列对调.

####守护进程

守护进程(Daemon)是一种后台服务进程,它们通常不与终端关联,`用户空间守护进程的父进程是 init 进程`.不会随着终端的退出和登录而改变进程状态.



