# 规范化规则

---

### 关系是什么

**关系**

		两个不同数据域上的值的集合通过一定的条件得到一个所有可能组合的子集.
		
**行之间没有上下顺序**
		
		在SQL中,查询返回的结果的顺序是不定的,除非使用ORDER BY指定排序规则.当然,除了顺序,结果集中的数据总是一致的.
		
**列之间没有左右顺序**

		无论是让 丁克斌 去处理 1youku-redmine项目中的 #445 BUG,还是我们需要知道 1youku-redmine 的 #445 号 BUG 能否让丁克斌去处理, 最终得到的查询结果应该是一样的.
		
**重复行是不允许的**

		在SQL中,我们对列或者列的集合使用主键约束来确保这一点,而不管是否需要保证记录唯一性.
		
**每一列只有一种类型,每一行只有一个值**

		关系头定了列的名字和数据类型.每一行数据拥有的列和投中的定义必须匹配,且每一列的意义在所有行中必须一致.
		EVA的表违反了这个规则.
		
**行没有隐藏组件**
		
		劣种存储的数据的值,不包含物理存储标示,注入行id.
		这里表达的意思我理解是,数据库中表达的是实际的值,不会隐藏的标识其他概念,列入行号等.
		
### 规范化是什么

1. 以一种我们能够理解的方式表达这个世界中的事物.
2. 减少数据的冗余存储,防止吟唱或者不一致的数据
3. 支持完成性约束
4. 当一张表满足规范化的规则时,我们便称这张表符合**范式**
5. 如果一张表的设计满足某一层及的范式,那这张表一定满足前面所有层级的范式.

#### 第一范式

第一范式的最根本要求是,该表必须是一个关系.每一列都是不可分割的原子数据项.
要求是这张表必须没有重复组合.关系中的每一行,都是从多个集合的每一个集合中选一个值行程的一种组合.重复的组合说明这一行可能有多个来自于同一个集合的值.
		
是指数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。如果出现重复的属性，就可能需要定义一个新的实体，新的实体由重复的属性构成，新实体与原实体之间为一对多关系
		
下列解释:满足第一范式的更合理设计应该是创建一个单独的表,tag占用单独的一列,并且通过每行存储一个标签来支持多个标签的存储.
		
		违反第一范式示例:
		
		bug_id |  tag1  |  tag2  |  tag3   
		-------| -------| -------| ------- 
		1234   |  crash |        |  		
		3456   |  check | crash  |		    
		5678   |  fixed | crash  |  data    
		
		bug_id |  tags  | 
		-------| -------------------------
		1234   |  crash          
		3456   |  check , crash   
		5678   |  fixed , crash  ,  data
		
		
		
		第一范式:
		
		bug_id | 	bug_id | tag	
		-------|	-------| -------   
		1234   |	1234   | crash		      
		3456   |  	3456   | check
		5678   |	3456   | crash
					5678   | fixed
					5678   | crash
					5678   | data
		 
		 
	
#### 第二范式

要求实体的属性完全依赖于主关键字,所谓的完全依赖是指不能存在依赖主关键字的一部分属性.

2NF的违例只会出现在候选键由超过一个字段构成的表中,因为对单关键字字段不存在部分依赖问题.

在第一范式的基础上完全依赖于主键.

##### 示例一

		违反第二范式示例:
		创造者的标识的存储是冗余的.这意味着修改了某一个tag(如crash)的创造者标识,如果没有同步所有相同标签的行,则会导致数据异常.
		PRIMARY KEY (bug_id,tag) 复合主键.
		
		bug_id |  tag   | tagger | coiner |  
		-------| -------| ------ | ------ |
		1234   |  crash | Larry  | Shemp  |
		3456   |  check | Larry  |	Shemp  |	    
		5678   |  crash | Jerry  |	Shemp  |
		
		加入只是修改了 5678 tag为crash 的创造者,则会导致数据异常  
		
		bug_id |  tag   | tagger | coiner |  
		-------| -------| ------ | ------ |
		1234   |  crash | Larry  | Shemp  |
		3456   |  check | Larry  |	Shemp  |	    
		5678   |  crash | Jerry  |	Curly  |
		
		1234,5678 都拥有tag标签为crash,但是创造者不一致.
		
		因为tag创造者只是依赖主关键字的一部分属性(tag).
		
		第二范式:
		我们应该对于每个tag只存储一次它的创造者.额外定义一张表tags,以tag作为主键,这样每一个tag就只有一行了.把tag的创造者从 bugtags 表里移到这张表中.
		
		bug_id |  tag   | tagger |      
		-------| -------| ------ | 
		1234   |  crash | Larry  | 
		3456   |  check | Larry  |	    
		5678   |  crash | Jerry  |	
				
				bugTags
			
		
		 tag   | coiner |      
		-------| -------| 
	     crash | Shemp  | 
	     check | Shemp  |
	     
	     		tags	    
		
##### 示例二

```
    例子：(学号, 姓名, 年龄, 课程名称, 成绩, 学分)

    候选键只有一个，就是(姓名，课程名称)，则主键就是(姓名，课程名称)

    存在如下决定关系：

    1：(学号, 课程名称) → (姓名, 年龄, 成绩, 学分)

    2：(课程名称) → (学分)

    3：(学号) → (姓名, 年龄)

    其中，姓名、年龄、学分是部分依赖于主键的，而成绩是完全依赖于主键的，存在部分依赖关系，所以不满足第二范式。




    解决办法：把原表(学号, 姓名, 年龄, 课程名称, 成绩, 学分)分成三个表：

    学生：Student(学号, 姓名, 年龄)；

    课程：Course(课程名称, 学分)；

    选课关 系：SelectCourse(学号, 课程名称, 成绩)。

```

#### 第三范式

任何非主属性不依赖于其他非主属性.

在`第一范式`例子中,tag创造者`部分`和复合主键属性相关.在`第三范式`里面是指和主属性完全没有一点关联,且依赖于其他非主属性.
	
	
##### 示例一
	
		违反第三范式示例:
		assigned_email 并不是 Bug 的属性,且依赖于assign_to.
		
		bug_id |assign_to| assigend_email  |  
		-------| ------- | --------------- |
		1234   | Larry   |Larry@example.com| 
		3456   | Jerry   |Jerry@example.com|     
		5678   | Larry   |Larry@example.com| 
		
		
		第三范式:
		将E-mail地址放到Accounts表中,在Accounts表中的E-mail是直接和主管关联而没有冗余的.
		
		bug_id |assign_to| 
		-------| ------- | 
		1234   | Larry   |
		3456   | Jerry   |
		5678   | Larry   |
		
		
		account_id |     email       |    
		---------- | --------------- |
		 Larry     |Larry@example.com| 
		 Jerry     |Jerry@example.com|     
		 
		 		Accounts

##### 示例二

```

    例子：表：(学号, 姓名, 年龄, 所在学院, 学院地点, 学院电话)

    该表中候选字段只有“学号”，于是“学号”做主键。由于主键是单一属性，所以不存在非主属性对主键的部分函数依赖的问题，所以必然满足第二范式。但是存在如下传递依赖

    (学号) → (所在学院) → (学院地点, 学院电话)

    学院地点和学院电话传递依赖于学号，而学院地点和学院电话都是非关键字段，即表中出现了“某一非关键字段可以确定出其它非关键字段”的情况，于是违反了第三范式。

```

#### BCNF

比第三范式稍微严格一点的范式版本成为博伊斯-科德范式.

在第三范式中,所有的非关键字列都必须`直接依赖`于这张表中的关键字列,而在BCNF中,所有`关键字列`也必须遵循这一规则(直接依赖,不能部分依赖),这一点在一张表有多种列的集合可作为表的关键字时才有效.

BCNF不存在关键字决定关键字的情况.

##### 示例一 

		违反BCNF示例:
		每一个 BUG 对于每一种 tag 类型只能有一个 tag.可能的键组合包括 bug_id 加上 tag, 或者 bug_id 加上 tag_type. 这两种组合都应该足够定位每一个独立的行.
		
		bug_id |  tag   | tag_type |      
		-------| -------| -------- | 
		1234   |  crash |  impact  | 
		3456   |  check |    fix   |	    
		5678   |  crash |  impact  |
		
		bug_id |  tag   | tag_type |      
		-------| -------| -------- | 
		1234   |  crash |  impact  | 
		3456   |  check |    fix   |	    
		5678   |  crash |subsystem |

		5678 修改了 tag_type, 造成了5678,1234拥有同样的 tag 却是不同的 tag_type.
		
		BCNF	
		
		bug_id |  tag   |     
		-------| -------|
		1234   |  crash |   
		3456   |  check |   	    
		5678   |  crash | 
            bugTags		
		
		
		 tag   | tag_type |      
		-------| -------- | 
		 crash |  impact  | 
		 check |    fix   |	    
			  Tags
				
##### 示例二

```
 假设仓库管理关系表为StorehouseManage(仓库ID, 存储物品ID, 管理员ID, 数量)，且有一个管理员只在一个仓库工作；一个仓库可以存储多种物品。这个数据库表中存在如下决定关系： 

 
　　 (仓库ID, 存储物品ID) →(管理员ID, 数量) 

　　 (管理员ID, 存储物品ID) → (仓库ID, 数量) 


所以，(仓库ID, 存储物品ID)和(管理员ID, 存储物品ID)都是StorehouseManage的候选关键字，表中的唯一非关键字段为数量，它是符合第三范式的。但是，由于存在如下决定关系： 

 
　　 (仓库ID) → (管理员ID) 

　　 (管理员ID) → (仓库ID) 

 
也就是说,(仓库ID, 存储物品ID)这个主键中的仓库ID可以被管理员ID决定, 同样(管理员ID, 存储物品ID)中管理员ID也可以被仓库ID决定,所以此表应该拆分.

```				
				
#### 第四范式

表中不能包含一个实体的两个或多个互相独立的多值因子.

当一个表中的非主属性互相独立时(3NF),这些非主属性不应该有多值.若有多值就违反了第四范式.
	
		违反第四范式:
		
		当尝试使用一张交叉表描述多个多对多关系时,就会违背第四范式.
		
	    bug_id |reported_by|assigned_to|verified_by|      
		-------| --------- | --------- | --------- | 
		1234   |  Jerry    |  Tommy    |    NULL   |
		3456   |  Jerry    |   NULL    |    NULL   |    
		5678   |  Kevin    |  gerry    |    Harry  |
		
		第四范式:
		我们应该为每一种多对多关系使用一张单独的交叉表,这就解决了冗余和数量不匹配的问题.
		
		bug_id |reported_by|    
		-------| --------- | 
		1234   |  Jerry    |  
		3456   |  Jerry    |       
		5678   |  Kevin    |  	
		
		bug_id |assigned_to|      
		-------| --------- | 
		1234   |  Tommy    |   
		5678   |  gerry    |    
		
		bug_id |verified_by|    
		-------| --------- | 
		5678   |  Harry    | 	
		
#### 第五范式
		
任何满足BCNF并且没有复合主键的表将同时满足第五范式.		
将表尽可能的分割成小的表,使之不存在冗余.

#### DK范式

认为表上的每个约束都是这张表的数据域约束和关键字约束的逻辑结果.

比如一个状态为 NEW 或者  DUPLICATE 的 Bug 应该是没有任何工作量的, 因此应该没有工作时间记录, 也不需要在 verified_by 列中指派质量工程师. 可能的实现方式使用一个触发器或者一个 CHECK 约束. 这些都是建在表的`非关键字列上的约束`, 因而他们并`不符合DK范式`.

#### 第六范式

第六范式旨在消除所有的连联结依赖,它通常用来支持属性的变更历史.比如我们可能想要在一张子表中记录下 Bugs.status 随着时间推移产生的变化.合适发生的变更,谁做的变更,以及其他可能的细节.

如果让 Bugs 这张表满足第六范式,几乎每一列都需要附带一个历史记录表.这回导致标的数量过多. 第六范式对于大多数程序来说都是没有必要的,淡一些数据仓库技术里会使用到第六范式.

# 总结 

---

1. 一范式，就是表里的字段不能在划分属性了(就是一个属性不允许再分成多个属性来建立列). **属性不可拆分 或 无重复的列**
2. 满足一范式基础,表里不存在与主关键字没关系的信息. **完全函数依赖**
3. 满足二范式的基础上,表里不存在其他字段的关联. **消除传递依赖**
4. BCNF:满足三范式的基础上,就是表里的每行都不存在重复的信息.
5. 一般关系型数据库设计中,达到BCNF就可以了!
6. 规范化规则只是减少冗余和提高数据一致性的惯用技术方法.
		