# mysql binlog日志的格式

## Row

日志中会记录成**每一行数据被修改的形式, 然后在`slave`端再对相同的数据进行修改.

### 优点

在`row`模式下, `bin-log`中可以不记录执行的`SQL`语句的上下文相关的信息, 仅仅只需要记录那一条记录被修改了, 修改成什么样了. 所以`row`的日志内容会非常清楚的记录下每一行数据修改的细节, 非常容易理解. 而且不会出现某些特定情况下的存储过程或 `function`，以及`trigger`的调用和触发无法被正确复制的问题。

### 缺点

在`row`模式下, 所有的执行的语句当记录到日志中的时候，都将以每行记录的修改来记录，这样可能会产生大量的日志内容，比如有这样一条`update`语句：

```
UPDATE product SET owner_member_id = 'b' WHERE owner_member_id = 'a'  
```

执行之后, 日志中记录的不是这条`update`语句所对应的事件(MySQL 以事件的形式来记录 bin-log 日志), 而是这条语句所更新的每一条记录的变化情况, 这样就记录成很多条记录被更新的很多个事件. 自然, `bin-log`日志的量就会很大. 尤其是当执行`alter table`之类的语句的时候, 产生的日志量是惊人的. 因为 MySQL 对于`alter table`之类的表结构变更语句的处理方式是整个表的每一条记录都需要变动, 实际上就是重建了整个表. 那么**该表的每一条记录都会被记录到日志中**.

## Statement

每一条会修改数据的`SQL`都会记录到`master`的`bin-log`中. `slave`在复制的时候 `SQL`进程会解析成和原来`master`端执行过的**相同的`SQL`再次执行**.

### 优点

在`statement`模式下, 首先就是解决了`row`模式的缺点, 不需要记录每一行数据的变化, 减少了`bin-log`日志量, 节省`I/O`以及存储资源, 提高性能. 因为他只需要记录在 `master`上所执行的语句的细节, 以及执行语句时候的上下文的信息.

### 缺点

在`statement`模式下, 由于他是记录的执行语句, 所以, 为了让这些语句在`slave`端也能正确执行, 那么他还必须记录每条语句在执行的时候的一些相关信息, 也就是**上下文信息**, 以保证所有语句在`slave`端杯执行的时候能够得到和在`master`端执行时候相同的结果. 另外就是, 由于 MySQL 现在发展比较快, 很多的新功能不断的加入, 使 MySQL 的复制遇到了不小的挑战, 自然复制的时候涉及到越复杂的内容, bug 也就越容易出现. 在 statement 中, 目前已经发现的就有不少情况会造成 MySQL 的复制出现问题, 主要是修改数据的时候使用了某些特定的函数或者功能的时候会出现. 比如：sleep() 函数在有些版本中就不能被正确复制, 在存储过程中使用了 last_insert_id() 函数, 可能会使 slave 和 master 上得到不一致的 id 等等. 由于 row 是基于每一行来记录的变化, 所以不会出现类似的问题.

## Mixed

Mixed, 实际上就是前两种模式的结合.

在`Mixed`模式下, MySQL 会根据执行的每一条具体的`SQL`语句来区分对待记录的日志形式, 也就是在`statement`和`row`之间选择一种.

新版本中的`statment`还是和以前一样, 仅仅记录执行的语句. 而新版本的`MySQL`中对 `row`模式也被做了优化, 并不是所有的修改都会以`row`模式来记录, 比如遇到表结构变更的时候就会以`statement`模式来记录, 如果 SQL 语句确实就是 update 或者 delete 等修改数据的语句, 那么还是会记录所有行的变更.