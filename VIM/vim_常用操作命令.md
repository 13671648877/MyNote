# VIM 常用操作命令

---

### 基本命令

#### 移动

##### 基本移动

当`wrap`被启用时(默认被启用), 每个超出窗口宽度的文本行都会被回绕显示, 以保证没有文本显示出来. 这样一来文件中的一行(实际行)也许会被显示为屏幕上的若干行(屏幕行).

`VIM`会区分实际行和屏幕行. 启用`number`设置, 以行号开头的行对应着一个实际行, 它们会占据着屏幕上的一行或几行(屏幕行).

**`j`**

向下移动一个实际行.

**`gj`**

向下移动一个屏幕行.

**`k`**

向上移动一个实际行.

**`gk`**

向上移动一个屏幕行.

**`0`**

移动到实际行的行首.

**`g0`**

移动到屏幕行的行首.

**`^`**

移动到实际行的第一个非空白字符.

**`g^`**

移动到屏幕行的第一个非空白字符.

**`$`**

移动到实际行的行尾.

**`g$`**

移动到屏幕行的行尾.

##### 基于单词移动

* 单词: 有字母,数字,下划线或其他非空白字符的序列组成, 单词以空白字符分隔.
* 字串: 由非空白字符序列组成, 字串间以空白字符分隔.

对应单词有`w`,`b`,`e`,`ge`. 对应字串则是`W`,`B`,`E`,`gE`都是大写.

**`w`**

移至下一个单词的开头.

**`b`**

反向移动到当前单词/上一单词的开头.

`b`和`w`是相对的.

**`e`**

跳至当前或下一个单词的词尾.

`ea`可以理解为在当前单词结尾后添加.

**`ge`**

反向移动到上一个单词的词尾.

**`#w`**

移动`#`个单词.

##### 其他移动

**`Ctrl+o`**

跳回到旧的位置.

CTRL-O goes to the older position, and CTRL-I or tab goes to the newer one. 仅限于normal mode

**`Ctrl+I(i)`**

跳到新的位置.

CTRL-O goes to the older position, and CTRL-I or tab goes to the newer one. 仅限于normal mode

#### 打开文件

**`e[dit] /path/filename`**

允许通过文件的绝对路径或相对路径来打开文件.

可以使用`TAB`自动补全文件.

如果文件不存在, `VIM`就会创建一个新的空白缓冲区.

但是如果文件夹也不存在, 保存就会报错.

```shell
打开不存在的文件夹下面的一个不存在的文件
:edit notExistFolder/notExistFile

随便编辑, 然后保存

:w
"notExistFolder/notExistFile" E212: Can't open file for writing
Press ENTER or type command to continue

需要先创建文件夹
:!mkdir -p %:h
:w
保存成功
```

**`e[dit]! /path/filename`**

不保存当前文件, 然后编辑另一个文件.

可以使用`TAB`自动补全文件.

**`:pwd`**

当因当前工作路径.

**`:edit %:h`**

`%` 代表缓冲区的完整文件路径.

`:h` 修饰符会去除文件名, 但保留路径中的其他部分.

```shell
我们编辑 test/a

:edit %<TAB> 会显示 test/a
:edit %:h<TAB> 会显示 test/
```

不带`:h`会显示当前编辑的`路径/文件名`, 带`:h`会去掉`文件名`, 只保留路径.

**修改`.vimrc` 映射快捷键**

```shell
cnoremap <expr> %% getcmdtype( ) == ':' ? expand('%:h').'/' : '%%'
```

`:edit %:h` 等同于 `:edit %%`.

**以超级用户权限保存文件**

```shell
以管理员身份创建一个文件

用普通用户身份打开这个文件, 进行插入操作时会提示: W10: Warning: Changing a readonly file
随便写点东西进去.

:w 保存会提示 'readonly' option is set (add! to override)
:!w 还是不行

:w !sudo tee % > /dev/null
然后输入当前用户密码(当前用户可以sudo), 选择 (L)oad file
```

`sudo tee % > /dev/null` 这条命令会把缓冲区的内容当做标准输入, 用它来覆盖`%`(当前文件)的内容.

我们可以修改`vimrc`使用`w!!`来代替上述`tee`命令.

```shell
" Allow saving of files as sudo when I forgot to start vim using sudo.
cmap w!! w !sudo tee > /dev/null %
```

#### 查找文件

我在项目目录内, 现在需要查找`Application`目录下的文件.

```shell
:set path+=Application/**

:find User.class.php 就会打开第一个匹配到的文件
:find User.class.php <TAB> 就会一次展开匹配到的文件
```

#### 退出

**`:w[rite] file`**

把缓冲区内容写入启动vim时指定的文件中.

如果指定了`file`, 则保存到`file`中.

**`:e[dit]!`**

把磁盘文件内容读入缓冲区(回滚所做修改)

**`:qa[ll]!`**

关闭所有窗口,摒弃修改而无需警告

**`:wa[ll]!`**

把所有改变的缓冲区写入磁盘.

#### 文件状态

**`C-g`**

显示当前文件的文件名及状态.

##### 插入类

**`i`**

在光标签插入.

**`I`**

到行首插入.

**`a`**

在光标后插入.

**`A`**

在行尾插入.

**`s`**

删除字符并插入.

**`S`**

删除行并插入.

**`<Ctrl+v>{123}`**

以十进制字符编码插入字符.

**`<Ctrl+v>u{123}`**

以十六进制字符编码插入字符

**`<Ctrl+v>u{非数字}`**

按原义插入非数字字符。

**`<Ctrl+k>{char1}{char2}`**

插入以二合字母{char1}{char2}表示的字符

**`ga`**

光标移到任意字符上,按`ga`可以查看十进制和十六进制的编码.

##### 修改类

**`r`**
替换光标处的字符.

**`R`**
进入替换模式,按esc回到正常模式.

**`cj`**

修改下一个字符. 等同于`s`.

**`C or c$`**

修改当前行上光标后面的部分.进入编辑状态

**`c0 or c^`**

表示从光标处到当前行行首的部分进行修改,^代表首个非空格处.

**`cc or S`**

修改当前行.进入编辑状态.

**`cw`**

从光标所在的位置开始到该`单词结束`进行修改.进入编辑状态.

**`cfx AND cFx`**

这里的 x 为一任意字符.

* cfx 表示修改从光标到`下`一个字符 x 之间的文本.
* cFx 表示修改从光标到`上`一个字符 x 之间的文本.

**`cn|`**

修改从光标到当前行的第 n 个字符间的所有字符, n 正整数.

**`cnG and cG`**

这里的 n 为一任意自然数.

* cnG 表示修改当前行到第 n 行之间的所有行.
* cG 表示修改当前行直至末行.

##### 查询

`f`和`t`的区别只是光标停留的地方不一样.

**`fx`**

在行内搜索`x`字母.且光标停在x上.

**`Fx`**

在行内反向搜索`x`字母.且光标停在x上.

**`tx`**

在当前行内搜索`x`,光标停在前一个`x`的前一个字符上面.且光标停在x前.

**`Tx`**

在当前行内反向搜索`x`,光标停在前一个`x`的前一个字符上面.且光标停在x后.

**`;`**

在相同方向重复上一个搜索命令.

**`,`**

在相反方向重复上一个搜索命令.

**`*`**

搜索当前光标所在的词，相当于对当前词进行`/搜索`,比如,光标停在词google内的任何字符上,那么`*命令就相当于/google`.

##### 换行类

**`o`**

在当前光标下行分段.

**`O`**

在当前光标上行分段.

##### 删除类

**`x`**

剪切光标当前字符.

**`dd`**

剪切当前行.

**`daw`**

剪切一个单词. 即使光标不在词首和句首也没关系.

还会删除一个空格, 停留在下一个词的词首,如果没有下一个词则停留在上一个词的词尾.

用`.`命令可以方便的重复执行.

**`das`**

剪切一个句子. 即使光标不在词首和句首也没关系.

**`dap`**

剪切一个段落.

**`d/xxx<CR>`**

删除可以可查找命令一起配合使用. 删除光标到查找到的词首之间的段落.

**`Ctrl+h`**

删除前一个字符,同空格键. ==在bash下同样生效==

**`Ctrl+w`**

删除前一个单词, ==在bash下同样生效==

**`Ctrl+u`**

删除至行首, ==在bash下同样生效==

##### 缩进类

**`>G`**

增加从当前航到文档末尾处的层级缩进.

按照`>`同时安装`G`,可以进行缩进.

可以在执行一次以后按`.`重复执行.

**`<G`**

反方向缩进.

可以在执行一次以后按`.`重复执行.

**`n==`**

表示自动缩进从当前行起的下面n行. `n`是自然数.

直接按`==`表示对当前行缩进.u

##### 重复 和 回退

**`.`**

重复上次命令.

从进入插入模式的那一刻起(例如,输入`i`),直到返回普通模式时为止(输入`<ESC>`),Vim会记录每一个按键操作.作出这样的修改后再用`.`可以重复执行.

**`@:`**

`.`命令可以重复上次的普通模式命令.`@:`可以重复上次的 Ex 命令.

**`u`**

撤销命令.

在进入插入模式开始,知道返回普通模式为止,在此期间输入或删除的任何内容都被当做一次修改.

最好让每个==可撤销块==对应一次==思考过程==.

**修改**

* 重复 `.`
* 回退 `u`

##### 查找

**在行内查找`下`一个指定字符**

`f{char}/t{char}`

* 重复 `;`
* 回退 `,`

`f{char}`移到下一个`{char}`所在之处.

`t{char}`移到下一个`{char}`所在之处的前一个字符上.

**在行内查找`上`一个指定字符**

`F{char}/T{char}`

* 重复 `;`
* 回退 `,`

`F{char}`移到上一个`{char}`所在之处.

`T{char}`移到上一个`{char}`所在之处的后一个字符上.

**`t{char}`和`T{char}`的应用场景**

结合`d{motion`和`c{motion`一起使用时, 较为方便.

```shel
I've been expecting you, Mister Bond.

我们删除you后的","到最后"."之间的内容.

执行 f, 然后 dt. 即可. 因为t是移到"."之前的字符上.
```

**在文档中查找`下`一处匹配项**

`/pattern<回车>`

* 重复 `n`
* 回退 `N`

**在文档中查找`上`一处匹配项**

`?pattern<回车>`

* 重复 `n`
* 回退 `N`

**执行替换**

`:s/target/replacement<回车>`

* 重复 `&`
* 回退 `u`

`[range]s/pattern/replacement/[options]`

* `range`(可选)
	* 如果缺省就指当前行,也就是后面的命令仅对当前行有效.
	* `n,m`: 从第n行到第m行,包括第`n`行和第`m`行.
	* `.`代表当前行.
	* `$`代表最后一行.
	* `%`表示全局, 等同于`1,$`.
* `options`: 可选
	* 缺省时只替换一行中的第一个匹配
	* `g`: 把一行中的所有匹配都替换
	* `c`: 替换之前要求确认
	* `i`: 大小写不敏感
	* `I`: 大小写敏感
	* `e`: 如果`pattern`没有找见不显示错误
	* `|`: 管道分隔命令
	* `update`: 保存

			%s/pattern/replace/ge | update

**执行一系列修改**

`qx{changes}q`

* 重复 `@x`
* 回退 `u`

这个`x`代表是记录到一个名为`x`的寄存器. 可以用其他字符代替.

#### 加法和减法

数字`007`,vim会把其当做`8`进制数字.如果执行`1Ctrl+a`则会变成`010`.即8进制的`8`.如果不想使用`8`进制.需要把下面的行加入`vimrc`:

		set nrformats=

**`#(数字)Ctrl+A`**

会对数字执行 **加n** 操作.

如果当前光标不在数字,则在当前行正向查找一个数字,如果找到了则执行,

**`#(数字)Ctrl+x`**

会对数字执行 **减n** 操作.

如果当前光标不在数字,则在当前行正向查找一个数字,如果找到了则执行,

#### 视角切换

**`zz`**

把当前航显示在窗口正中.

可以配合`Ctrl+o`一起使用.在插入模式`Ctrl+o zz`可以迅速定位到屏幕中央,并且又立即(在普通模式下执行完`zz`命令)返回到插入模式.

#### 普通,命令模式切换

**`Esc`**

切换到普通模式

**`Ctrl+[`**

切换到普通模式

**`Ctrl+o`**

在插入模式执行.在命令模式执行是跳转的意思.

执行**一个**普通模式命令,执行完后,马上就又返回到插入模式.

#### 替换模式

在普通替换模式`R`中,如果键入一个字符,会把一个占据8列的制表符用占据一个字符的普通字符替换(列宽度变小了)(即按文本中保存时占据的列数替换字符).

在虚拟替换模式`g`R中,需要键入8个字符才能替换该制表符(即按屏幕实际显示的宽度替换字符)

单次版本的替换模式及虚拟替换模式`r{char}` 和 `gr{char}`,允许我们覆盖一个字符,之后马上又回到普通模式.

#### 宏

**`qx` `q` `@x`**

首先按`qx`,会提示开始记录宏. 录制完成后按`q`,退出记录模式.

`@x`播放记录在x寄存器中的宏命令

		(按qx) ddsssadasd (esc, 按q)
		(按@x,播放上次的记录) ddsssadasd (按@x,播放上次的记录) ddsssadasd

#### 转换大小写

命令需要组合使用,不能单独使用

		guw,gue 转换一个单词小写.
		gUw,gUe 转换一个单词大写
		
		gu5w 转换5个单词.
		
		gu0 从光标所在位置到行首,都变为大写
		gu$ 从光标所在位置到行尾,都变为小写

**`~`**

反转一个光标处字符大小写.

#### 刷新加载文件

**`e!`**

手动重新加载文件

#### 命令行

就是按`Esc`.

**`:print`**

在命令行下方回显指定行的内容.

缩写是 `:p`.

**`:#(数字)`**

跳到`#`行.

**`:#(start),#(end)`**

指定范围. 第一个`#`表示的是起始行.第二个`#`表示的是结束行.

**`:.`**

`.`表示当前行的地址.

**`:$`**

表示文件最末尾行.

**`:%`**

表示文件所有行. 等效于 `:1,$`.

**`:'<,'>`**

代表高亮选区的范围.

* `'<`: 表示高亮选区首行的位置标记.
* `>'`: 表示高亮选区的最后一行.

**模式指定范围**

`:/<html>/,/<\/html>/p`

* {start} 地址是模式 `/<html>/`
* {end} 地址是模式 `/<\/html>/`

这里地址选择是对应`<html>`开标签所在的行开始,到对应标签所在的行结束.

**偏移地址**

`:{address}+n`.

如果`n`被省略,那么缺省偏移量为`1`.`{address}`可以是一个行号,一个位置标记,或是一个查找模式.
	
		:2
		:.,.+3p
		
		符号 . 代表当前航,所以上例相当于 :2,5
		
**`:copy`**

可以把文档的一行或多行从文档的一部分复制到另一部分.

`:[range]copy {address}`

可以简写为:

* `:co`
* `:t`

		:6t. 把第6行复制到当前行下方
		:t6	 把当前行复制到第6行下方
		:t.  为当前行创建一个副本(复制黏贴当前行)
		:t$	 把当前行复制到文本结尾
		:'<,'>t0 把高亮选中的行复制到文件开头
		
`:t.` 效果等同于 `yyp`. 但是 `yyp` 会使用寄存器.

**`:move`**

可以把文档的一行或多行移到文档的其他地方.

`:[range]move {address}`

#### 全局命令 `g`

* `:[range]g/pattern/cmd`
* `:g/pattern1/,/pattern2/cmd`

        :g/test/d
        删除所有带test的行
        :g!/test/d 或者 v/test/d
        保留带test的行
        :g/hello/,/world/d
        删除所有hello,world之间的行

#### 可视模式,选择模式

**`v`**

激活面向字符的可视模式.

**`V`**

激活面向行的可视模式.

**`Ctrl+v`**

激活面向块的可视模式.

**`Ctrl+g`**

在可视模式中可以切换为选择模式.

* `--VISUAL--` 可视模式
* `--SELECR--` 选择模式

#### 文本对象选择

操作成对出现的标签"{}","''"...的利器, 也方便操作`xml`标记.

```shell
{aaaabbb}
```

理解两个操作符`i`(inside)和`a`(around);

我们先把光标移动到`{}`内或者括号上

操作+ `i/a` + 标记(这里是"}").

如果是`i`, 则括号里的内容被选中. 如果是`a`, 则包括括号的内容被选中.

```
{aaabb}

操作: vi} = aaabb 被选中
     va} = {aaabb} 被选中
 
"aaabb"
	 ci" = aaabb 被删除带替换
	 ca" = "aaabb" 被删除待替换
```

 如果标记时`t`, 则是针对`xml`标签操作.
 
 ```
 <xml>aabb</xml>
 
 cit == aabb 被删除待替换
 cat == <xml>aabb</xml> 被删除待替换
 ```
 
 **其他的一些标签**
 
 * `iw` 当前单词
 * `aw` 当前单词及一个空格
 * `iW` 当前字串
 * `aW` 当前字串及一个空格
 * `is` 当前句子
 * `as` 当前句子及一个空格 
 * `ip` 当前段落
 * `ap` 当前段落及一个空行

 ```
 caw 在一个句子中删除一个单词
 ciw 在一个句子中替换一个单词
 ```

#### 括号间跳转

作用于`()`,`{}`和`[]`

`%` 在一组开,闭括号间跳转.

只能工作在成对的括号上.

在修改括号上, 可以先修改一个括号, 然后使用"\`\`"(当前文件中上次跳转动作之前的位置)跳回去修改另外一个括号.(因为当修改了一侧的括号以后, 括号就不是成对出现的, 不能再使用`%`)

#### 标记 (mark)

利用标记可以快速移动.

**添加标记**

光标移到某一个行,使用`m{a-z,A-Z}`命令添加标记.

* `a-z` 引用于当前缓冲区.
* `A-Z` 跨越不同的缓冲区.比如正在编辑`File1`,但仍然可以使用`'A`命令,移动到`File2`中创建的标记`A`.

**跳转标记**

* **'{ch}** 跳到指定标记行的首个非空字符.
* **`{ch}** 移到所做标记时的光标位置.

**Vim的自动位置标记**

* `` 当前文件中上次跳转动作之前的位置
* `. 上次修改的地方
* `^ 上次插入的地方
* `[ 上次修改或复制的起始位置
* `] 上次修改或复制的结束位置
* `< 上次高亮选区的起始位置
* `> 上次高亮选区的结束位置

**列出标记**

`:marks`,可以列出所有标记.也包括一些系统内置的特殊标记:

* . ——最近编辑的位置
* 0-9 ——最近使用的文件
* ∧ ——最近插入的位置
* ' ——上一次跳转前的位置
* " ——上一次退出文件时的位置
* [ ——上一次修改的开始处
* ] ——上一次修改的结尾处

**删除标记**

`:delmarks a b c`, 可以删除某个或多个标记

`:delmarks!`,会删除所有标记. 只删除当前的,不删除`A-Z,0-9`.

#### normal 命令

**`[range]normal xx`**

在某个范围重复执行`xx`命令.

		:%normal A;
		
		符号%代表整个文件范围,VIM在文件每行末尾添加一个分号.在此修改时会切换到插入模式,但是在修改完后Vim会自动返回到普通模式.

#### 命令自动补全

在命令模式下:

`Ctrl+d`会让Vim显示可用的补全列表.

`Tab` 会依次显示命令.

`Shift+Tab` 会反向显示.

#### 把当前单词插入到命令行

**Ctrl+w&Ctrl+r**

在命令行模式下,会把光标指向的单词复制黏贴到命令行内.

#### 回溯历史命令

在命令行内, 按 `<UP>` 和 `<Down>` 可以回滚历史命令执行记录.

		:c 这时候在按上下键,会过滤出以字母`c`开头的命令

**`q:`**

命令行历史窗口,在命令行窗口内我们可以编辑过去执行的命令.

`Enter` 会执行命令.

**`q\`**

打开查找命令历史的命令行窗口.

#### VIM 中运行命令

**`:!`**

在命令前加一个`!`就可以执行外部命令.

`%` 代表当前文件名.

**`:[定位]read !{cmd}`**

在`shell`中执行`{cmd}`,并把其标准输出插入到光标下方.

```shell
在第5行输出执行ls的结果.
5read !ls
```

**`:shell`**

运行该命令会启动一个交互的`shell`会话.在此按`exit`后回到`vim`.

也可以使用`Ctrl+z`挂起`Vim`所属的进程.

		jobs 查看当前作业列表
		fg %1 唤醒别挂起的作业
		
**`:[range]!{cmd}`**(比较有用)

由`[range]`所指定的行会传给`{cmd}`当做标准输入,然后又会用`{cmd}`的输出覆盖`[range]`内原本的内容.

```shell
first name,last name, email
johb,smith,johb@example.com
drew,neil,drew@example.com
jane,doe,jane@example.com

:2,$!sort -t',' -k2

first name,last name, email
jane,doe,jane@example.com
drew,neil,drew@example.com
johb,smith,johb@example.com
```			

### vim缓冲区

我们所编辑的只是文件在内存中的映像,也就是VIM术语中的==缓冲区==.

文件是存储在磁盘上的,缓冲区则存在于内存中.当 VIM 打开一个文件时,该文件的内容被读入一个具有相同名字的缓冲区.
	
		一次打开多个文件
		vim *.txt
		
**`:ls`**

`:ls`命令会列出所有被载入到内存中的缓冲区的列表.
		
		:ls
		  1 %a   "phpcs.xml"                    line 1
		  2      "phpunit.xml"                  line 0
		  3      "ruleset.xml"                  line 0
		  
**`:bnext` `:bprev`**

`:brev`命令可以切换到列表中的上一个缓冲区.

`:bnext`命令可以切换到列表中的下一个缓冲区.

`:bfirst`跳至列表的开头.

`:blast`跳至列表的结尾.
		
		:bnext
		:ls
		  1 #    "phpcs.xml"                    line 1
		  2 %a   "phpunit.xml"                  line 1
		  3      "ruleset.xml"                  line 0
		
* `%` 致命哪个缓冲区在当前窗口可见.
* `#` 代表轮换文件.`Ctrl+^`可以在当前文件和轮换文件间快速切换.
* `数字` 由 VIM 自动分配的编号.`buffer N`命令凭编号直接跳到一个缓冲区.

`:buffer {bufname}` 只需包含文件路径中足以唯一标识此缓冲区的字符即可.

#### 删除缓冲区

每次打开一个文件时, VIM 就会创建一个新的缓冲区.

`:bdelete` 删除缓冲区

	:bdelete N1, N2, N3
	:N,M bd(bdelete)

删除一个缓冲区并==不会==影响缓冲区所关联的文件,而只是简单地把该文件在内存中的映像删除掉.

#### 参数列表将缓冲区分组

`:args` 可清空并重新设置参数列表.

**`:args`**

```vim
vim *.php
:args
	
[AddDistributionProductCommandHandler.class.php]
DeleteDistributionProductCommandHandler.class.php
DistributionProductCommandHandlerFactory.class.php
OffDistributionProductCommandHandler.class.php
OnDistributionProductCommandHandler.class.php
SaveDistributionProductPricesCommandHandler.class.php
```	
	
`[]`字符则指明参数列表中哪个文件时活动文件.

当不带参数运行 `:args` 命令时,会打印当前参数列表的内容.	
```
:args {arglist}
```

`arglist`:

* 文件名
* 通配符
* shell命令的输出结果

		vim
		
		//把 test 文件加载到内存中,vim 可以显示 test 内容
		:args test
		
		//把当前目录所有文件打开
		:args `ls`
		
**`:args` 通配符**

* `*`: 匹配 0个 或 多个 字符.范围局限于指定的目录.
* `*.*`: 匹配 0个 或 多个 字符.可以递归的进入指定目录的子目录.


**`:args` shell命令**

Vim 会在 shell 中执行反撇号(\`)括起来的命令.然后在把命令的输出作为`:args`命令的参数

		:args `shell命令`

**`:argdo`**

命令以另一个命令为参数. 该命令将对所有待编辑的文件都执行一次.

```shell
替换缓冲区所有文件并更新

argdo %s/搜索字符/替换字符/ge | update
```

#### 分隔窗口

**水平窗口分隔**

* `:split` (打开另一个窗口看同一文件), 简写是`sp`
	* `:edit 文件名` 随后使用该命令将这个文件载入缓冲区.
* `:split 文件名`（开启另一个窗口察看指定文件, 等同于上面两步)

**垂直窗口分隔**

* `:vsplit` 简写是`vsp`或`vs`
	* `:edit 文件名` 随后使用该命令将这个文件载入缓冲区. 
* `:vsplit 文件名`

##### 窗口切换

等同于`hjkl`移动操作符号

* `<C-w>w` 在窗口间循环切换
* `<C-w>h` 切换到左边的窗口
* `<C-w>j` 切换到下边的窗口
* `<C-w>k` 切换到上面的窗口
* `<C-w>l` 切换到右边的窗口

##### 关闭窗口

* `:clo[se]` 关闭活动窗口
	* 等同于`<C-w>c`
* `:on[ly]` 只保留活动窗口, 关闭其他所有窗口
	* 等同于`<C-w>o`

#### 标签页

##### 打开及关闭标签页

`:tabe[dit] {filename}` 打开一个新的标签页. 如果省略`{filename}`那么`Vim`会创建一个新的标签页, 里面包含一个空的缓冲区.

* `:tabec[lose]` 关闭当前标签页及其中所有窗口.
* `:tabo[nly]` 只保留活动标签页, 关闭所有其他标签页

##### 在标签页间切换

* `:tabn[ext] {N}` 切换到编号为`{N}`的标签页, 如果省略`{N}`, 则跳到下一个
	* `{N} gt`
* `:tabp{revios}` 反向跳到上`{N}`个标签
	* `{N} gT`

##### 重排标签页

`:tabmove {N}` 命令重新排列标签页. 把当前标签页移到第`{N}`个标签之后.

* 当`{N}`为`0`时, 当前标签页会移到==开头==.
* 如果省略`{N}`, 当前标签页会被移到==结尾==.

#### 跳转 (面包屑)

使用`<C-o>`后退, 使用`<C-i>`前进, 可以在`vim`的跳转列表进行遍历.

`:jumps`可以查看跳转列表的内容, 数字越小表示最新的一次跳.

`[count]G(gg)`会被当做一次跳转. 但是向上向下移动一行**不会**被当做跳转.

每个窗口都拥有一份自己的跳转列表.

##### 跳转和移动的区别

大范围的动作命令可能会被当做跳转.

小范围的动作命令则只能算移动.

##### 常用跳转命令

* `[count]G` 跳转到指定行
* `/pattern`(回车) n:上一个 N:下一个
* `/?pattern`(回车) n:上一个 N:下一个
* `%`: 跳转到匹配的括号所在处.
* `(`: 跳到上一句的开头
* `)`: 跳到下一句的开头
* `{`: 跳到上一段落的开头
* `}`: 跳到下一段落的开头
* `H`: 跳到屏幕最上方
* `M`: 跳到屏幕中间
* `L`: 跳到屏幕最下方
* `gf`: 跳到光标下的文件名, 如果内容是文件名则打开该文件
* `<C-]>`: `ctags` 跳转到光标下的关键字的定义之处.

##### 改变列表

`vim`会在编辑会话期间维护一张表, 里面记载我们对**每个缓冲区**所做的修改.

`:changes`查看改变列表.

* `g;`: 反向遍历改变列表, 即在当前文件遍历改变的点.
* `g,`: 正向遍历改变列表

我们打开一个文件按`g;`即可跳到上次**完成编辑时**光标所在的位置.

* **\`**. : 标记是指向**上次修改**的位置.
* **\`^** : 标记是指向**上次退出插入模式**的位置.

这两者的区别, 比如我编辑了如下

```shell
aaa


```

如果我在第三行进入插入模式但是什么都不做然后退出, **\`.**就指向aaa后面, **\`^** 会指向第三行

###### \`. 和 g; 的区别

大多数场景下 **\`.**和**g;**相同, 但是**\`.**总是指向最后修改的位置, **g;**每次都会把我们带到改变列表中较早的一个位置.

###### \`^ 和 gi 的区别

**gi**会用**\`^**恢复的位置, 并切换到插入模式.

##### 跳转到光标下的文件`gf`

Vim会把文档中的文件名当成一个超链接, 可以使用`gf`命令跳转到光标下的文件.

但是假如我们使用`.php`后缀, 就需要制定文件的扩展名. 这样当Vim用`gf`命令搜寻文件名时, 会尝试使用这些扩展名.

```shell
:set suffixesadd+=.php
```

每次使用`gf`命令时, Vim 都会在跳转列表增添一条记录. 使用`<C-o>`后退, 使用`<C-i>`前进进行遍历.

如果我们跳转到文件在别的路径下, 可以通过配置`path`, 可以把它配置成一个以**逗号**分隔的目录列表. 当使用`gf`命令时, Vim会检查`path`目录列表中的每个目录, 看该目录下是否包含一个匹配光标下文本的文件名.

##### 用全局位置标记在文件间快速跳转

`m{letter}`允许我们在当前光标位置创建一个位置标记, **小写**字母会创建**局部**于缓冲区的标记, **大写**字母创建**全局**标记. **\`{letter}**命令是光标快速回到标记所在之处.

假设我们使用`vimgrep`查找一个关键字, 会直接跳到它所找到的第一个匹配上, 这或许会切换到另外一个文件. 假设我们遍历了很多文件找见想找的内容, 想回去的话`<C-o>`会反向遍历跳转列表(所有). 所有最好在使用`vimgrep`之前, 执行`mM`添加一个标记, 那么在执行完查询之后就可以使用**\`M**跳转回去了.

### 示例

**在行尾添加`;`**

1. `A`到行尾处添加
2. `;`添加分号
3. `<ESC>`回到命令模式

如果要修改其他行可以移动到其他行,然后按`.`重复添加`;`的命令.

**指定多行删除**

VI中的多行删除与复制
法一：
单行删除，：1（待删除行）d
多行删除 ，：1,10d

**批量添加注释**

在10 - 20行添加 // 注释

		:10,20s#^#//#g
		
在10 - 20行删除 // 注释

		:10,20s#^//##g
		
在10 - 20行添加 # 注释

		:10,20s/^/#/g
		
在10 - 20行删除 # 注释

		:10,20s/^/#/g
		

**多行复制**

复制`9-15`行, 黏贴到`16`行.

		:9，15 copy 16  或 :9，15 co 16
		
**多行剪切**

剪切`9-15`行, 黏贴到`16`行.

		:9，15 move 16  或 :9，15 m 16
		
**批量查找**

		:vimgrep /搜索内容/*
		
* `:cnext(:cn)`         下一个匹配位置
* `:cprevious(:cp)`     上一个匹配位置
* `:cwindow(:cw)`     	 quickfix窗口，可以选择匹配的文件位置
* `:cl(:clist)`         查看所有匹配的位置

**快捷操作文件**

		:new 文件名.后缀 新建文件
		
		:e 文件名 打开文件
		
		:w 文件名 保存文件
		
		:wq	保存呢并推出
		
		:x 退出, 如果文件更改则保存
		
**自动折行**

		:set wrap 设置自动折行
		:set nowrap 设置不自动折行
		
#### 复制黏贴

##### `p`和`P`

* `p`将寄存器中的文本黏贴到光标之后.
* `P`将寄存器中的文本黏贴到光标之前.

##### 调换光标之后的两个字符

`xp`用于调换光标之后的两个字符.

**面向字符的复制或者删除操作, 将创建面向行的寄存器**

##### 调换问本行

`ddp`调换当前行和它的下一行. 剪切和黏贴操作.

**面向行的复制或者删除操作, 将创建面向行的寄存器**

##### 创建一行的副本

`yyp`创建一行的副本. 复制和黏贴操作.

##### 复制一个单词

* `ycw/yiw`光标必须处在该单词的任何位置.
* `yw`: 复制单词的时候光标必须在词首.

#### 寄存器

通过给命令加`"{register}`前缀的方式指定要用的寄存器. 若不指明, `Vim`将缺省使用无名寄存器.

##### 删除

删除会先把指定文本**复制到寄存器**后再从文档中删掉.

`"_d`删除不复制到任何寄存器中.

`"_`是黑洞寄存器. 放到这里的文本有去无回.

##### 寄存器示例

```
"ayiw 把当前单词复制到寄存器a中
"bdd 把当前整行文本剪切至寄存器b中

"ap 黏贴来自寄存器a中的单词
"bp 黏贴来自寄存器b中的整行数据
```

```
:delete c 把当前行剪切到寄存器 c 中
:put c 将其黏贴至当前光标所在行下
```

##### 无名寄存器

`""`用两个双引号表示无名寄存器.

##### 复制专用寄存器`"0`

使用`y{motion}`命令, 要**复制**的文本不仅会被拷贝到无名寄存器中, 而且也被拷贝到复制专用寄存器中, 后者可用数字`0`.

只用使用`y{motion}`命令时, 才会覆盖复制专用寄存器.

##### 查看寄存器内容

```
查看无名寄存器, 复制专用寄存器内容
:reg "0
```

##### 有名寄存器(`"a-"z`)

**小写**字母引用有名寄存器, 会覆盖该寄存器的原有内容. (覆盖)

**大写**字母会将内容添加到该寄存器的原有内容之后. (添加之后)

##### 黑洞(`"_`)

黑洞寄存器是个有去无回的地方, 可用**下划线**引用它.

`"_d{motion}`删除一行, 不保存到无名寄存器, 保存到黑洞寄存器(即不保存删除的内容).

##### 表达式寄存器(`"=`)

插入模式`<C-r>=`就可以访问表达式寄存器, 然后输入表达式, 按`<CR>`获取执行结果.

```
插入模式按 <C-r>=

=1+2 <CR>

光标的地方显示 3
```

##### 其他寄存器

只读寄存器.

* `"%` 当前文件名.
* `"#` 轮换文件名, 如果跳到新文件, 该寄存器是上个文件名.
* `".` 上次插入的文本.
* `":` 上次执行的`ex`命令.
* `"/` 上次查找的文本.

##### 插入模式使用寄存器

`<C-r>{register}`

在插入模式`<C-r>"`插入无名寄存器的内容. `<C-r>0`插入复制专用寄存器的内容.

##### 串行和并行方式访问宏

串行方式访问宏: `#@宏`, 执行`#`次宏.

并行方式访问宏: 使用`visual`模式选中要执行宏的区域. 

`'<, '>normal xxx`: 对高亮区域选中的每一行执行普通模式下的命令.

##### 追加命令到宏

`qa`录制接下来的按键操作, 并将它们保存到寄存器`a`中, 这会覆盖原有的内容.

`qA`录制接下来的按键操作, 但是会**追加**到寄存器`a`原有的内容之后.

##### 在一组文件中执行宏

`:argdo`允许对参数列表内的所有缓冲区执行一条`Ex`命令.

对参数列表的所有缓冲区内执行宏.

```
:argdo normal @a
```

或者在宏命令后添加`:next`, 则在执行每一个宏后则跳转至下一个缓冲区.

#### paste 选项

`:set paste`开启`paste`选项, 则复制代码不会出现乱行.

`:set nopaste`关闭.

#### 取消高亮搜索

```
:nohlsearch
```