# 第二节

---

[视频地址](http://v.youku.com/v_show/id_XNjA5Nzk2OTMy.html)

##笔记

---

**容易混淆的值对象**

* 值对象只关心内容不关心标识
* 界限上下文: 可能在A领域是实体,在B领域是值对象

**为什么值对象是不可变的**

* 原子类型是不可变的
* 线程安全

**列表作为值对象**

* 列表必须作为一个整体拥有值对象的语义

		String是Char的列表,String是值语义

**值语义**

* 所谓值语义是一个对象被系统标准的复制方式复制后,与被复制的对象之间毫无关系,可以彼此独立改变互不影响

		clone
* 优点
	* 避免别名问题导致的意外修改
	* 避免对共享资源的引用引起的释放时机和额外的引用计数问题
* 缺点
	* 占用较多内存
* 应用
	* 通常将具有“等价性”的对象实现为值语义,如Money,你的10块钱跟我的10块钱没什么两样,完全可以换过来用

**对象语义**

* 也叫指针语义,引用语义等,通常是指一个对象被系统标准的复制方式复制后,与被复制的对象之间依然共享底层资源,对任何一个的改变都将改变另一个
* 优点
	* 占用较少内存
* 缺点
	* 别名问题导致的意外修改,尤其应主意用于模块间接口的参数和返回值
	* 资源释放的额外负担,通常是引用计数
* 应用
	* 通常将必须保持“同一性”的对象实现为对象语义,如帐户,虽然你的帐户和我的帐户此时都只剩100块钱了,但你的是你的,我的是我的,将来你发了财也只会存到你帐户上;具有“同一性”的对象通常在系统中有唯一ID,这类对象通常不可复制,因为复制没有现实意义,如网络端口,数据库链接


**值对象和值语义的区别**

* 值:	死的,傻的,简单的,具体的,可复制的
* 对象:	活的,聪明的,复杂的,抽象的,不可复制的 

复杂性是指行为的复杂性,而非结构的复杂性


**实体间的关系**

* 关系越多，耦合越大
* 找出整个业务声明周期都依赖的关系,某些关系或许只在对象创建时刻有意义

		必读下订单时候和产品的依赖的关系 
		
* UML里画出来的关系才是关系,而非数据库里的关系

**聚合**

* 聚合是 一簇相关联的对象,处于封装的目的,将这些对象作为一个单元(业务,持久化和并发)
* 每个聚合都有一个边界和一个根
* 边界定义了聚合中应该包含什么
* 根是聚合中唯一允许被外部引用的元素,在聚合边界内,对象之间可以相互引用
* 聚合根使用全局标识,由仓储负责其持久化相关的生命周期,实体使用局部标识,由聚合跟负责其持久化生命周期,包括业务相关的生命周期


**聚合的一致性**

* 聚合内的一致性由`聚合自身`负责维护
* 跨聚合的一致性由`服务`负责维护

**一致性的最高目标是啥**

* 应用层随意的使用领域模型,不会导致模型处于非法的状态
* 反射除外,反射可能会绕过某些封装


**如何保证聚合内的一致性?**

* 对聚合内的任何修改都要经过聚合根,聚合跟负责一致性检查
* 聚合内除了聚合根之外的实体只能被临时使用
* 值对象因为拥有了值语义,天生安全


**聚合的声明周期**

* Factory.Create() 创建对象
* 仓储 存放持久化

**仓储**

* 仓储面向和管理的是聚合,而不是传统数据库对应的一行或一个模型
* 仓储是DAO 和 DAL


**信息专家模式**

* 如果将职责分配给某个类型,则这个类型必须拥有完成职责所需的信息.
	* 工厂封装了领域模型的创建职责
	* 仓储封装了聚合的持久化职责
	* 实体和聚合根封装了保证自身一致性的职责

**服务**

* 服务封装了保证跨聚合一致性的职责

###一些问题

* 反射
* 依赖注入
* DAO
* DAL

**DAL**

DAL为数据访问层(Data Access Layer),可以理解为DAL`放数据库操作`.

三层架构为:

* 表示层(USL)
* 业务逻辑层(BLL)
* 数据访问层(DAL)

**DAO**

DAO(Data Access Object)是一个数据访问接口,可以理解为DAO`放ORM映射`.


