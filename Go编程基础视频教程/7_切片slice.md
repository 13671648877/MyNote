#7 切片slice

[地址](http://edu.51cto.com/lesson/id-32312.html "地址")

###笔记

---

**切片slice**

* 本身并`不是数组`, 它`指向`底层的`数组`(slice 的底层用数组表示).
* 作为变长数组的替代方案,可以关联底层数组的局部或全部
* `引用类型`.
* 可以直接创建或从底层数组获取生成.
* 使用`len()`获取元素个数, `cap()`获取容量.
* 一般使用`make()`创建.
* 如果多个slice指向相同底层数组, 其中一个的值改变会影响全部(引用类型特性).
	
		a := []int{1,2,3,4,5}
		s1 := a[2:5]
		s2 := a[1:3]
		fmt.Println(s1,s2)
		s1[0] = 9
		fmr.Println(s1,s2)
		
		输出:
		[3 4 5] [2 3]
		[9 4 5] [2 9] //s1[0] = 9,其中一个的值改变会影响全部
	
* `make([]T, len, cap)`.
* 其中`cap`可以省略,则和`len`的值相同.
* `len`表示存数的元素个数,`cap`表示容量.

**示例**

		var s1 []int//slice 声明, 数组[]中会有"数字"或"..."
		输出:[]
		
		a := [10]int{1,2,3,4,5,6,7,8,9,10}
		fmt.Println(a);
		s1 := a[9]
		fmt.Println(s1);
		输出:
		[1,2,3,4,5,6,7,8,9,10]
		10
		
		s1 := a[5:10]//包含起始索引,不包含终止索引,等价于 a[5] a[6] a[7] a[8] a[9]
		输出:
		6 7 8 9 10
		
		s1 := a[5,len(a)]//等价于 a[5:10]
		s1 := a[5:]//等价于 a[5:10]
		s1 := a[:5]//前5个元素
		
		
`make函数声明`:
		
		//3: 初始化3个int 放到数组.
		//10: 10小块连续的内存,容量.如果需要放入11个元素,需要重新分配,go 一般是增加一倍 10 -> 20.
		//s1 := make([]int,10,10),在放入1个元素,slice会自动扩容到20,会重新分配长度为20的连续内存块.如果在超,20分配40.因为重新分配内存效率较低.
		
		s1 := make([]int,3,10)
		fmt.Println(len(s1),cap(s1))
		输出:
		3 10
		
		s1 := make([]int,3)
		fmt.Println(len(s1),cap(s1))
		输出:
		3 3 //最大容量就是当前的长度

**Reslice**

在slice上再一次slice

* `Reslice`时索引以被slice的切片为准
* `索引`不可以超过被slice的切片的容量 `cap()` 值 (超出这个值不属于这个内存片的范围)
* `索引越界`不会导致底层数组的重新分配而是引发错误 

**Append**

* 可以在slice尾部追加元素
* 可以将一个slice追加在另一个slice尾部
* 如果最终长度`未超过`追加到slice的容量则返回原始slce (`<=`)
* 如果`超过`追加到的slice的容量则将`重新分配数组`并`拷贝原始数组`

		s1 := mak([]int,3,6)
		fmt.Printf("%p",s1)//打印内存地址
		s1 = append(s1,1,2,3)
		fmt.Printf("%v %p",s1,s1)
		
		输出:
		//内存地址一致,因为容量最多6个元素
		0xf84002c700
		[0 0 0 1 2 3] 0xf84002c700

		//再追加3个元素
		s1 = append(s1,1,2,3)
		fmt.Printf("%v %p",s1,s1)
		
		0xf84002c700
		[0 0 0 1 2 3] 0xf84002c700
		[0 0 0 1 2 3 1 2 3] 0xf840000cf0//超过容量6,分配新的内存地址
		
**copy**

		s1 := []int{1,2,3,4,5,6}
		s2 := []int{7,8,9}
		copy(s1,s2)//将 s2 复制到 s1 中
		fmt.Println(s1)
		
		输出:
		[7 8 9 4 5 6]
		
###整理知识点

---