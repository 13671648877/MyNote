#6 数组ARRAY

[地址](http://edu.51cto.com/lesson/id-32308.html "地址")

###笔记

---

**数组Array**

* 定义数组的格式: `var<varName> [n]<type>, n >= 0`.

		var a [2]int
		
		a := [2]int{1,1} // 输出 [1 1]
		a := [2]int{1} // 输出 [1 0]
		a := [2]int{1:1} // 输出 [0 1], 使用索引 key:value
		a := [...]int{1,2,3,4,5} //使用"..."代替"n", 长度根据值自动得出
		a := [...]int{1:1} // 省略长度,输出 [0 1], 使用索引 key:value

* 数组长度也是类型的一部分, 因此具有`不同长度的数组为不同类型`.

		var a [2]int
		var b [1]int
		b = a //不合法,长度不同,类型不同

* 注意区分`指向数组的指针`和`指针数组`.
	
		指向数组的指针:
		
		a := [...]int{1:1}
		var p *[2]int = &a 	 //指向数组的指针
		输出p:	
		&[0,1]//前面多了一个"&", 代表取该值的地址.
		
		指针数组:
		
		x, y := 1, 2
		a := [...]*int{&x,&y} //指向int型的指针
		输出a:
		[0xf840... 0xf8400...]//保存了2个指针,而不是实际的值. x的地址, y的地址

* 数组在Go中为值类型

		传递到方法或函数当值,传递是拷贝,而不是引用(其他语言一般为了节省内存是引用)

* 数组之间可以使用`==`或`!=`进行比较(相同类型之间), 但不可以使用`<`或`>`.

		a := [2]int{1,2}
		b := [2]int{1,2}
		
		fmt.Println( a == b)
		
		输出:
		true

* 可以使用`new`来创建数组, 次方法返回一个`指向数组的指针`.

		p := new([10]int)
		
		fmt.Println(p)
		
		输出:
		
		&[0 0 0 0 0 0 0 0 0 0]

* `指向数组的指针`和`指针数组`都可以使用索引来操作

		 a := [2]int{}
		 a[1] = 2
		 fmt.Println(a)
		 p := new([2]int)
		 p[1] = 2
		 fmt.Println(p)
		 
		 输出:
		 [0 2]
		 &[0 2]
		
* Go支持多维数组.

		a := [2][3]int{
			{1,1,1},
			{2,2,2}
		}
		
		输出:
		[[1 1 1] [2 2 2]]
		
###整理知识点

---